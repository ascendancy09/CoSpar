%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Main}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{0}


% Jupyter Notebook code cell colors
\definecolor{nbsphinxin}{HTML}{307FC1}
\definecolor{nbsphinxout}{HTML}{BF5B3D}
\definecolor{nbsphinx-code-bg}{HTML}{F5F5F5}
\definecolor{nbsphinx-code-border}{HTML}{E0E0E0}
\definecolor{nbsphinx-stderr}{HTML}{FFDDDD}
% ANSI colors for output streams and traceback highlighting
\definecolor{ansi-black}{HTML}{3E424D}
\definecolor{ansi-black-intense}{HTML}{282C36}
\definecolor{ansi-red}{HTML}{E75C58}
\definecolor{ansi-red-intense}{HTML}{B22B31}
\definecolor{ansi-green}{HTML}{00A250}
\definecolor{ansi-green-intense}{HTML}{007427}
\definecolor{ansi-yellow}{HTML}{DDB62B}
\definecolor{ansi-yellow-intense}{HTML}{B27D12}
\definecolor{ansi-blue}{HTML}{208FFB}
\definecolor{ansi-blue-intense}{HTML}{0065CA}
\definecolor{ansi-magenta}{HTML}{D160C4}
\definecolor{ansi-magenta-intense}{HTML}{A03196}
\definecolor{ansi-cyan}{HTML}{60C6C8}
\definecolor{ansi-cyan-intense}{HTML}{258F8F}
\definecolor{ansi-white}{HTML}{C5C1B4}
\definecolor{ansi-white-intense}{HTML}{A1A6B2}
\definecolor{ansi-default-inverse-fg}{HTML}{FFFFFF}
\definecolor{ansi-default-inverse-bg}{HTML}{000000}

% Define an environment for non-plain-text code cell outputs (e.g. images)
\makeatletter
\newenvironment{nbsphinxfancyoutput}{%
    % Avoid fatal error with framed.sty if graphics too long to fit on one page
    \let\sphinxincludegraphics\nbsphinxincludegraphics
    \nbsphinx@image@maxheight\textheight
    \advance\nbsphinx@image@maxheight -2\fboxsep   % default \fboxsep 3pt
    \advance\nbsphinx@image@maxheight -2\fboxrule  % default \fboxrule 0.4pt
    \advance\nbsphinx@image@maxheight -\baselineskip
\def\nbsphinxfcolorbox{\spx@fcolorbox{nbsphinx-code-border}{white}}%
\def\FrameCommand{\nbsphinxfcolorbox\nbsphinxfancyaddprompt\@empty}%
\def\FirstFrameCommand{\nbsphinxfcolorbox\nbsphinxfancyaddprompt\sphinxVerbatim@Continues}%
\def\MidFrameCommand{\nbsphinxfcolorbox\sphinxVerbatim@Continued\sphinxVerbatim@Continues}%
\def\LastFrameCommand{\nbsphinxfcolorbox\sphinxVerbatim@Continued\@empty}%
\MakeFramed{\advance\hsize-\width\@totalleftmargin\z@\linewidth\hsize\@setminipage}%
\lineskip=1ex\lineskiplimit=1ex\raggedright%
}{\par\unskip\@minipagefalse\endMakeFramed}
\makeatother
\newbox\nbsphinxpromptbox
\def\nbsphinxfancyaddprompt{\ifvoid\nbsphinxpromptbox\else
    \kern\fboxrule\kern\fboxsep
    \copy\nbsphinxpromptbox
    \kern-\ht\nbsphinxpromptbox\kern-\dp\nbsphinxpromptbox
    \kern-\fboxsep\kern-\fboxrule\nointerlineskip
    \fi}
\newlength\nbsphinxcodecellspacing
\setlength{\nbsphinxcodecellspacing}{0pt}

% Define support macros for attaching opening and closing lines to notebooks
\newsavebox\nbsphinxbox
\makeatletter
\newcommand{\nbsphinxstartnotebook}[1]{%
    \par
    % measure needed space
    \setbox\nbsphinxbox\vtop{{#1\par}}
    % reserve some space at bottom of page, else start new page
    \needspace{\dimexpr2.5\baselineskip+\ht\nbsphinxbox+\dp\nbsphinxbox}
    % mimick vertical spacing from \section command
      \addpenalty\@secpenalty
      \@tempskipa 3.5ex \@plus 1ex \@minus .2ex\relax
      \addvspace\@tempskipa
      {\Large\@tempskipa\baselineskip
             \advance\@tempskipa-\prevdepth
             \advance\@tempskipa-\ht\nbsphinxbox
             \ifdim\@tempskipa>\z@
               \vskip \@tempskipa
             \fi}
    \unvbox\nbsphinxbox
    % if notebook starts with a \section, prevent it from adding extra space
    \@nobreaktrue\everypar{\@nobreakfalse\everypar{}}%
    % compensate the parskip which will get inserted by next paragraph
    \nobreak\vskip-\parskip
    % do not break here
    \nobreak
}% end of \nbsphinxstartnotebook

\newcommand{\nbsphinxstopnotebook}[1]{%
    \par
    % measure needed space
    \setbox\nbsphinxbox\vbox{{#1\par}}
    \nobreak % it updates page totals
    \dimen@\pagegoal
    \advance\dimen@-\pagetotal \advance\dimen@-\pagedepth
    \advance\dimen@-\ht\nbsphinxbox \advance\dimen@-\dp\nbsphinxbox
    \ifdim\dimen@<\z@
      % little space left
      \unvbox\nbsphinxbox
      \kern-.8\baselineskip
      \nobreak\vskip\z@\@plus1fil
      \penalty100
      \vskip\z@\@plus-1fil
      \kern.8\baselineskip
    \else
      \unvbox\nbsphinxbox
    \fi
}% end of \nbsphinxstopnotebook

% Ensure height of an included graphics fits in nbsphinxfancyoutput frame
\newdimen\nbsphinx@image@maxheight % set in nbsphinxfancyoutput environment
\newcommand*{\nbsphinxincludegraphics}[2][]{%
    \gdef\spx@includegraphics@options{#1}%
    \setbox\spx@image@box\hbox{\includegraphics[#1,draft]{#2}}%
    \in@false
    \ifdim \wd\spx@image@box>\linewidth
      \g@addto@macro\spx@includegraphics@options{,width=\linewidth}%
      \in@true
    \fi
    % no rotation, no need to worry about depth
    \ifdim \ht\spx@image@box>\nbsphinx@image@maxheight
      \g@addto@macro\spx@includegraphics@options{,height=\nbsphinx@image@maxheight}%
      \in@true
    \fi
    \ifin@
      \g@addto@macro\spx@includegraphics@options{,keepaspectratio}%
    \fi
    \setbox\spx@image@box\box\voidb@x % clear memory
    \expandafter\includegraphics\expandafter[\spx@includegraphics@options]{#2}%
}% end of "\MakeFrame"-safe variant of \sphinxincludegraphics
\makeatother

\makeatletter
\renewcommand*\sphinx@verbatim@nolig@list{\do\'\do\`}
\begingroup
\catcode`'=\active
\let\nbsphinx@noligs\@noligs
\g@addto@macro\nbsphinx@noligs{\let'\PYGZsq}
\endgroup
\makeatother
\renewcommand*\sphinxbreaksbeforeactivelist{\do\<\do\"\do\'}
\renewcommand*\sphinxbreaksafteractivelist{\do\.\do\,\do\:\do\;\do\?\do\!\do\/\do\>\do\-}
\makeatletter
\fvset{codes*=\sphinxbreaksattexescapedchars\do\^\^\let\@noligs\nbsphinx@noligs}
\makeatother



\title{CoSpar documentation}
\date{Feb 01, 2021}
\release{0.0.2}
\author{Shou-Wen Wang}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}
\sphinxhref{https://pypi.org/project/scvelo}{\sphinxincludegraphics{{/Users/shouwenwang/Dropbox (HMS)/Python_file/Clonal_tracing/cell_lineage_tracing/code_for_clonal_dynamics/Python/WOT/CoSpar_Package_development/CoSpar/docs/build/doctrees/images/99091ad35c48a73a4f2de974704f58bd0fbd0179/scvelo}.svg}} \sphinxhref{https://pepy.tech/project/scvelo}{\sphinxincludegraphics{{/Users/shouwenwang/Dropbox (HMS)/Python_file/Clonal_tracing/cell_lineage_tracing/code_for_clonal_dynamics/Python/WOT/CoSpar_Package_development/CoSpar/docs/build/doctrees/images/https/pepy.tech/badge/scvelo/scvelo}.svg}} \sphinxhref{https://scvelo.readthedocs.io}{\sphinxincludegraphics{{/Users/shouwenwang/Dropbox (HMS)/Python_file/Clonal_tracing/cell_lineage_tracing/code_for_clonal_dynamics/Python/WOT/CoSpar_Package_development/CoSpar/docs/build/doctrees/images/af09d8e57bd560ce09b28cb823690f3c6fcd1738/cccd72610130a31784df3bdcac3ec38be9f3b953}.svg}}



\noindent{\sphinxincludegraphics[width=300\sphinxpxdimen]{{1ee000c1ca085395227572c8e8883a0dc9d28475}.png}\hspace*{\fill}}

\sphinxstylestrong{CoSpar} is a toolkit for dynamic inference in lineage\sphinxhyphen{}traced single cells. 
The methods are based on
\sphinxhref{https://doi.org/xxx}{S.\sphinxhyphen{}W. Wang \& A.M. Klein (ToBeSubmitted, 2021)}.

Dynamic inference based on single\sphinxhyphen{}cell state measurement alone requires serious simplifications. On the other hand, direct dynamic measurement via lineage tracing only captures partial information and are very noisy. Exploiting both the local coherence and sparsity of differentiation transitions, CoSpar robustly infer the transition map of a development/differentiation system by integrating state and lineage measurement. CoSpar can recover early fate bias undetected in other dynamic inference methods, even using more noisy and fewer data.


\chapter{CoSpar’s key applications}
\label{\detokenize{index:cospar-s-key-applications}}\begin{itemize}
\item {} 
infer the finite\sphinxhyphen{}time single\sphinxhyphen{}cell transition amplitude from one state to another.

\item {} 
map a cell forward or backward in time.

\item {} 
infer the fate potential of a cell.

\item {} 
identify the boundary of fate bifurcation.

\item {} 
identify putative driver genes.

\item {} 
identify fate\sphinxhyphen{}bias clones.

\item {} 
infer differentiation coupling between different fate clusters.

\end{itemize}


\chapter{Reference}
\label{\detokenize{index:reference}}
Shou\sphinxhyphen{}Wen Wang \& Allon M. Klein (2021), Coherent sparsity optimization for dynamic inference by integrating state and lineage information,
\sphinxhref{https://doi.org/xxx}{ToBeSubmitted}.



\chapter{Support}
\label{\detokenize{index:support}}
Feel free to submit an \sphinxhref{https://github.com/ShouWenWang/cospar/issues/new/choose}{issue}
or send us an \sphinxhref{mailto:shouwen\_wang@hms.harvard.edu}{email}.
Your help to improve CoSpar is highly appreciated.


\section{About CoSpar}
\label{\detokenize{about:about-cospar}}\label{\detokenize{about::doc}}
High\sphinxhyphen{}throughput single\sphinxhyphen{}cell measurements have enabled unbiased study of development and differentiation, leading to numerous methods for dynamic inference. However, single\sphinxhyphen{}cell RNA sequencing (scRNA\sphinxhyphen{}seq) data alone does not fully constrain the differentiation dynamics, and existing methods inevitably operate under simplified assumptions. In parallel, the lineage information of individual cells can be profiled simultaneously along with their transcriptome by using a heritable and expressible DNA barcode as a lineage tracer. The barcode may remain static or evolve. However, sequencing is killing; we cannot get the actual single\sphinxhyphen{}cell dynamics in the transcriptomic space. In most cases, we can only get a snapshot of cells’ lineage information at a single time point. In some \sphinxstyleemphasis{in vitro} systems like hematopoiesis or iPS, we can approximate the dynamics by re\sphinxhyphen{}sampling the same clone, i.e., cells from the same ancestor, over time. The approximation is inevitably crude due to the tradeoff between the wish to observe a clone earlier and the need to allow it to expand before sampling. Therefore, clonal data also provide only partial information of the dynamics. This opens up the opportunity to integrate state and lineage (clonal) information for dynamic inference.

CoSpar, developed by \sphinxhref{https://doi.org/}{Wang \& Klein (2021)}, is the first tool ever to perform dynamic inference by integrating state and lineage information. It solves for the transition probability map from cell states at an earlier time point to states at a later time point. It achieves accuracy and robustness by making use of intrinsic sparsity and coherence of the transition dynamics: neighboring initial states share similar yet sparse fate outcomes. Built upon the finite\sphinxhyphen{}time transition map, CoSpar can 1) infer fate potential of early states; 2) detect early fate bias among a heterogeneous progenitor population, and identify the early boundary of fate bifurcation; 3) identify putative driver genes for fate bifurcation; 4) by selecting progenitor states more accurately, we also provide a better pseudo time analysis, including a more accurate gene expression dynamics along the trajectory. CoSpar also provides several methods to analyze clonal data by itself, including the clonal coupling between fate clusters and clonal fate bias.  We envision CoSpar to be a platform to integrate key methods needed to analyze data with both state and lineage information.


\subsection{Coherent sparsity optimization}
\label{\detokenize{about:coherent-sparsity-optimization}}
One formulation of dynamic inference is to identify a finite\sphinxhyphen{}time transition matrix \(T_{ij} (t_1,t_2)\), which describes the probability of a cell, initially in some state \(i\) at time \(t_1\), giving rise to progeny in a state \(j\) at time \(t_2\). However, scRNA\sphinxhyphen{}seq data alone do not constrain these maps fully, and strong assumptions have to be made.  We now extend these ideas to incorporate information from lineage tracing.

The clonal data directly constrains the transition map. We denote \sphinxstyleemphasis{I(t)} as a clone\sphinxhyphen{}by\sphinxhyphen{}cell matrix that encodes the clonal information at time \(t\), and introduce  \(S\)  as a cell\sphinxhyphen{}state similarity matrix that encodes the state information. The observed clonal data is sampled from a particular realization of the stochastic differentiation dynamics. To account for this bias and technical noises, we locally smooth the raw data to obtain the “average” cell density profile per clone:  \(P(t)=I(t)S\).  The transition map \(T\) directly links density profiles at two time points:
\begin{equation*}
\begin{split}\begin{equation}
P(t_2 )\approx P(t_1 )T(t_1,t_2)
\end{equation}\end{split}
\end{equation*}
In most cases, the number of clones (i.e., constraints) is less than that of initial states (i.e., variables), and  \(T\) is not sufficiently constrained.To further constrain the map, we observe that: 1)  \(T\) is a sparse matrix, since most cell states have sparse differentiation outcomes; 2)  \(T\) is locally coherent as neighboring cell states share similar fate outcomes; 3) \(T\) is a non\sphinxhyphen{}negative matrix. With these, the inference becomes an optimization problem:
\begin{equation*}
\begin{split}\begin{equation}
 \min_{P(t_1)}\min_{T} ||T||_1+\alpha ||LT||_2,  \; \text{s.t.} \; ||P(t_2)- P(t_1) T(t_1,t_2)||_{2}\le\epsilon;\; T\ge 0; \sum_j T_{ij}=1.
 \end{equation}\end{split}
\end{equation*}
Here, \(‖T‖_1\) quantifies the sparsity of the matrix T through its l\sphinxhyphen{}1 norm, while  \(‖LT‖_2\) quantifies the local coherence of \(T\) (\(L\) is the Laplacian of the cell state similarity graph, and \(LT\) is the local divergence). The remaining constraints are from clonal observation, non\sphinxhyphen{}negativity of \(T\), and map normalization, respectively. Both \(\alpha\) and \(\epsilon\) are tunable parameters.  At \(\alpha=0\), the minimization takes the form of Lasso, a traditional algorithm for compressed sensing. Our formulation extends compressed sensing from vector\sphinxhyphen{}oriented to matrix\sphinxhyphen{}oriented, and improves its robustness by incorporating the local coherence constraint. The local coherence extension is reminiscent of the fused Lasso problem. We have developed CoSpar to solve the optimization.

The above optimization is formulated as if we have initial clonal information by re\sphinxhyphen{}sampling clones. When we only have the clonal information at \(t_2\), we can still infer the transition map by jointly optimizing the map \(T\) and the initial clonal data \(I(t_1)\) such that the cost function is minimized. In this joint optimization, \(I(t_1 )\) is further constrained such that all initial cell states are labeled by clones, and non\sphinxhyphen{}overlapping clones at \(t_2\) label different cells at \(t_1\).

See \sphinxhref{https://doi.org/}{Wang \& Klein (2021)} for a detailed exposition of the methods.
\phantomsection\label{\detokenize{api:module-cospar}}\index{module@\spxentry{module}!cospar@\spxentry{cospar}}\index{cospar@\spxentry{cospar}!module@\spxentry{module}}
CoSpar \sphinxhyphen{} dynamic inference by integrating transcriptome and lineage information


\section{API}
\label{\detokenize{api:api}}\label{\detokenize{api::doc}}
Import CoSpar as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{cospar} \PYG{k}{as} \PYG{n+nn}{cs}
\end{sphinxVerbatim}

CoSpar is built around the \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object (usually called \sphinxtitleref{adata}).
The structure is defined in {\hyperref[\detokenize{cospar.pp.initialize_adata_object:cospar.pp.initialize_adata_object}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pp.initialize\_adata\_object()}}}}}. For each cell,
we store its time information at \sphinxtitleref{adata.obs{[}‘time\_info’{]}}, state information
at \sphinxtitleref{adata.obs{[}‘state\_info’{]}},  clonal information at \sphinxtitleref{adata.obsm{[}‘X\_clone’{]}},
and 2\sphinxhyphen{}d embedding at \sphinxtitleref{adata.obsm{[}‘X\_emb’{]}}.

Once the \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object is initialized via \sphinxcode{\sphinxupquote{cs.pp.initialize\_adata\_object()}}, the typical flow of analysis is to 1) perform preprocessing and dimension reduction (\sphinxcode{\sphinxupquote{cs.pp.*}}), 2) visualize and analyzing clonal data alone (\sphinxcode{\sphinxupquote{cs.pl.*}}), 3) infer transition map (\sphinxcode{\sphinxupquote{cs.tmap.*}}), and 4) analyze inferred map by plotting (\sphinxcode{\sphinxupquote{cs.pl.*}}). We also provide miscellaneous functions to assist with the analysis (\sphinxcode{\sphinxupquote{cs.hf.*}}). See {\hyperref[\detokenize{getting_started::doc}]{\sphinxcrossref{\DUrole{doc}{tutorial}}}} for details.


\subsection{Preprocessing}
\label{\detokenize{api:preprocessing}}

\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{cospar.pp.initialize_adata_object:cospar.pp.initialize_adata_object}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pp.initialize\_adata\_object}}}}}(…{[}, X\_clone, …{]})
&
Initialized the \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object
\\
\hline
{\hyperref[\detokenize{cospar.pp.get_X_pca:cospar.pp.get_X_pca}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pp.get\_X\_pca}}}}}(adata{[}, n\_pca\_comp{]})
&
Update X\_pca
\\
\hline
{\hyperref[\detokenize{cospar.pp.get_X_emb:cospar.pp.get_X_emb}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pp.get\_X\_emb}}}}}(adata{[}, n\_neighbors, umap\_min\_dist{]})
&
Update X\_emb using \sphinxhref{https://scanpy.readthedocs.io/en/latest/api/scanpy.tl.umap.html\#scanpy.tl.umap}{\sphinxcode{\sphinxupquote{scanpy.tl.umap()}}}
\\
\hline
{\hyperref[\detokenize{cospar.pp.get_state_info:cospar.pp.get_state_info}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pp.get\_state\_info}}}}}(adata{[}, leiden\_resolution{]})
&
Update \sphinxtitleref{state\_info} using \sphinxhref{https://scanpy.readthedocs.io/en/latest/api/scanpy.tl.leiden.html\#scanpy.tl.leiden}{\sphinxcode{\sphinxupquote{scanpy.tl.leiden()}}}
\\
\hline
{\hyperref[\detokenize{cospar.pp.refine_state_info_by_marker_genes:cospar.pp.refine_state_info_by_marker_genes}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pp.refine\_state\_info\_by\_marker\_genes}}}}}(adata, …)
&
Refine state info according to marker gene expression.
\\
\hline
{\hyperref[\detokenize{cospar.pp.refine_state_info_by_leiden_clustering:cospar.pp.refine_state_info_by_leiden_clustering}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pp.refine\_state\_info\_by\_leiden\_clustering}}}}}(adata)
&
Refine state info by clustering on states at given time points.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subsubsection{cospar.pp.initialize\_adata\_object}
\label{\detokenize{cospar.pp.initialize_adata_object:cospar-pp-initialize-adata-object}}\label{\detokenize{cospar.pp.initialize_adata_object::doc}}\index{initialize\_adata\_object() (in module cospar.pp)@\spxentry{initialize\_adata\_object()}\spxextra{in module cospar.pp}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.pp.initialize_adata_object:cospar.pp.initialize_adata_object}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.pp.}}\sphinxbfcode{\sphinxupquote{initialize\_adata\_object}}}{\emph{\DUrole{n}{cell\_by\_gene\_matrix}}, \emph{\DUrole{n}{gene\_names}}, \emph{\DUrole{n}{time\_info}}, \emph{\DUrole{n}{X\_clone}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}, \emph{\DUrole{n}{X\_pca}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}, \emph{\DUrole{n}{X\_emb}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}, \emph{\DUrole{n}{state\_info}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}, \emph{\DUrole{n}{data\_des}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}cospar\textquotesingle{}}}}{}
Initialized the \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object

The principal components (\sphinxtitleref{X\_pca}), 2\sphinxhyphen{}d embedding (\sphinxtitleref{X\_emb}), and
state\_info can be provided upfront, or generated in the next step.
If the clonal information (X\_clone) is not provided,
the transition map will be generated using only the state information.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{cell\_by\_gene\_matrix}} : \sphinxtitleref{np.ndarray}, \sphinxtitleref{sp.spmatrix}}] \leavevmode
The (annotated) data matrix. Rows correspond to cells and columns to genes.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{gene\_names}} : \sphinxtitleref{np.ndarray}}] \leavevmode
An array of gene names.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{time\_info}} : \sphinxtitleref{np.ndarray}}] \leavevmode
Time annotation for each cell in \sphinxtitleref{str},like ‘Day27’ or ‘D27’.
However, it can also contain other sample\_info,
like ‘GFP+\_day27’, and ‘GFP\sphinxhyphen{}\_day27’.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{X\_clone}} : \sphinxtitleref{sp.spmatrix} (also accpet \sphinxtitleref{np.ndarray})}] \leavevmode
The clonal data matrix, with the row in cell\_id, and column in barcode\_id.
For evolvable barcoding, a cell may carry several different barcode\_id.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{X\_pca}} : \sphinxtitleref{np.ndarray}, optional (default: {[}{]})}] \leavevmode
A matrix of the shape n\_cell*n\_pct. Create if not set.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{X\_emb}} : \sphinxtitleref{np.ndarray}, optional (default: {[}{]})}] \leavevmode
Two\sphinxhyphen{}dimensional matrix for embedding.  Create with UMAP if not set.
It is used only for plotting after the transition map is created

\item[{\sphinxstyleliteralstrong{\sphinxupquote{state\_info}} : \sphinxtitleref{np.ndarray}, optional (default: {[}{]})}] \leavevmode
The classification and annotation for each cell state.
Create with leiden clustering if not set.
This will be used only after the map is created. Can be adjusted later

\item[{\sphinxstyleliteralstrong{\sphinxupquote{data\_des}} : \sphinxtitleref{str}, optional (default:’cospar’)}] \leavevmode
This is just a name to label/distinguish this data.
Will be used for saving the results.
It should be a unique name for a new dataset.

\end{description}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
Generate an \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object with the following entries

\item {} 
\sphinxstylestrong{obs} (\sphinxstyleemphasis{‘time\_info’, ‘state\_info’})

\item {} 
\sphinxstylestrong{uns} (\sphinxstyleemphasis{‘data\_des’, ‘clonal\_time\_points’})

\item {} 
\sphinxstylestrong{obsm} (\sphinxstyleemphasis{‘X\_clone’, ‘X\_pca’, ‘X\_emb’})

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.pp.get\_X\_pca}
\label{\detokenize{cospar.pp.get_X_pca:cospar-pp-get-x-pca}}\label{\detokenize{cospar.pp.get_X_pca::doc}}\index{get\_X\_pca() (in module cospar.pp)@\spxentry{get\_X\_pca()}\spxextra{in module cospar.pp}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.pp.get_X_pca:cospar.pp.get_X_pca}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.pp.}}\sphinxbfcode{\sphinxupquote{get\_X\_pca}}}{\emph{\DUrole{n}{adata}}, \emph{\DUrole{n}{n\_pca\_comp}\DUrole{o}{=}\DUrole{default_value}{40}}}{}
Update X\_pca
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{adata}} : \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object}] \leavevmode


\item[{\sphinxstyleliteralstrong{\sphinxupquote{n\_pca\_comp}} : \sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{default: 40}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}}] \leavevmode
Number of top principle components to keep

\end{description}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{None, but the adata.obsm{[}‘X\_pca’{]} is modified.}

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.pp.get\_X\_emb}
\label{\detokenize{cospar.pp.get_X_emb:cospar-pp-get-x-emb}}\label{\detokenize{cospar.pp.get_X_emb::doc}}\index{get\_X\_emb() (in module cospar.pp)@\spxentry{get\_X\_emb()}\spxextra{in module cospar.pp}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.pp.get_X_emb:cospar.pp.get_X_emb}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.pp.}}\sphinxbfcode{\sphinxupquote{get\_X\_emb}}}{\emph{\DUrole{n}{adata}}, \emph{\DUrole{n}{n\_neighbors}\DUrole{o}{=}\DUrole{default_value}{20}}, \emph{\DUrole{n}{umap\_min\_dist}\DUrole{o}{=}\DUrole{default_value}{0.3}}}{}
Update X\_emb using \sphinxhref{https://scanpy.readthedocs.io/en/latest/api/scanpy.tl.umap.html\#scanpy.tl.umap}{\sphinxcode{\sphinxupquote{scanpy.tl.umap()}}}

We assume that X\_pca is computed.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{adata}} : \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object}] \leavevmode


\item[{\sphinxstyleliteralstrong{\sphinxupquote{n\_neighbors}} : \sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{default: 20}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}}] \leavevmode
neighber number for constructing the KNN graph, using the UMAP method.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{umap\_min\_dist}} : \sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{default: 0.3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}}] \leavevmode
The effective minimum distance between embedded points.

\end{description}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{None, but the adata.obsm{[}‘X\_emb’{]} is modified.}

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.pp.get\_state\_info}
\label{\detokenize{cospar.pp.get_state_info:cospar-pp-get-state-info}}\label{\detokenize{cospar.pp.get_state_info::doc}}\index{get\_state\_info() (in module cospar.pp)@\spxentry{get\_state\_info()}\spxextra{in module cospar.pp}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.pp.get_state_info:cospar.pp.get_state_info}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.pp.}}\sphinxbfcode{\sphinxupquote{get\_state\_info}}}{\emph{\DUrole{n}{adata}}, \emph{\DUrole{n}{leiden\_resolution}\DUrole{o}{=}\DUrole{default_value}{0.5}}}{}
Update \sphinxtitleref{state\_info} using \sphinxhref{https://scanpy.readthedocs.io/en/latest/api/scanpy.tl.leiden.html\#scanpy.tl.leiden}{\sphinxcode{\sphinxupquote{scanpy.tl.leiden()}}}

We assume that X\_pca is computed.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{adata}} : \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object}] \leavevmode


\item[{\sphinxstyleliteralstrong{\sphinxupquote{n\_neighbors}} : \sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{default: 20}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}}] \leavevmode
neighber number for constructing the KNN graph, using the UMAP method.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{leiden\_resolution}} : \sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{default: 0.5}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}}] \leavevmode
A parameter value controlling the coarseness of the clustering.
Higher values lead to more clusters.

\end{description}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{None, but the adata.obs{[}‘state\_info’{]} is modified.}

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.pp.refine\_state\_info\_by\_marker\_genes}
\label{\detokenize{cospar.pp.refine_state_info_by_marker_genes:cospar-pp-refine-state-info-by-marker-genes}}\label{\detokenize{cospar.pp.refine_state_info_by_marker_genes::doc}}\index{refine\_state\_info\_by\_marker\_genes() (in module cospar.pp)@\spxentry{refine\_state\_info\_by\_marker\_genes()}\spxextra{in module cospar.pp}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.pp.refine_state_info_by_marker_genes:cospar.pp.refine_state_info_by_marker_genes}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.pp.}}\sphinxbfcode{\sphinxupquote{refine\_state\_info\_by\_marker\_genes}}}{\emph{\DUrole{n}{adata}}, \emph{\DUrole{n}{marker\_genes}}, \emph{\DUrole{n}{express\_threshold}\DUrole{o}{=}\DUrole{default_value}{0.1}}, \emph{\DUrole{n}{selected\_time\_points}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}, \emph{\DUrole{n}{new\_cluster\_name}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}new\_cluster\textquotesingle{}}}, \emph{\DUrole{n}{confirm\_change}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{add\_neighbor\_N}\DUrole{o}{=}\DUrole{default_value}{5}}}{}
Refine state info according to marker gene expression.

In this method, a state is selected if it expresses all genes in the list
of marker\_genes, and the expression are above the relative threshold express\_threshold.
You can also specify which time point you want to focus on. In addition, we also include
cell states neighboring to these valid states to smooth the selection
(controlled by add\_neighbor\_N).

When you run it the first time, set confirm\_change=False. Only when you are happy with
the result, set confirm\_change=True to update the adata.obs{[}‘state\_info’{]}.
The original state\_info will be stored at adata.obs{[}‘old\_state\_info’{]}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{adata}} : \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object}] \leavevmode


\item[{\sphinxstyleliteralstrong{\sphinxupquote{marker\_genes}} : \sphinxtitleref{list} or ‘str’}] \leavevmode
List of marker genes to be used for defining cell states.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{express\_threshold}} : \sphinxtitleref{float}, optional (default: 0.1)}] \leavevmode
Relative threshold of marker gene expression, in the range {[}0,1{]}.
A state must have an expression above this threshold for all genes
to be included.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{selected\_time\_points}} : \sphinxtitleref{list}, optional (default: include all)}] \leavevmode
A list of selected time points for performing clustering,
among adata.obs{[}‘time\_info’{]}. If set as {[}{]}, use all time points.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{new\_cluster\_name}} : \sphinxtitleref{str}, optional (default: ‘new\_cluster’)}] \leavevmode


\item[{\sphinxstyleliteralstrong{\sphinxupquote{confirm\_change}} : \sphinxtitleref{bool}, optional (default: False)}] \leavevmode
If True, update adata.obs{[}‘state\_info’{]}

\item[{\sphinxstyleliteralstrong{\sphinxupquote{add\_neighbor\_N}} : \sphinxtitleref{int}, optional (default: 5)}] \leavevmode
Add to the new cluster neighboring cells of a qualified
high\sphinxhyphen{}expressing state according to the KNN graph
with K=add\_neighbor\_N

\end{description}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{Update the adata.obs{[}‘state\_info’{]} if confirm\_change=True.}

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.pp.refine\_state\_info\_by\_leiden\_clustering}
\label{\detokenize{cospar.pp.refine_state_info_by_leiden_clustering:cospar-pp-refine-state-info-by-leiden-clustering}}\label{\detokenize{cospar.pp.refine_state_info_by_leiden_clustering::doc}}\index{refine\_state\_info\_by\_leiden\_clustering() (in module cospar.pp)@\spxentry{refine\_state\_info\_by\_leiden\_clustering()}\spxextra{in module cospar.pp}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.pp.refine_state_info_by_leiden_clustering:cospar.pp.refine_state_info_by_leiden_clustering}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.pp.}}\sphinxbfcode{\sphinxupquote{refine\_state\_info\_by\_leiden\_clustering}}}{\emph{\DUrole{n}{adata}}, \emph{\DUrole{n}{selected\_time\_points}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}, \emph{\DUrole{n}{leiden\_resolution}\DUrole{o}{=}\DUrole{default_value}{0.5}}, \emph{\DUrole{n}{n\_neighbors}\DUrole{o}{=}\DUrole{default_value}{5}}, \emph{\DUrole{n}{confirm\_change}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{cluster\_name\_prefix}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}S\textquotesingle{}}}}{}
Refine state info by clustering on states at given time points.

Select states at desired time points to improve the clustering. When
first run, set confirm\_change=False. Only when you are happy with the
result, set confirm\_change=True to update the adata.obs{[}‘state\_info’{]}.
The original state\_info will be stored at adata.obs{[}‘old\_state\_info’{]}.

When you run it the first time, set confirm\_change=False. Only when you are happy with
the result, set confirm\_change=True to update the adata.obs{[}‘state\_info’{]}.
The original state\_info will be stored at adata.obs{[}‘old\_state\_info’{]}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{adata}} : \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object}] \leavevmode


\item[{\sphinxstyleliteralstrong{\sphinxupquote{selected\_time\_points}} : \sphinxtitleref{list}, optional (default: include all)}] \leavevmode
A list of selected time points for performing clustering,
among adata.obs{[}‘time\_info’{]}. If set as {[}{]}, use all time points.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{adata}}}] \leavevmode


\item[{\sphinxstyleliteralstrong{\sphinxupquote{n\_neighbors}} : \sphinxtitleref{int}, optional (default: 20)}] \leavevmode
neighber number for constructing the KNN graph, using the UMAP method.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{leiden\_resolution}} : \sphinxtitleref{float}, optional (default: 0.5)}] \leavevmode
A parameter value controlling the coarseness of the clustering.
Higher values lead to more clusters.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{confirm\_change}} : \sphinxtitleref{bool}, optional (default: False)}] \leavevmode
If True, update adata.obs{[}‘state\_info’{]}

\item[{\sphinxstyleliteralstrong{\sphinxupquote{cluster\_name\_prefix}} : \sphinxtitleref{str}, optional (default: ‘S’)}] \leavevmode
prefix for the new cluster name in case they overlap
with existing cluster names.

\end{description}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{Update the adata.obs{[}‘state\_info’{]} if confirm\_change=True.}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{Transition map inference}
\label{\detokenize{api:transition-map-inference}}
\sphinxstylestrong{External functions}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{cospar.tmap.infer_Tmap_from_multitime_clones:cospar.tmap.infer_Tmap_from_multitime_clones}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tmap.infer\_Tmap\_from\_multitime\_clones}}}}}(…{[}, …{]})
&
Infer Tmap for clonal data with multiple time points.
\\
\hline
{\hyperref[\detokenize{cospar.tmap.infer_intraclone_Tmap:cospar.tmap.infer_intraclone_Tmap}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tmap.infer\_intraclone\_Tmap}}}}}(adata{[}, …{]})
&
Infer intra\sphinxhyphen{}clone transition map.
\\
\hline
{\hyperref[\detokenize{cospar.tmap.infer_Tmap_from_one_time_clones:cospar.tmap.infer_Tmap_from_one_time_clones}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tmap.infer\_Tmap\_from\_one\_time\_clones}}}}}(…{[}, …{]})
&
Infer transition map from clones with a single time point
\\
\hline
{\hyperref[\detokenize{cospar.tmap.infer_Tmap_from_state_info_alone:cospar.tmap.infer_Tmap_from_state_info_alone}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tmap.infer\_Tmap\_from\_state\_info\_alone}}}}}(…{[}, …{]})
&
Infer transition map from state information alone.
\\
\hline
{\hyperref[\detokenize{cospar.tmap.infer_Tmap_from_clonal_info_alone:cospar.tmap.infer_Tmap_from_clonal_info_alone}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tmap.infer\_Tmap\_from\_clonal\_info\_alone}}}}}(adata)
&
Compute transition map using only the lineage information
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subsubsection{cospar.tmap.infer\_Tmap\_from\_multitime\_clones}
\label{\detokenize{cospar.tmap.infer_Tmap_from_multitime_clones:cospar-tmap-infer-tmap-from-multitime-clones}}\label{\detokenize{cospar.tmap.infer_Tmap_from_multitime_clones::doc}}\index{infer\_Tmap\_from\_multitime\_clones() (in module cospar.tmap)@\spxentry{infer\_Tmap\_from\_multitime\_clones()}\spxextra{in module cospar.tmap}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.tmap.infer_Tmap_from_multitime_clones:cospar.tmap.infer_Tmap_from_multitime_clones}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.tmap.}}\sphinxbfcode{\sphinxupquote{infer\_Tmap\_from\_multitime\_clones}}}{\emph{\DUrole{n}{adata\_orig}}, \emph{\DUrole{n}{selected\_clonal\_time\_points}}, \emph{\DUrole{n}{smooth\_array}\DUrole{o}{=}\DUrole{default_value}{{[}15, 10, 5{]}}}, \emph{\DUrole{n}{CoSpar\_KNN}\DUrole{o}{=}\DUrole{default_value}{20}}, \emph{\DUrole{n}{noise\_threshold}\DUrole{o}{=}\DUrole{default_value}{0.1}}, \emph{\DUrole{n}{demulti\_threshold}\DUrole{o}{=}\DUrole{default_value}{0.05}}, \emph{\DUrole{n}{normalization\_mode}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{use\_all\_cells}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{save\_subset}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{use\_full\_Smatrix}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{trunca\_threshold}\DUrole{o}{=}\DUrole{default_value}{0.001}}, \emph{\DUrole{n}{compute\_new}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Infer Tmap for clonal data with multiple time points.

It prepares adata object for cells of targeted time points by
{\hyperref[\detokenize{cospar.tmap.select_time_points:cospar.tmap.select_time_points}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{select\_time\_points()}}}}}, generate the similarity matrix
via {\hyperref[\detokenize{cospar.tmap.generate_similarity_matrix:cospar.tmap.generate_similarity_matrix}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{generate\_similarity\_matrix()}}}}}, and iterately calls
the core function {\hyperref[\detokenize{cospar.tmap.refine_Tmap_through_cospar:cospar.tmap.refine_Tmap_through_cospar}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{refine\_Tmap\_through\_cospar()}}}}} to update
the transition map.

The inferred map allows transitions between neighboring time points.
For example, if selected\_clonal\_time\_points={[}‘day1’,’day2’,’day3’{]},
then it computes transitions for pairs (day1, day2) and (day2, day3),
but not (day1, day3).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{adata\_orig}} : \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object}] \leavevmode
Should be prepared from our anadata initialization.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{selected\_clonal\_time\_points}} : \sphinxtitleref{list} of \sphinxtitleref{str}}] \leavevmode
List of time points to be included for analysis.
We assume that each selected time point has clonal measurement.
It should be in ascending order: ‘day\_1’,’day\_2’….

\item[{\sphinxstyleliteralstrong{\sphinxupquote{smooth\_array}} : \sphinxtitleref{list}, optional (default: {[}15,10,5{]})}] \leavevmode
List of smooth rounds at each iteration.
The n\sphinxhyphen{}th entry determines the smooth round for the Smatrix
at the n\sphinxhyphen{}th iteration. Its length determins the number of
iteration. It is better to use a number at the multiple of
5, i.e., 5, 10, 15, 20,…

\item[{\sphinxstyleliteralstrong{\sphinxupquote{CoSpar\_KNN}} : \sphinxtitleref{int}, optional (default: 20)}] \leavevmode
the number of neighbors for KNN graph used for computing the
similarity matrix.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{trunca\_threshold}} : \sphinxtitleref{float}, optional (default: 0.001)}] \leavevmode
We set entries to zero in the computed similarity matrix that
are smaller than this threshold. This is to promote the Smatrix
sparsity, which leads to faster computation, and smaller file size.
This threshld should be small, but not too small.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{noise\_threshold}} : \sphinxtitleref{float}, optional (default: 0.1)}] \leavevmode
noise threshold to remove noises in the updated transition map,
in the range {[}0,1{]}

\item[{\sphinxstyleliteralstrong{\sphinxupquote{demulti\_threshold}} : \sphinxtitleref{float}, optional (default: 0.05)}] \leavevmode
noise threshold to remove noises in demultiplexed (un\sphinxhyphen{}smoothed) map,
in the range {[}0,1{]}

\item[{\sphinxstyleliteralstrong{\sphinxupquote{normalization\_mode}} : \sphinxtitleref{int}, optional (default: 1)}] \leavevmode
Method for normalization. Choice: {[}0,1{]}
0, single\sphinxhyphen{}cell normalization
1, Clone normalization

\item[{\sphinxstyleliteralstrong{\sphinxupquote{use\_all\_cells}} : \sphinxtitleref{bool} optional (default: \sphinxtitleref{False})}] \leavevmode
If true, all cells at selected time points will be used for computing
Tmap. If false, only cells belonging to multi\sphinxhyphen{}time clones will be used
for computing Tmap. The latter case usually speed up the computation,
which is recommended.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{save\_subset}} : \sphinxtitleref{bool}, optional (default: True)}] \leavevmode
If true, save only Smatrix at smooth round {[}5,10,15,…{]}.
Else, save Smatrix at each round.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{use\_full\_Smatrix}} : \sphinxtitleref{bool}, optional (default: False)}] \leavevmode
use the Smatrix as defined by all cells, whether they are clonally
barcoded or not. We sub\sphinxhyphen{}sample cell states relevant for downstream
analysis from this full Smatrix. This may refine the Smatrix.
But will also increase the computation time significantly.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{Compute\_new}} : \sphinxtitleref{bool}, optional (default: False)}] \leavevmode
If True, compute Smatrix from scratch, whether it was
computed and saved before or not. This is activated only when
\sphinxtitleref{use\_full\_Smatrix=False}.

\end{description}

\item[{Returns}] \leavevmode
\sphinxstylestrong{adata} (\sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object) \textendash{} Store results at adata.uns{[}‘transition\_map’{]}
and adata.uns{[}‘intraclone\_transition\_map’{]}. This adata is different
from the input adata\_orig due to subsampling cells.

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.tmap.infer\_intraclone\_Tmap}
\label{\detokenize{cospar.tmap.infer_intraclone_Tmap:cospar-tmap-infer-intraclone-tmap}}\label{\detokenize{cospar.tmap.infer_intraclone_Tmap::doc}}\index{infer\_intraclone\_Tmap() (in module cospar.tmap)@\spxentry{infer\_intraclone\_Tmap()}\spxextra{in module cospar.tmap}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.tmap.infer_intraclone_Tmap:cospar.tmap.infer_intraclone_Tmap}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.tmap.}}\sphinxbfcode{\sphinxupquote{infer\_intraclone\_Tmap}}}{\emph{\DUrole{n}{adata}}, \emph{\DUrole{n}{demulti\_threshold}\DUrole{o}{=}\DUrole{default_value}{0.05}}, \emph{\DUrole{n}{normalization\_mode}\DUrole{o}{=}\DUrole{default_value}{1}}}{}
Infer intra\sphinxhyphen{}clone transition map.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{adata}} : \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object}] \leavevmode
Should be prepared by {\hyperref[\detokenize{cospar.tmap.select_time_points:cospar.tmap.select_time_points}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{select\_time\_points()}}}}}

\item[{\sphinxstyleliteralstrong{\sphinxupquote{demulti\_threshold}} : \sphinxtitleref{float}, optional (default: 0.05)}] \leavevmode
noise threshold to remove noises in transition\_map,
in the range {[}0,1{]}

\item[{\sphinxstyleliteralstrong{\sphinxupquote{normalization\_mode}} : \sphinxtitleref{int}, optional (default: 1)}] \leavevmode
Method for normalization. Choice: {[}0,1{]}
0, single\sphinxhyphen{}cell normalization
1, Clone normalization

\end{description}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{None. Update/generate adata.uns{[}‘intraclone\_transition\_map’{]}}

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.tmap.infer\_Tmap\_from\_one\_time\_clones}
\label{\detokenize{cospar.tmap.infer_Tmap_from_one_time_clones:cospar-tmap-infer-tmap-from-one-time-clones}}\label{\detokenize{cospar.tmap.infer_Tmap_from_one_time_clones::doc}}\index{infer\_Tmap\_from\_one\_time\_clones() (in module cospar.tmap)@\spxentry{infer\_Tmap\_from\_one\_time\_clones()}\spxextra{in module cospar.tmap}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.tmap.infer_Tmap_from_one_time_clones:cospar.tmap.infer_Tmap_from_one_time_clones}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.tmap.}}\sphinxbfcode{\sphinxupquote{infer\_Tmap\_from\_one\_time\_clones}}}{\emph{\DUrole{n}{adata\_orig}}, \emph{\DUrole{n}{initial\_time\_points}}, \emph{\DUrole{n}{clonal\_time\_point}}, \emph{\DUrole{n}{initialize\_method}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}OT\textquotesingle{}}}, \emph{\DUrole{n}{OT\_epsilon}\DUrole{o}{=}\DUrole{default_value}{0.02}}, \emph{\DUrole{n}{OT\_dis\_KNN}\DUrole{o}{=}\DUrole{default_value}{5}}, \emph{\DUrole{n}{OT\_cost}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}SPD\textquotesingle{}}}, \emph{\DUrole{n}{HighVar\_gene\_pctl}\DUrole{o}{=}\DUrole{default_value}{85}}, \emph{\DUrole{n}{Clone\_update\_iter\_N}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{normalization\_mode}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{noise\_threshold}\DUrole{o}{=}\DUrole{default_value}{0.2}}, \emph{\DUrole{n}{CoSpar\_KNN}\DUrole{o}{=}\DUrole{default_value}{20}}, \emph{\DUrole{n}{use\_full\_Smatrix}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{smooth\_array}\DUrole{o}{=}\DUrole{default_value}{{[}15, 10, 5{]}}}, \emph{\DUrole{n}{trunca\_threshold}\DUrole{o}{=}\DUrole{default_value}{0.001}}, \emph{\DUrole{n}{compute\_new}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{use\_fixed\_clonesize\_t1}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{sort\_clone}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{save\_subset}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
Infer transition map from clones with a single time point

We iteratively infer transition map between each of the initial
time points {[}‘day\_1’,’day\_2’,…,{]} and the time point with clonal
observation. Given the two time points, after initializing the map
by either OT method or HighVar method, we jointly infer the likely
initial clonal cells and the transition map between cell states
in these two time points.

\sphinxstylestrong{Summary}
\begin{itemize}
\item {} 
Parameters relevant for cell state selection:  initial\_time\_points,
clonal\_time\_point, use\_full\_Smatrix.

\item {} 
Choose the initialization method, and set the corresponding parameters.
\begin{itemize}
\item {} 
‘OT’: tend to be more accurate, but not reliable
under batch effect. Key parameters: \sphinxtitleref{OT\_epsilon, OT\_dis\_KNN}.

\item {} 
‘HighVar’:  is robust to batch effect, but not as accurate.
Key parameter: \sphinxtitleref{HighVar\_gene\_pctl}.

\end{itemize}

\item {} 
Key parameters relevant for CoSpar itself: \sphinxtitleref{smooth\_array, normalization\_mode,
CoSpar\_KNN, noise\_threshold, Clone\_update\_iter\_N}.

\end{itemize}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{adata\_orig}} : \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object}] \leavevmode
assumed to be preprocessed, can have multiple time points.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{initial\_time\_points}} : \sphinxtitleref{list}}] \leavevmode
List of initial time points to be included for the transition map.
Like {[}‘day\_1’,’day\_2’{]}. Entries consistent with adata.obs{[}‘time\_info’{]}.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{clonal\_time\_point}} : \sphinxtitleref{str}}] \leavevmode
The time point with clonal observation. Its value should be
consistent with adata.obs{[}‘time\_info’{]}.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{initialize\_method}} : \sphinxtitleref{str}, optional (default ‘OT’)}] \leavevmode
Method to initialize the transition map from state information.
Choice: \{‘OT’, ‘HighVar’\}.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{OT\_epsilon}} : \sphinxtitleref{float}, optional (default: 0.02)}] \leavevmode
The entropic regularization, \textgreater{}0, a larger one increases
uncertainty of the transition. Relevant when \sphinxtitleref{initialize\_method=’OT’}.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{OT\_dis\_KNN}} : \sphinxtitleref{int}, optional (default: 5)}] \leavevmode
Number of nearest neighbors to construct the KNN graph for
computing the shortest path distance. Relevant when \sphinxtitleref{initialize\_method=’OT’}.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{OT\_cost}} : \sphinxtitleref{str}, optional (default: \sphinxtitleref{SPD}), options \{‘GED’,’SPD’\}}] \leavevmode
The cost metric. We provide gene expression distance (GED), and also
shortest path distance (SPD). GED is much faster, but SPD is more accurate.
However, cospar is robust to the initialization.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{HighVar\_gene\_pctl}} : \sphinxtitleref{int}, optional (default: 85)}] \leavevmode
percentile threshold to select highly variable genes. Range: {[}0,100{]}.
A higher value selects more variable genes.
Relevant when \sphinxtitleref{initialize\_method=’HighVar’}.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{Clone\_update\_iter\_N}} : \sphinxtitleref{int}, optional (default: 1)}] \leavevmode
Number of iteration for the joint optimization

\item[{\sphinxstyleliteralstrong{\sphinxupquote{normalization\_mode}} : \sphinxtitleref{int}, optional (default: 1)}] \leavevmode
Method for normalization. Choice: {[}0,1{]}
0, single\sphinxhyphen{}cell normalization
1, Clone normalization

\item[{\sphinxstyleliteralstrong{\sphinxupquote{smooth\_array}} : \sphinxtitleref{list}, optional (default: {[}15,10,5{]})}] \leavevmode
List of smooth rounds at each iteration.
The n\sphinxhyphen{}th entry determines the smooth round for the Smatrix
at the n\sphinxhyphen{}th iteration. Its length determins the number of
iteration. It is better to use a number at the multiple of
5, i.e., 5, 10, 15, 20,…

\item[{\sphinxstyleliteralstrong{\sphinxupquote{CoSpar\_KNN}} : \sphinxtitleref{int}, optional (default: 20)}] \leavevmode
the number of neighbors for KNN graph used for computing the similarity matrix.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{trunca\_threshold}} : \sphinxtitleref{float}, optional (default: 0.001)}] \leavevmode
We set entries to zero in the computed similarity matrix that
are smaller than this threshold. This is to promote the Smatrix sparsity, which
leads to faster computation, and smaller file size.
This threshld should be small, but not too small.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{noise\_threshold}} : \sphinxtitleref{float}, optional (default: 0.1)}] \leavevmode
noise threshold to remove noises in the updated transition map,
in the range {[}0,1{]}

\item[{\sphinxstyleliteralstrong{\sphinxupquote{save\_subset}} : \sphinxtitleref{bool}, optional (default: True)}] \leavevmode
If true, save only Smatrix at smooth round {[}5,10,15,…{]}.
Else, save Smatrix at each round.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{use\_full\_Smatrix}} : \sphinxtitleref{bool}, optional (default: False)}] \leavevmode
use the Smatrix as defined by all cells, whether they are clonally
barcoded or not. We sub\sphinxhyphen{}sample cell states relevant for downstream
analysis from this full Smatrix. This may refine the Smatrix.
But will also increase the computation time significantly.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{use\_fixed\_clonesize\_t1}} : \sphinxtitleref{bool}, optional (default: False)}] \leavevmode
If true, fix the number of initial states as the same for all clones

\item[{\sphinxstyleliteralstrong{\sphinxupquote{sort\_clone}} : \sphinxtitleref{int}, optional (default: 1)}] \leavevmode
The order to infer initial states for each clone: \{1,\sphinxhyphen{}1,others\}
1, sort clones by size from small to large
\sphinxhyphen{}1,sort clones by size from large to small
others, do not sort.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{compute\_new}} : \sphinxtitleref{bool}, optional (default: False)}] \leavevmode
If True, compute everthing (ShortestPathDis,OT\_map etc.) from scratch,
whether it was computed and saved before or not. Regarding the Smatrix, it is
recomputed only when \sphinxtitleref{use\_full\_Smatrix=False}.

\end{description}

\item[{Returns}] \leavevmode
\sphinxstylestrong{adata} (\sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object) \textendash{} Update adata.obsm{[}‘X\_clone’{]} and adata.uns{[}‘transition\_map’{]},
as well as adata.uns{[}‘OT\_transition\_map’{]} or
adata.uns{[}‘intraclone\_transition\_map’{]}, depending on the initialization.

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.tmap.infer\_Tmap\_from\_state\_info\_alone}
\label{\detokenize{cospar.tmap.infer_Tmap_from_state_info_alone:cospar-tmap-infer-tmap-from-state-info-alone}}\label{\detokenize{cospar.tmap.infer_Tmap_from_state_info_alone::doc}}\index{infer\_Tmap\_from\_state\_info\_alone() (in module cospar.tmap)@\spxentry{infer\_Tmap\_from\_state\_info\_alone()}\spxextra{in module cospar.tmap}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.tmap.infer_Tmap_from_state_info_alone:cospar.tmap.infer_Tmap_from_state_info_alone}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.tmap.}}\sphinxbfcode{\sphinxupquote{infer\_Tmap\_from\_state\_info\_alone}}}{\emph{\DUrole{n}{adata\_orig}}, \emph{\DUrole{n}{initial\_time\_points}}, \emph{\DUrole{n}{target\_time\_point}}, \emph{\DUrole{n}{method}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}OT\textquotesingle{}}}, \emph{\DUrole{n}{OT\_epsilon}\DUrole{o}{=}\DUrole{default_value}{0.02}}, \emph{\DUrole{n}{OT\_dis\_KNN}\DUrole{o}{=}\DUrole{default_value}{5}}, \emph{\DUrole{n}{OT\_cost}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}SPD\textquotesingle{}}}, \emph{\DUrole{n}{HighVar\_gene\_pctl}\DUrole{o}{=}\DUrole{default_value}{85}}, \emph{\DUrole{n}{normalization\_mode}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{noise\_threshold}\DUrole{o}{=}\DUrole{default_value}{0.2}}, \emph{\DUrole{n}{CoSpar\_KNN}\DUrole{o}{=}\DUrole{default_value}{20}}, \emph{\DUrole{n}{use\_full\_Smatrix}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{smooth\_array}\DUrole{o}{=}\DUrole{default_value}{{[}15, 10, 5{]}}}, \emph{\DUrole{n}{trunca\_threshold}\DUrole{o}{=}\DUrole{default_value}{0.001}}, \emph{\DUrole{n}{compute\_new}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{save\_subset}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
Infer transition map from state information alone.

We iteratively infer transition map between each of the initial
time points {[}‘day\_1’,’day\_2’,…,{]} and the targeted time point.
Given each two\sphinxhyphen{}time pair, we infer the map by either OT method
or HighVar method:
\begin{itemize}
\item {} 
‘OT’: tend to be more accurate, but not reliable
under batch effect. Key parameters: \sphinxtitleref{OT\_epsilon, OT\_dis\_KNN}.

\item {} 
‘HighVar’:  is robust to batch effect, but not as accurate.
Key parameter: \sphinxtitleref{HighVar\_gene\_pctl}.

\end{itemize}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{adata\_orig}} : \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object}] \leavevmode
assumed to be preprocessed, can have multiple time points.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{initial\_time\_points}} : \sphinxtitleref{list}}] \leavevmode
List of initial time points to be included for the transition map.
Like {[}‘day\_1’,’day\_2’{]}. Entries consistent with adata.obs{[}‘time\_info’{]}.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{clonal\_time\_point}} : \sphinxtitleref{str}}] \leavevmode
The time point with clonal observation. Its value should be
consistent with adata.obs{[}‘time\_info’{]}.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{method}} : \sphinxtitleref{str}, optional (default ‘OT’)}] \leavevmode
Method to initialize the transition map from state information.
Choice: \{‘OT’, ‘HighVar’\}.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{OT\_epsilon}} : \sphinxtitleref{float}, optional (default: 0.02)}] \leavevmode
The entropic regularization, \textgreater{}0, a larger one increases
uncertainty of the transition. Relevant when \sphinxtitleref{method=’OT’}.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{OT\_dis\_KNN}} : \sphinxtitleref{int}, optional (default: 5)}] \leavevmode
Number of nearest neighbors to construct the KNN graph for
computing the shortest path distance. Relevant when \sphinxtitleref{method=’OT’}.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{OT\_cost}} : \sphinxtitleref{str}, optional (default: \sphinxtitleref{SPD}), options \{‘GED’,’SPD’\}}] \leavevmode
The cost metric. We provide gene expression distance (GED), and also
shortest path distance (SPD). GED is much faster, but SPD is more accurate.
However, cospar is robust to the initialization.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{HighVar\_gene\_pctl}} : \sphinxtitleref{int}, optional (default: 85)}] \leavevmode
Genes wht a variability percentile higher than this threshold are marked as
highly variable genes for dimension reduction. Range: {[}0,100{]}.
Relevant when \sphinxtitleref{method=’HighVar’}.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{normalization\_mode}} : \sphinxtitleref{int}, optional (default: 1)}] \leavevmode
Method for normalization. Choice: {[}0,1{]}
0, single\sphinxhyphen{}cell normalization
1, Clone normalization

\item[{\sphinxstyleliteralstrong{\sphinxupquote{smooth\_array}} : \sphinxtitleref{list}, optional (default: {[}15,10,5{]})}] \leavevmode
List of smooth rounds at each iteration.
The n\sphinxhyphen{}th entry determines the smooth round for the Smatrix
at the n\sphinxhyphen{}th iteration. Its length determins the number of
iteration. It is better to use a number at the multiple of
5, i.e., 5, 10, 15, 20,…

\item[{\sphinxstyleliteralstrong{\sphinxupquote{CoSpar\_KNN}} : \sphinxtitleref{int}, optional (default: 20)}] \leavevmode
the number of neighbors for KNN graph used for computing the similarity matrix.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{trunca\_threshold}} : \sphinxtitleref{float}, optional (default: 0.001)}] \leavevmode
We set entries to zero in the computed similarity matrix that
are smaller than this threshold. This is to promote the Smatrix sparsity, which
leads to faster computation, and smaller file size.
This threshld should be small, but not too small.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{noise\_threshold}} : \sphinxtitleref{float}, optional (default: 0.1)}] \leavevmode
noise threshold to remove noises in the updated transition map,
in the range {[}0,1{]}

\item[{\sphinxstyleliteralstrong{\sphinxupquote{save\_subset}} : \sphinxtitleref{bool}, optional (default: True)}] \leavevmode
If true, save only Smatrix at smooth round {[}5,10,15,…{]}.
Else, save Smatrix at each round.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{use\_full\_Smatrix}} : \sphinxtitleref{bool}, optional (default: False)}] \leavevmode
use the Smatrix as defined by all cells, whether they are clonally
barcoded or not. We sub\sphinxhyphen{}sample cell states relevant for downstream
analysis from this full Smatrix. This may refine the Smatrix.
But will also increase the computation time significantly.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{compute\_new}} : \sphinxtitleref{bool}, optional (default: False)}] \leavevmode
If True, compute everthing (ShortestPathDis,OT\_map etc.) from scratch,
whether it was computed and saved before or not. Regarding the Smatrix, it is
recomputed only when \sphinxtitleref{use\_full\_Smatrix=False}.

\end{description}

\item[{Returns}] \leavevmode
\sphinxstylestrong{adata} (\sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object) \textendash{} Update adata.uns{[}‘OT\_transition\_map’{]} or adata.uns{[}‘intraclone\_transition\_map’{]},
depending on the initialization.

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.tmap.infer\_Tmap\_from\_clonal\_info\_alone}
\label{\detokenize{cospar.tmap.infer_Tmap_from_clonal_info_alone:cospar-tmap-infer-tmap-from-clonal-info-alone}}\label{\detokenize{cospar.tmap.infer_Tmap_from_clonal_info_alone::doc}}\index{infer\_Tmap\_from\_clonal\_info\_alone() (in module cospar.tmap)@\spxentry{infer\_Tmap\_from\_clonal\_info\_alone()}\spxextra{in module cospar.tmap}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.tmap.infer_Tmap_from_clonal_info_alone:cospar.tmap.infer_Tmap_from_clonal_info_alone}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.tmap.}}\sphinxbfcode{\sphinxupquote{infer\_Tmap\_from\_clonal\_info\_alone}}}{\emph{\DUrole{n}{adata}}, \emph{\DUrole{n}{method}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}naive\textquotesingle{}}}}{}
Compute transition map using only the lineage information

We simply average transitions across all clones, assuming that
the intra\sphinxhyphen{}clone transition is uniform within the same clone.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{adata}} : \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object}] \leavevmode
It should have been preprocessed by {\hyperref[\detokenize{cospar.tmap.select_time_points:cospar.tmap.select_time_points}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{select\_time\_points()}}}}}

\item[{\sphinxstyleliteralstrong{\sphinxupquote{method}} : \sphinxtitleref{str}, optional (default: ‘naive’)}] \leavevmode
Method used to compute the transition map. Choice: \{‘naive’,
‘weinreb’\}. For the naive method, we simply average transitions
across all clones, assuming that the intra\sphinxhyphen{}clone transition is
uniform within the same clone. For the ‘weinreb’ method, we first
find uni\sphinxhyphen{}potent clones, then compute the transition map by simply
averaging across all clonal transitions as the naive method.

\end{description}

\item[{Returns}] \leavevmode
Update \sphinxtitleref{adata} with the attributes adata.uns{[}‘naive\_transition\_map’{]}

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstylestrong{Internal functions}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{cospar.tmap.generate_similarity_matrix:cospar.tmap.generate_similarity_matrix}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tmap.generate\_similarity\_matrix}}}}}(adata, file\_name)
&
Generate similarity matrix (Smatrix) through graph diffusion
\\
\hline
{\hyperref[\detokenize{cospar.tmap.generate_initial_similarity:cospar.tmap.generate_initial_similarity}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tmap.generate\_initial\_similarity}}}}}(…)
&
Extract Smatrix at t1 from the full Smatrix
\\
\hline
{\hyperref[\detokenize{cospar.tmap.generate_final_similarity:cospar.tmap.generate_final_similarity}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tmap.generate\_final\_similarity}}}}}(…)
&
Extract Smatrix at t2 from the full Smatrix
\\
\hline
{\hyperref[\detokenize{cospar.tmap.select_time_points:cospar.tmap.select_time_points}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tmap.select\_time\_points}}}}}(adata\_orig{[}, …{]})
&
Select barcoded cells at given time points for Tmap inference
\\
\hline
{\hyperref[\detokenize{cospar.tmap.infer_Tmap_from_multitime_clones_private:cospar.tmap.infer_Tmap_from_multitime_clones_private}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tmap.infer\_Tmap\_from\_multitime\_clones\_private}}}}}(adata)
&
Internal function for Tmap inference from multiTime clonal data.
\\
\hline
{\hyperref[\detokenize{cospar.tmap.refine_Tmap_through_cospar_noSmooth:cospar.tmap.refine_Tmap_through_cospar_noSmooth}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tmap.refine\_Tmap\_through\_cospar\_noSmooth}}}}}(…)
&
This performs one iteration of coherent sparsity optimization
\\
\hline
{\hyperref[\detokenize{cospar.tmap.refine_Tmap_through_cospar:cospar.tmap.refine_Tmap_through_cospar}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tmap.refine\_Tmap\_through\_cospar}}}}}(…{[}, …{]})
&
This performs one iteration of coherent sparsity optimization
\\
\hline
{\hyperref[\detokenize{cospar.tmap.compute_custom_OT_transition_map:cospar.tmap.compute_custom_OT_transition_map}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tmap.compute\_custom\_OT\_transition\_map}}}}}(adata)
&
Compute Tmap from state info using optimal transport (OT).
\\
\hline
{\hyperref[\detokenize{cospar.tmap.Tmap_from_highly_variable_genes:cospar.tmap.Tmap_from_highly_variable_genes}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tmap.Tmap\_from\_highly\_variable\_genes}}}}}(adata)
&
Generate Tmap based on state info using HighVar.
\\
\hline
{\hyperref[\detokenize{cospar.tmap.infer_Tmap_from_one_time_clones_private:cospar.tmap.infer_Tmap_from_one_time_clones_private}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tmap.infer\_Tmap\_from\_one\_time\_clones\_private}}}}}(…)
&
Infer Tmap from clones with a single time point
\\
\hline
{\hyperref[\detokenize{cospar.tmap.infer_Tmap_from_one_time_clones_twoTime:cospar.tmap.infer_Tmap_from_one_time_clones_twoTime}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tmap.infer\_Tmap\_from\_one\_time\_clones\_twoTime}}}}}(…)
&
Infer transition map from clones with a single time point
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subsubsection{cospar.tmap.generate\_similarity\_matrix}
\label{\detokenize{cospar.tmap.generate_similarity_matrix:cospar-tmap-generate-similarity-matrix}}\label{\detokenize{cospar.tmap.generate_similarity_matrix::doc}}\index{generate\_similarity\_matrix() (in module cospar.tmap)@\spxentry{generate\_similarity\_matrix()}\spxextra{in module cospar.tmap}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.tmap.generate_similarity_matrix:cospar.tmap.generate_similarity_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.tmap.}}\sphinxbfcode{\sphinxupquote{generate\_similarity\_matrix}}}{\emph{\DUrole{n}{adata}}, \emph{\DUrole{n}{file\_name}}, \emph{\DUrole{n}{round\_of\_smooth}\DUrole{o}{=}\DUrole{default_value}{10}}, \emph{\DUrole{n}{neighbor\_N}\DUrole{o}{=}\DUrole{default_value}{20}}, \emph{\DUrole{n}{beta}\DUrole{o}{=}\DUrole{default_value}{0.1}}, \emph{\DUrole{n}{truncation\_threshold}\DUrole{o}{=}\DUrole{default_value}{0.001}}, \emph{\DUrole{n}{save\_subset}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{compute\_new\_Smatrix}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Generate similarity matrix (Smatrix) through graph diffusion

It generates the similarity matrix via iteratively graph diffusion.
Similarity matrix from each round of diffusion will be saved, after truncation
to promote sparsity and save space. If save\_subset is activated, only save
Smatrix for smooth round {[}5,10,15,…{]}. If a Smatrix is pre\sphinxhyphen{}computed,
it will be loaded directly if compute\_new\_Smatrix=Flase.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{adata}} : \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object}] \leavevmode


\item[{\sphinxstyleliteralstrong{\sphinxupquote{file\_name}} : \sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}}] \leavevmode
file name to load pre\sphinxhyphen{}computed similarity matrix or save the newly
computed similarity matrix

\item[{\sphinxstyleliteralstrong{\sphinxupquote{round\_of\_smooth}} : \sphinxtitleref{int}, optional (default: 10)}] \leavevmode
The rounds of graph diffusion.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{neighbor\_N}} : \sphinxtitleref{int}, optional (default: 20)}] \leavevmode
Neighber number for constructing the KNN graph, using the UMAP method.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{beta}} : \sphinxtitleref{float}, option (default: 0.1)}] \leavevmode
Probability to stay at origin in a unit diffusion step, in the range {[}0,1{]}

\item[{\sphinxstyleliteralstrong{\sphinxupquote{truncation\_threshold}} : \sphinxtitleref{float}, optional (default: 0.001)}] \leavevmode
At each iteration, truncate the similarity matrix (the similarity) using
truncation\_threshold. This promotes the sparsity of the matrix,
thus the speed of computation. We set the truncation threshold to be small,
to guarantee accracy.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{save\_subset}} : \sphinxtitleref{bool}, optional (default: True)}] \leavevmode
If true, save only Smatrix at smooth round {[}5,10,15,…{]}
Else, save Smatrix at each round.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{compute\_new\_Smatrix}} : \sphinxtitleref{bool}, optional (default: False)}] \leavevmode
If true, compute new Smatrix, even if there is pre\sphinxhyphen{}computed Smatrix with the
same parameterization.

\end{description}

\item[{Returns}] \leavevmode
\sphinxstylestrong{similarity\_matrix} (\sphinxtitleref{sp.spmatrix})

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.tmap.generate\_initial\_similarity}
\label{\detokenize{cospar.tmap.generate_initial_similarity:cospar-tmap-generate-initial-similarity}}\label{\detokenize{cospar.tmap.generate_initial_similarity::doc}}\index{generate\_initial\_similarity() (in module cospar.tmap)@\spxentry{generate\_initial\_similarity()}\spxextra{in module cospar.tmap}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.tmap.generate_initial_similarity:cospar.tmap.generate_initial_similarity}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.tmap.}}\sphinxbfcode{\sphinxupquote{generate\_initial\_similarity}}}{\emph{\DUrole{n}{similarity\_matrix}}, \emph{\DUrole{n}{initial\_index\_0}}, \emph{\DUrole{n}{initial\_index\_1}}}{}
Extract Smatrix at t1 from the full Smatrix
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{similarity\_matrix}} : \sphinxtitleref{np.array} or \sphinxtitleref{sp.spmatrix}}] \leavevmode
full Smatrix

\item[{\sphinxstyleliteralstrong{\sphinxupquote{initial\_index\_0}} : \sphinxtitleref{list}}] \leavevmode
list of selected t1\sphinxhyphen{}cell id among all cells (t1+t2)

\item[{\sphinxstyleliteralstrong{\sphinxupquote{initial\_index\_1}} : \sphinxtitleref{list}}] \leavevmode
list of selected t1\sphinxhyphen{}cell id among all cells (t1+t2)
It can be the same as initial\_index\_0. In the case that they are different,
initial\_index\_1 is a subset of cells that correspond to multi\sphinxhyphen{}time clones,
while initial\_index\_0 may be all cells at t1.

\end{description}

\item[{Returns}] \leavevmode
\sphinxstylestrong{initial Smatrix} (\sphinxtitleref{np.array})

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.tmap.generate\_final\_similarity}
\label{\detokenize{cospar.tmap.generate_final_similarity:cospar-tmap-generate-final-similarity}}\label{\detokenize{cospar.tmap.generate_final_similarity::doc}}\index{generate\_final\_similarity() (in module cospar.tmap)@\spxentry{generate\_final\_similarity()}\spxextra{in module cospar.tmap}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.tmap.generate_final_similarity:cospar.tmap.generate_final_similarity}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.tmap.}}\sphinxbfcode{\sphinxupquote{generate\_final\_similarity}}}{\emph{\DUrole{n}{similarity\_matrix}}, \emph{\DUrole{n}{final\_index\_0}}, \emph{\DUrole{n}{final\_index\_1}}}{}
Extract Smatrix at t2 from the full Smatrix
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{similarity\_matrix}} : \sphinxtitleref{np.array} or \sphinxtitleref{sp.spmatrix}}] \leavevmode
full Smatrix

\item[{\sphinxstyleliteralstrong{\sphinxupquote{final\_index\_0}} : \sphinxtitleref{list}}] \leavevmode
list of selected t2\sphinxhyphen{}cell id among all cells (t1+t2)

\item[{\sphinxstyleliteralstrong{\sphinxupquote{final\_index\_1}} : \sphinxtitleref{list}}] \leavevmode
list of selected t2\sphinxhyphen{}cell id among all cells (t1+t2)
It can be the same as final\_index\_0. In the case that they are different,
initial\_index\_0 is a subset of cells that correspond to multi\sphinxhyphen{}time clones,
while initial\_index\_1 may be all cells at t2.

\end{description}

\item[{Returns}] \leavevmode
\sphinxstylestrong{initial Smatrix} (\sphinxtitleref{np.array})

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.tmap.select\_time\_points}
\label{\detokenize{cospar.tmap.select_time_points:cospar-tmap-select-time-points}}\label{\detokenize{cospar.tmap.select_time_points::doc}}\index{select\_time\_points() (in module cospar.tmap)@\spxentry{select\_time\_points()}\spxextra{in module cospar.tmap}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.tmap.select_time_points:cospar.tmap.select_time_points}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.tmap.}}\sphinxbfcode{\sphinxupquote{select\_time\_points}}}{\emph{\DUrole{n}{adata\_orig}}, \emph{\DUrole{n}{time\_point}\DUrole{o}{=}\DUrole{default_value}{{[}\textquotesingle{}day\_1\textquotesingle{}, \textquotesingle{}day\_2\textquotesingle{}{]}}}, \emph{\DUrole{n}{use\_all\_cells}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Select barcoded cells at given time points for Tmap inference

Select cells at given time points, and prepare the right data structure
for running core cospar function to infer the Tmap.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{adata\_orig}} : original \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object}] \leavevmode


\item[{\sphinxstyleliteralstrong{\sphinxupquote{time\_point}} : \sphinxtitleref{list} optional (default: {[}‘day\_1’,’day\_2’{]})}] \leavevmode
Require at least two time points, arranged in ascending order.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{use\_all\_cells}} : \sphinxtitleref{bool} optional (default: \sphinxtitleref{False})}] \leavevmode
If true, all cells at selected time points will be used for computing Tmap
If false, only cells belonging to multi\sphinxhyphen{}time clones will be used for computing Tmap.
The latter case usually speed up the computation, which is recommended.

\end{description}

\item[{Returns}] \leavevmode
Subsampled \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.tmap.infer\_Tmap\_from\_multitime\_clones\_private}
\label{\detokenize{cospar.tmap.infer_Tmap_from_multitime_clones_private:cospar-tmap-infer-tmap-from-multitime-clones-private}}\label{\detokenize{cospar.tmap.infer_Tmap_from_multitime_clones_private::doc}}\index{infer\_Tmap\_from\_multitime\_clones\_private() (in module cospar.tmap)@\spxentry{infer\_Tmap\_from\_multitime\_clones\_private()}\spxextra{in module cospar.tmap}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.tmap.infer_Tmap_from_multitime_clones_private:cospar.tmap.infer_Tmap_from_multitime_clones_private}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.tmap.}}\sphinxbfcode{\sphinxupquote{infer\_Tmap\_from\_multitime\_clones\_private}}}{\emph{\DUrole{n}{adata}}, \emph{\DUrole{n}{smooth\_array}\DUrole{o}{=}\DUrole{default_value}{{[}15, 10, 5{]}}}, \emph{\DUrole{n}{neighbor\_N}\DUrole{o}{=}\DUrole{default_value}{20}}, \emph{\DUrole{n}{noise\_threshold}\DUrole{o}{=}\DUrole{default_value}{0.1}}, \emph{\DUrole{n}{demulti\_threshold}\DUrole{o}{=}\DUrole{default_value}{0.05}}, \emph{\DUrole{n}{normalization\_mode}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{save\_subset}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{use\_full\_Smatrix}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{trunca\_threshold}\DUrole{o}{=}\DUrole{default_value}{0.001}}, \emph{\DUrole{n}{compute\_new\_Smatrix}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Internal function for Tmap inference from multiTime clonal data.

Same as {\hyperref[\detokenize{cospar.tmap.infer_Tmap_from_multitime_clones:cospar.tmap.infer_Tmap_from_multitime_clones}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{infer\_Tmap\_from\_multitime\_clones()}}}}} except that it
assumes that the adata object has been prepared for targeted
time points. It generate the similarity matrix
via {\hyperref[\detokenize{cospar.tmap.generate_similarity_matrix:cospar.tmap.generate_similarity_matrix}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{generate\_similarity\_matrix()}}}}}, and iterately calls
the core function {\hyperref[\detokenize{cospar.tmap.refine_Tmap_through_cospar:cospar.tmap.refine_Tmap_through_cospar}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{refine\_Tmap\_through\_cospar()}}}}} to update
the transition map.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{adata}} : \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object}] \leavevmode
Should be prepared by {\hyperref[\detokenize{cospar.tmap.select_time_points:cospar.tmap.select_time_points}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{select\_time\_points()}}}}}

\item[{\sphinxstyleliteralstrong{\sphinxupquote{smooth\_array}} : \sphinxtitleref{list}, optional (default: {[}15,10,5{]})}] \leavevmode
List of smooth rounds at each iteration.
The n\sphinxhyphen{}th entry determines the smooth round for the Smatrix
at the n\sphinxhyphen{}th iteration. Its length determins the number of
iteration. It is better to use a number at the multiple of
5, i.e., 5, 10, 15, 20,…

\item[{\sphinxstyleliteralstrong{\sphinxupquote{neighbor\_N}} : \sphinxtitleref{int}, optional (default: 20)}] \leavevmode
the number of neighbors for KNN graph used for computing the similarity matrix.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{trunca\_threshold}} : \sphinxtitleref{float}, optional (default: 0.001)}] \leavevmode
We set entries to zero in the computed similarity matrix that
are smaller than this threshold. This is to promote the Smatrix sparsity, which
leads to faster computation, and smaller file size.
This threshld should be small, but not too small.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{noise\_threshold}} : \sphinxtitleref{float}, optional (default: 0.1)}] \leavevmode
noise threshold to remove noises in the updated transition map,
in the range {[}0,1{]}

\item[{\sphinxstyleliteralstrong{\sphinxupquote{demulti\_threshold}} : \sphinxtitleref{float}, optional (default: 0.05)}] \leavevmode
noise threshold to remove noises in demultiplexed (un\sphinxhyphen{}smoothed) map,
in the range {[}0,1{]}

\item[{\sphinxstyleliteralstrong{\sphinxupquote{normalization\_mode}} : \sphinxtitleref{int}, optional (default: 1)}] \leavevmode
Method for normalization. Choice: {[}0,1{]}
0, single\sphinxhyphen{}cell normalization
1, Clone normalization

\item[{\sphinxstyleliteralstrong{\sphinxupquote{save\_subset}} : \sphinxtitleref{bool}, optional (default: True)}] \leavevmode
If true, save only Smatrix at smooth round {[}5,10,15,…{]}.
Else, save Smatrix at each round.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{use\_full\_Smatrix}} : \sphinxtitleref{bool}, optional (default: False)}] \leavevmode
use the Smatrix as defined by all cells, whether they are clonally
barcoded or not. We sub\sphinxhyphen{}sample cell states relevant for downstream
analysis from this full Smatrix. This may refine the Smatrix.
But will also increase the computation time significantly.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{compute\_new\_Smatrix}} : \sphinxtitleref{bool}, optional (default: False)}] \leavevmode
If True, compute Smatrix from scratch, whether it was
computed and saved before or not. This is activated only when
\sphinxtitleref{use\_full\_Smatrix=False}.

\end{description}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstyleemphasis{None. Inferred transition map updated at adata.uns{[}‘transition\_map’{]}}

\item {} 
\sphinxstyleemphasis{and adata.uns{[}‘intraclone\_transition\_map’{]}}

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.tmap.refine\_Tmap\_through\_cospar\_noSmooth}
\label{\detokenize{cospar.tmap.refine_Tmap_through_cospar_noSmooth:cospar-tmap-refine-tmap-through-cospar-nosmooth}}\label{\detokenize{cospar.tmap.refine_Tmap_through_cospar_noSmooth::doc}}\index{refine\_Tmap\_through\_cospar\_noSmooth() (in module cospar.tmap)@\spxentry{refine\_Tmap\_through\_cospar\_noSmooth()}\spxextra{in module cospar.tmap}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.tmap.refine_Tmap_through_cospar_noSmooth:cospar.tmap.refine_Tmap_through_cospar_noSmooth}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.tmap.}}\sphinxbfcode{\sphinxupquote{refine\_Tmap\_through\_cospar\_noSmooth}}}{\emph{\DUrole{n}{MultiTime\_cell\_id\_array\_t1}}, \emph{\DUrole{n}{MultiTime\_cell\_id\_array\_t2}}, \emph{\DUrole{n}{proportion}}, \emph{\DUrole{n}{transition\_map}}, \emph{\DUrole{n}{X\_clone}}, \emph{\DUrole{n}{noise\_threshold}\DUrole{o}{=}\DUrole{default_value}{0.1}}, \emph{\DUrole{n}{normalization\_mode}\DUrole{o}{=}\DUrole{default_value}{1}}}{}
This performs one iteration of coherent sparsity optimization

This is the same as ‘refine\_Tmap\_through\_cospar’, except that
there is no smoothing afterwards for demultiplexing.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{MultiTime\_cell\_id\_array\_t1}} : \sphinxtitleref{np.array}}] \leavevmode
an array of cell id sub\_array, where each sub\_array consists of
clonally\sphinxhyphen{}related cell id’s at different time points

\item[{\sphinxstyleliteralstrong{\sphinxupquote{MultiTime\_cell\_id\_array\_t2}} : \sphinxtitleref{np.array}}] \leavevmode
an corresponding array of sub\_array, where each sub\_array are id’s of
cells that are clonally related to the corresponding sub\_array at
MultiTime\_cell\_id\_array\_t1.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{proportion}} : \sphinxtitleref{list}}] \leavevmode
A weight factor for each time point.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{transition\_map}} : \sphinxtitleref{np.array} or \sphinxtitleref{sp.spmatrix}}] \leavevmode
initialized transition map, or map from a previous iteration.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{X\_clone}} : \sphinxtitleref{sp.spmatrix}}] \leavevmode
clonal matrix

\item[{\sphinxstyleliteralstrong{\sphinxupquote{initial\_similarity}} : \sphinxtitleref{np.array}}] \leavevmode
similarity matrix for all cells belonging
to MultiTime\_cell\_id\_array\_t1

\item[{\sphinxstyleliteralstrong{\sphinxupquote{final\_similarity}} : \sphinxtitleref{np.array}}] \leavevmode
similarity matrix for all cells belonging
to MultiTime\_cell\_id\_array\_t2

\item[{\sphinxstyleliteralstrong{\sphinxupquote{noise\_threshold}} : \sphinxtitleref{float}, optional (default: 0.1)}] \leavevmode
noise threshold to remove noises in the updated transition map,
in the range {[}0,1{]}

\item[{\sphinxstyleliteralstrong{\sphinxupquote{normalization\_mode}} : \sphinxtitleref{int}, optional (default: 1)}] \leavevmode
Method for normalization. Choice: {[}0,1{]}
0, single\sphinxhyphen{}cell normalization
1, Clone normalization

\end{description}

\item[{Returns}] \leavevmode
\sphinxstylestrong{un\_SM\_transition\_map} (\sphinxtitleref{np.array})

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.tmap.refine\_Tmap\_through\_cospar}
\label{\detokenize{cospar.tmap.refine_Tmap_through_cospar:cospar-tmap-refine-tmap-through-cospar}}\label{\detokenize{cospar.tmap.refine_Tmap_through_cospar::doc}}\index{refine\_Tmap\_through\_cospar() (in module cospar.tmap)@\spxentry{refine\_Tmap\_through\_cospar()}\spxextra{in module cospar.tmap}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.tmap.refine_Tmap_through_cospar:cospar.tmap.refine_Tmap_through_cospar}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.tmap.}}\sphinxbfcode{\sphinxupquote{refine\_Tmap\_through\_cospar}}}{\emph{\DUrole{n}{MultiTime\_cell\_id\_array\_t1}}, \emph{\DUrole{n}{MultiTime\_cell\_id\_array\_t2}}, \emph{\DUrole{n}{proportion}}, \emph{\DUrole{n}{transition\_map}}, \emph{\DUrole{n}{X\_clone}}, \emph{\DUrole{n}{initial\_similarity}}, \emph{\DUrole{n}{final\_similarity}}, \emph{\DUrole{n}{noise\_threshold}\DUrole{o}{=}\DUrole{default_value}{0.1}}, \emph{\DUrole{n}{normalization\_mode}\DUrole{o}{=}\DUrole{default_value}{1}}}{}
This performs one iteration of coherent sparsity optimization

This is our core algorithm for coherent sparsity optimization for multi\sphinxhyphen{}time
clones. It upates a map by considering clones spanning multiple time points.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{MultiTime\_cell\_id\_array\_t1}} : \sphinxtitleref{np.array}}] \leavevmode
an array of cell id sub\_array, where each sub\_array consists of
clonally\sphinxhyphen{}related cell id’s at different time points

\item[{\sphinxstyleliteralstrong{\sphinxupquote{MultiTime\_cell\_id\_array\_t2}} : \sphinxtitleref{np.array}}] \leavevmode
an corresponding array of sub\_array, where each sub\_array are id’s of
cells that are clonally related to the corresponding sub\_array at
MultiTime\_cell\_id\_array\_t1.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{proportion}} : \sphinxtitleref{list}}] \leavevmode
A weight factor for each time point.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{transition\_map}} : \sphinxtitleref{np.array} or \sphinxtitleref{sp.spmatrix}}] \leavevmode
initialized transition map, or map from a previous iteration.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{X\_clone}} : \sphinxtitleref{sp.spmatrix}}] \leavevmode
clonal matrix

\item[{\sphinxstyleliteralstrong{\sphinxupquote{initial\_similarity}} : \sphinxtitleref{np.array}}] \leavevmode
similarity matrix for all cells belonging
to MultiTime\_cell\_id\_array\_t1

\item[{\sphinxstyleliteralstrong{\sphinxupquote{final\_similarity}} : \sphinxtitleref{np.array}}] \leavevmode
similarity matrix for all cells belonging
to MultiTime\_cell\_id\_array\_t2

\item[{\sphinxstyleliteralstrong{\sphinxupquote{noise\_threshold}} : \sphinxtitleref{float}, optional (default: 0.1)}] \leavevmode
noise threshold to remove noises in the updated transition map,
in the range {[}0,1{]}

\item[{\sphinxstyleliteralstrong{\sphinxupquote{normalization\_mode}} : \sphinxtitleref{int}, optional (default: 1)}] \leavevmode
Method for normalization. Choice: {[}0,1{]}
0, single\sphinxhyphen{}cell normalization
1, Clone normalization

\end{description}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{smoothed\_new\_transition\_map} (\sphinxtitleref{np.array})

\item {} 
\sphinxstylestrong{un\_SM\_transition\_map} (\sphinxtitleref{np.array})

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.tmap.compute\_custom\_OT\_transition\_map}
\label{\detokenize{cospar.tmap.compute_custom_OT_transition_map:cospar-tmap-compute-custom-ot-transition-map}}\label{\detokenize{cospar.tmap.compute_custom_OT_transition_map::doc}}\index{compute\_custom\_OT\_transition\_map() (in module cospar.tmap)@\spxentry{compute\_custom\_OT\_transition\_map()}\spxextra{in module cospar.tmap}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.tmap.compute_custom_OT_transition_map:cospar.tmap.compute_custom_OT_transition_map}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.tmap.}}\sphinxbfcode{\sphinxupquote{compute\_custom\_OT\_transition\_map}}}{\emph{\DUrole{n}{adata}}, \emph{\DUrole{n}{OT\_epsilon}\DUrole{o}{=}\DUrole{default_value}{0.02}}, \emph{\DUrole{n}{OT\_dis\_KNN}\DUrole{o}{=}\DUrole{default_value}{5}}, \emph{\DUrole{n}{OT\_solver}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}duality\_gap\textquotesingle{}}}, \emph{\DUrole{n}{OT\_cost}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}SPD\textquotesingle{}}}, \emph{\DUrole{n}{compute\_new}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
Compute Tmap from state info using optimal transport (OT).

We provide the options for the OT solver, and also the cost function.
The OT solver does not seem to matter, although ‘duality\_gap’ is faster.
The cost function could affect the OT map results. Using shortest path
distance (‘SPD’) is slower but more accurate, while using gene expression
distance (‘GED’) is faster but less accurate. The performance of cospar
is robust to the initialized map (this is especially so in terms of fate
bias, not so much for the fate map alone)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{adata}} : \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object}] \leavevmode
Assumed to be preprocessed, only has two time points.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{OT\_epsilon}} : \sphinxtitleref{float}, optional (default: 0.02)}] \leavevmode
The entropic regularization, \textgreater{}0, a larger one increases
uncertainty of the transition

\item[{\sphinxstyleliteralstrong{\sphinxupquote{OT\_dis\_KNN}} : \sphinxtitleref{int}, optional (default: 5)}] \leavevmode
Number of nearest neighbors to construct the KNN graph for
computing the shortest path distance.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{OT\_solver}} : \sphinxtitleref{str}, optional (default: \sphinxtitleref{duality\_gap})}] \leavevmode
The method used to compute the optimal transport map. Availabel choice:
\{‘duality\_gap’,’fixed\_iters’\}. Our test shows that they produce the same
results, while ‘duality\_gap’ is almost twice faster.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{OT\_cost}} : \sphinxtitleref{str}, optional (default: \sphinxtitleref{SPD}), options \{‘GED’,’SPD’\}}] \leavevmode
The cost metric. We provide gene expression distance (GED), and also
shortest path distance (SPD). GED is much faster, but SPD is more accurate.
However, cospar is robust to the initialization.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{compute\_new}} : \sphinxtitleref{bool}, optional (default: False)}] \leavevmode
If True, compute OT\_map and also the shortest path distance from scratch,
whether it was computed and saved before or not.

\end{description}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{None. Results are stored at adata.uns{[}‘OT\_transition\_map’{]}.}

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.tmap.Tmap\_from\_highly\_variable\_genes}
\label{\detokenize{cospar.tmap.Tmap_from_highly_variable_genes:cospar-tmap-tmap-from-highly-variable-genes}}\label{\detokenize{cospar.tmap.Tmap_from_highly_variable_genes::doc}}\index{Tmap\_from\_highly\_variable\_genes() (in module cospar.tmap)@\spxentry{Tmap\_from\_highly\_variable\_genes()}\spxextra{in module cospar.tmap}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.tmap.Tmap_from_highly_variable_genes:cospar.tmap.Tmap_from_highly_variable_genes}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.tmap.}}\sphinxbfcode{\sphinxupquote{Tmap\_from\_highly\_variable\_genes}}}{\emph{\DUrole{n}{adata}}, \emph{\DUrole{n}{min\_counts}\DUrole{o}{=}\DUrole{default_value}{3}}, \emph{\DUrole{n}{min\_cells}\DUrole{o}{=}\DUrole{default_value}{3}}, \emph{\DUrole{n}{min\_gene\_vscore\_pctl}\DUrole{o}{=}\DUrole{default_value}{85}}, \emph{\DUrole{n}{smooth\_array}\DUrole{o}{=}\DUrole{default_value}{{[}15, 10, 5{]}}}, \emph{\DUrole{n}{neighbor\_N}\DUrole{o}{=}\DUrole{default_value}{20}}, \emph{\DUrole{n}{noise\_threshold}\DUrole{o}{=}\DUrole{default_value}{0.2}}, \emph{\DUrole{n}{normalization\_mode}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{use\_full\_Smatrix}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{trunca\_threshold}\DUrole{o}{=}\DUrole{default_value}{0.001}}, \emph{\DUrole{n}{compute\_new\_Smatrix}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{save\_subset}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
Generate Tmap based on state info using HighVar.

We convert differentially expressed genes into \sphinxtitleref{pseudo\sphinxhyphen{}clones},
and run cospar to infer the transition map. Each clone occupies
a different set of cells.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{adata}} : \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object}] \leavevmode
assumed to be preprocessed, only has two time points.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{min\_counts}} : \sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{default: 3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}}] \leavevmode
Minimum number of UMIs per cell to be considered for selecting highly variable genes.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{min\_cells}} : \sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{default: 3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}}] \leavevmode
Minimum number of cells per gene to be considered for selecting highly variable genes.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{min\_gene\_vscore\_pctl}} : \sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{default: 85}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}}] \leavevmode
Genes wht a variability percentile higher than this threshold are marked as
highly variable genes for dimension reduction. Range: {[}0,100{]}

\item[{\sphinxstyleliteralstrong{\sphinxupquote{smooth\_array}} : \sphinxtitleref{list}, optional (default: {[}15,10,5{]})}] \leavevmode
List of smooth rounds at each iteration.
The n\sphinxhyphen{}th entry determines the smooth round for the Smatrix
at the n\sphinxhyphen{}th iteration. Its length determins the number of
iteration.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{neighbor\_N}} : \sphinxtitleref{int}, optional (default: 20)}] \leavevmode
the number of neighbors for KNN graph used for computing the similarity matrix.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{trunca\_threshold}} : \sphinxtitleref{float}, optional (default: 0.001)}] \leavevmode
We set entries to zero in the computed similarity matrix that
are smaller than this threshold. This is to promote the Smatrix sparsity, which
leads to faster computation, and smaller file size.
This threshld should be small, but not too small.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{noise\_threshold}} : \sphinxtitleref{float}, optional (default: 0.1)}] \leavevmode
noise threshold to remove noises in the updated transition map,
in the range {[}0,1{]}

\item[{\sphinxstyleliteralstrong{\sphinxupquote{normalization\_mode}} : \sphinxtitleref{int}, optional (default: 2)}] \leavevmode
Method for normalization. Choice: {[}0,1,2{]}
0, single\sphinxhyphen{}cell normalization
1, Clone normalization: N2/N1 (this one does not make sense)
2, Clone normalization

\item[{\sphinxstyleliteralstrong{\sphinxupquote{save\_subset}} : \sphinxtitleref{bool}, optional (default: True)}] \leavevmode
If true, save only Smatrix at smooth round {[}5,10,15,…{]}.
Else, save Smatrix at each round.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{use\_full\_Smatrix}} : \sphinxtitleref{bool}, optional (default: False)}] \leavevmode
use the Smatrix as defined by all cells, whether they are clonally
barcoded or not. We sub\sphinxhyphen{}sample cell states relevant for downstream
analysis from this full Smatrix. This may refine the Smatrix.
But will also increase the computation time significantly.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{compute\_new\_Smatrix}} : \sphinxtitleref{bool}, optional (default: False)}] \leavevmode
If True, compute Smatrix from scratch, whether it was
computed and saved before or not.

\end{description}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{None. Results are stored at adata.uns{[}‘HighVar\_transition\_map’{]}.}

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.tmap.infer\_Tmap\_from\_one\_time\_clones\_private}
\label{\detokenize{cospar.tmap.infer_Tmap_from_one_time_clones_private:cospar-tmap-infer-tmap-from-one-time-clones-private}}\label{\detokenize{cospar.tmap.infer_Tmap_from_one_time_clones_private::doc}}\index{infer\_Tmap\_from\_one\_time\_clones\_private() (in module cospar.tmap)@\spxentry{infer\_Tmap\_from\_one\_time\_clones\_private()}\spxextra{in module cospar.tmap}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.tmap.infer_Tmap_from_one_time_clones_private:cospar.tmap.infer_Tmap_from_one_time_clones_private}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.tmap.}}\sphinxbfcode{\sphinxupquote{infer\_Tmap\_from\_one\_time\_clones\_private}}}{\emph{\DUrole{n}{adata}}, \emph{\DUrole{n}{initialized\_map}}, \emph{\DUrole{n}{Clone\_update\_iter\_N}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{smooth\_array}\DUrole{o}{=}\DUrole{default_value}{{[}15, 10, 5{]}}}, \emph{\DUrole{n}{CoSpar\_KNN}\DUrole{o}{=}\DUrole{default_value}{20}}, \emph{\DUrole{n}{normalization\_mode}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{noise\_threshold}\DUrole{o}{=}\DUrole{default_value}{0.2}}, \emph{\DUrole{n}{use\_full\_Smatrix}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{trunca\_threshold}\DUrole{o}{=}\DUrole{default_value}{0.001}}, \emph{\DUrole{n}{compute\_new}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{use\_fixed\_clonesize\_t1}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{sort\_clone}\DUrole{o}{=}\DUrole{default_value}{1}}}{}
Infer Tmap from clones with a single time point

Starting from an initialized transitin map from state information,
we jointly infer the initial clonal states and the transition map.

This method has been optimized to be very fast. Besides, it is
deterministic.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{adata}} : \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object}] \leavevmode
Should have only two time points.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{initialized\_map}} : \sphinxtitleref{sp.spmatrix}}] \leavevmode
Initialized transition map based on state information alone.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{Clone\_update\_iter\_N}} : \sphinxtitleref{int}, optional (default: 1)}] \leavevmode
Number of iteration for the joint optimization.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{normalization\_mode}} : \sphinxtitleref{int}, optional (default: 1)}] \leavevmode
Method for normalization. Choice: {[}0,1{]}
0, single\sphinxhyphen{}cell normalization
1, Clone normalization

\item[{\sphinxstyleliteralstrong{\sphinxupquote{smooth\_array}} : \sphinxtitleref{list}, optional (default: {[}15,10,5{]})}] \leavevmode
List of smooth rounds at each iteration.
The n\sphinxhyphen{}th entry determines the smooth round for the Smatrix
at the n\sphinxhyphen{}th iteration. Its length determins the number of
iteration. It is better to use a number at the multiple of
5, i.e., 5, 10, 15, 20,…

\item[{\sphinxstyleliteralstrong{\sphinxupquote{CoSpar\_KNN}} : \sphinxtitleref{int}, optional (default: 20)}] \leavevmode
the number of neighbors for KNN graph used for computing the similarity matrix.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{trunca\_threshold}} : \sphinxtitleref{float}, optional (default: 0.001)}] \leavevmode
We set entries to zero in the computed similarity matrix that
are smaller than this threshold. This is to promote the Smatrix sparsity, which
leads to faster computation, and smaller file size.
This threshld should be small, but not too small.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{noise\_threshold}} : \sphinxtitleref{float}, optional (default: 0.1)}] \leavevmode
threshold to remove noises in the updated transition map,
in the range {[}0,1{]}

\item[{\sphinxstyleliteralstrong{\sphinxupquote{save\_subset}} : \sphinxtitleref{bool}, optional (default: True)}] \leavevmode
If true, save only Smatrix at smooth round {[}5,10,15,…{]}.
Else, save Smatrix at each round.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{use\_full\_Smatrix}} : \sphinxtitleref{bool}, optional (default: False)}] \leavevmode
use the Smatrix as defined by all cells, whether they are clonally
barcoded or not. We sub\sphinxhyphen{}sample cell states relevant for downstream
analysis from this full Smatrix. This may refine the Smatrix.
But will also increase the computation time significantly.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{use\_fixed\_clonesize\_t1}} : \sphinxtitleref{bool}, optional (default: False)}] \leavevmode
If true, fix the number of initial states as the same for all clones

\item[{\sphinxstyleliteralstrong{\sphinxupquote{sort\_clone}} : \sphinxtitleref{int}, optional (default: 1)}] \leavevmode
The order to infer initial states for each clone: \{1,\sphinxhyphen{}1,others\}
1, sort clones by size from small to large
\sphinxhyphen{}1,sort clones by size from large to small
others, do not sort.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{compute\_new}} : \sphinxtitleref{bool}, optional (default: False)}] \leavevmode
If True, compute everthing (ShortestPathDis,OT\_map etc.) from scratch,
whether it was computed and saved before or not.

\end{description}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstyleemphasis{None. Update adata.obsm{[}‘X\_clone’{]} and adata.uns{[}‘transition\_map’{]},}

\item {} 
\sphinxstyleemphasis{as well as adata.uns{[}‘OT\_transition\_map’{]} or}

\item {} 
\sphinxstyleemphasis{adata.uns{[}‘intraclone\_transition\_map’{]}, depending on the initialization.}

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.tmap.infer\_Tmap\_from\_one\_time\_clones\_twoTime}
\label{\detokenize{cospar.tmap.infer_Tmap_from_one_time_clones_twoTime:cospar-tmap-infer-tmap-from-one-time-clones-twotime}}\label{\detokenize{cospar.tmap.infer_Tmap_from_one_time_clones_twoTime::doc}}\index{infer\_Tmap\_from\_one\_time\_clones\_twoTime() (in module cospar.tmap)@\spxentry{infer\_Tmap\_from\_one\_time\_clones\_twoTime()}\spxextra{in module cospar.tmap}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.tmap.infer_Tmap_from_one_time_clones_twoTime:cospar.tmap.infer_Tmap_from_one_time_clones_twoTime}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.tmap.}}\sphinxbfcode{\sphinxupquote{infer\_Tmap\_from\_one\_time\_clones\_twoTime}}}{\emph{\DUrole{n}{adata\_orig}}, \emph{\DUrole{n}{selected\_two\_time\_points}\DUrole{o}{=}\DUrole{default_value}{{[}\textquotesingle{}1\textquotesingle{}, \textquotesingle{}2\textquotesingle{}{]}}}, \emph{\DUrole{n}{initialize\_method}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}OT\textquotesingle{}}}, \emph{\DUrole{n}{OT\_epsilon}\DUrole{o}{=}\DUrole{default_value}{0.02}}, \emph{\DUrole{n}{OT\_dis\_KNN}\DUrole{o}{=}\DUrole{default_value}{5}}, \emph{\DUrole{n}{OT\_cost}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}SPD\textquotesingle{}}}, \emph{\DUrole{n}{HighVar\_gene\_pctl}\DUrole{o}{=}\DUrole{default_value}{80}}, \emph{\DUrole{n}{Clone\_update\_iter\_N}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{normalization\_mode}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{noise\_threshold}\DUrole{o}{=}\DUrole{default_value}{0.2}}, \emph{\DUrole{n}{CoSpar\_KNN}\DUrole{o}{=}\DUrole{default_value}{20}}, \emph{\DUrole{n}{use\_full\_Smatrix}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{smooth\_array}\DUrole{o}{=}\DUrole{default_value}{{[}15, 10, 5{]}}}, \emph{\DUrole{n}{trunca\_threshold}\DUrole{o}{=}\DUrole{default_value}{0.001}}, \emph{\DUrole{n}{compute\_new}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{use\_fixed\_clonesize\_t1}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{sort\_clone}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{save\_subset}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{joint\_optimization}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
Infer transition map from clones with a single time point

It is the same as {\hyperref[\detokenize{cospar.tmap.infer_Tmap_from_one_time_clones:cospar.tmap.infer_Tmap_from_one_time_clones}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{infer\_Tmap\_from\_one\_time\_clones()}}}}}, except that
it assumes that the input adata\_orig has only two time points.

joint\_optimization: \sphinxtitleref{bool}, optional (default: True).

\end{fulllineitems}



\subsection{Plotting}
\label{\detokenize{api:plotting}}
\sphinxstylestrong{Clone analysis} (clone visualization, clustering etc.)


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{cospar.pl.clones_on_manifold:cospar.pl.clones_on_manifold}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pl.clones\_on\_manifold}}}}}(adata{[}, …{]})
&
Plot clones on top of state embedding.
\\
\hline
{\hyperref[\detokenize{cospar.pl.barcode_heatmap:cospar.pl.barcode_heatmap}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pl.barcode\_heatmap}}}}}(adata, plot\_time\_point{[}, …{]})
&
Plot barcode heatmap among different fate clusters.
\\
\hline
{\hyperref[\detokenize{cospar.pl.fate_coupling_from_clones:cospar.pl.fate_coupling_from_clones}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pl.fate\_coupling\_from\_clones}}}}}(adata, …{[}, …{]})
&
Plot fate coupling determined by just clones.
\\
\hline
{\hyperref[\detokenize{cospar.pl.clonal_fate_bias:cospar.pl.clonal_fate_bias}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pl.clonal\_fate\_bias}}}}}(adata{[}, selected\_fate, …{]})
&
Plot clonal fate bias towards a cluster.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subsubsection{cospar.pl.clones\_on\_manifold}
\label{\detokenize{cospar.pl.clones_on_manifold:cospar-pl-clones-on-manifold}}\label{\detokenize{cospar.pl.clones_on_manifold::doc}}\index{clones\_on\_manifold() (in module cospar.pl)@\spxentry{clones\_on\_manifold()}\spxextra{in module cospar.pl}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.pl.clones_on_manifold:cospar.pl.clones_on_manifold}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.pl.}}\sphinxbfcode{\sphinxupquote{clones\_on\_manifold}}}{\emph{\DUrole{n}{adata}}, \emph{\DUrole{n}{selected\_clone\_list}\DUrole{o}{=}\DUrole{default_value}{{[}0{]}}}, \emph{\DUrole{n}{point\_size}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{color\_list}\DUrole{o}{=}\DUrole{default_value}{{[}\textquotesingle{}red\textquotesingle{}, \textquotesingle{}blue\textquotesingle{}, \textquotesingle{}purple\textquotesingle{}, \textquotesingle{}green\textquotesingle{}, \textquotesingle{}cyan\textquotesingle{}, \textquotesingle{}black\textquotesingle{}{]}}}, \emph{\DUrole{n}{time\_points}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}}{}
Plot clones on top of state embedding.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{adata}} : \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object}] \leavevmode


\item[{\sphinxstyleliteralstrong{\sphinxupquote{selected\_clone\_list}} : \sphinxtitleref{list}}] \leavevmode
List of selected clone ID’s.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{point\_size}} : \sphinxtitleref{int}, optional (default: 1)}] \leavevmode
Size of the data point.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{color\_list}} : \sphinxtitleref{list}, optional (default: {[}‘red’,’blue’,’purple’,’green’,’cyan’,’black’{]})}] \leavevmode
The list of color that defines color at respective time points.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{time\_points}} : \sphinxtitleref{list}, optional (default: all)}] \leavevmode
Select time points to show corresponding states. If set to be {[}{]}, use all states.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.pl.barcode\_heatmap}
\label{\detokenize{cospar.pl.barcode_heatmap:cospar-pl-barcode-heatmap}}\label{\detokenize{cospar.pl.barcode_heatmap::doc}}\index{barcode\_heatmap() (in module cospar.pl)@\spxentry{barcode\_heatmap()}\spxextra{in module cospar.pl}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.pl.barcode_heatmap:cospar.pl.barcode_heatmap}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.pl.}}\sphinxbfcode{\sphinxupquote{barcode\_heatmap}}}{\emph{\DUrole{n}{adata}}, \emph{\DUrole{n}{plot\_time\_point}}, \emph{\DUrole{n}{selected\_fates}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}, \emph{\DUrole{n}{color\_bar}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
Plot barcode heatmap among different fate clusters.

We select one time point with clonal measurement, and show the
heatmap of barcodes among selected fate clusters.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{adata}} : \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object}] \leavevmode


\item[{\sphinxstyleliteralstrong{\sphinxupquote{plot\_time\_point}} : \sphinxtitleref{str}}] \leavevmode
Time point to select the cell states.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{selected\_fates}} : \sphinxtitleref{list}, optional (default: all)}] \leavevmode
List of fate clusters to use. If set to be {[}{]}, use all.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{color\_bar}} : \sphinxtitleref{bool}, optional (default: True)}] \leavevmode
Plot color bar.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.pl.fate\_coupling\_from\_clones}
\label{\detokenize{cospar.pl.fate_coupling_from_clones:cospar-pl-fate-coupling-from-clones}}\label{\detokenize{cospar.pl.fate_coupling_from_clones::doc}}\index{fate\_coupling\_from\_clones() (in module cospar.pl)@\spxentry{fate\_coupling\_from\_clones()}\spxextra{in module cospar.pl}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.pl.fate_coupling_from_clones:cospar.pl.fate_coupling_from_clones}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.pl.}}\sphinxbfcode{\sphinxupquote{fate\_coupling\_from\_clones}}}{\emph{\DUrole{n}{adata}}, \emph{\DUrole{n}{plot\_time\_point}}, \emph{\DUrole{n}{selected\_fates}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}, \emph{\DUrole{n}{color\_bar}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{rename\_selected\_fates}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}}{}
Plot fate coupling determined by just clones.

We select one time point with clonal measurement, and show the normalized
clonal correlation among these fates.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{adata}} : \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object}] \leavevmode


\item[{\sphinxstyleliteralstrong{\sphinxupquote{plot\_time\_point}} : \sphinxtitleref{str}}] \leavevmode
Time point to select the cell states.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{selected\_fates}} : \sphinxtitleref{list}, optional (default: all)}] \leavevmode
List of fate clusters to use. If set to be {[}{]}, use all.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{color\_bar}} : \sphinxtitleref{bool}, optional (default: True)}] \leavevmode
Plot color bar.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.pl.clonal\_fate\_bias}
\label{\detokenize{cospar.pl.clonal_fate_bias:cospar-pl-clonal-fate-bias}}\label{\detokenize{cospar.pl.clonal_fate_bias::doc}}\index{clonal\_fate\_bias() (in module cospar.pl)@\spxentry{clonal\_fate\_bias()}\spxextra{in module cospar.pl}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.pl.clonal_fate_bias:cospar.pl.clonal_fate_bias}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.pl.}}\sphinxbfcode{\sphinxupquote{clonal\_fate\_bias}}}{\emph{\DUrole{n}{adata}}, \emph{\DUrole{n}{selected\_fate}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{clone\_size\_thresh}\DUrole{o}{=}\DUrole{default_value}{3}}, \emph{\DUrole{n}{N\_resampling}\DUrole{o}{=}\DUrole{default_value}{1000}}, \emph{\DUrole{n}{compute\_new}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
Plot clonal fate bias towards a cluster.

This is just \sphinxhyphen{}log(P\_value), where P\_value is for the observation
cell fraction of a clone in the targeted cluster as compared to
randomized clones, where the randomized sampling produces clones
of the same size as the targeted clone. The computed results will
be saved at path defined in adata.uns{[}‘data\_path’{]}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{adata}} : \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object}] \leavevmode


\item[{\sphinxstyleliteralstrong{\sphinxupquote{selected\_fate}} : \sphinxtitleref{str}}] \leavevmode
The targeted fate cluster, from adata.obs{[}‘state\_info’{]}.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{clone\_size\_thresh}} : \sphinxtitleref{int}, optional (default: 3)}] \leavevmode
Clones with size \textgreater{}= this threshold will be highlighted in
the plot in red.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{N\_resampling}} : \sphinxtitleref{int}, optional (default: 1000)}] \leavevmode
Number of randomized sampling for asseesing the Pvalue of a clone.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{compute\_new}} : \sphinxtitleref{bool}, optional (default: True)}] \leavevmode
Compute from stratch, regardless of existing saved files.

\end{description}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{fate\_bias} (\sphinxtitleref{np.array}) \textendash{} Computed clonal fate bias.

\item {} 
\sphinxstylestrong{sort\_idx} (\sphinxtitleref{np.array}) \textendash{} Corresponding clone id list.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}


\sphinxstylestrong{Transition map analysis} (fate bias etc.)


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{cospar.pl.fate_map:cospar.pl.fate_map}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pl.fate\_map}}}}}(adata{[}, selected\_fates, …{]})
&
Plot transition probability to given fate/ancestor clusters
\\
\hline
{\hyperref[\detokenize{cospar.pl.single_cell_transition:cospar.pl.single_cell_transition}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pl.single\_cell\_transition}}}}}(adata, …{[}, …{]})
&
Plot transition probability from given initial cell states
\\
\hline
{\hyperref[\detokenize{cospar.pl.fate_bias_intrinsic:cospar.pl.fate_bias_intrinsic}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pl.fate\_bias\_intrinsic}}}}}(adata{[}, …{]})
&
Plot the relative fate bias (predicted/expected) towards a cluster.
\\
\hline
{\hyperref[\detokenize{cospar.pl.fate_bias_from_binary_competition:cospar.pl.fate_bias_from_binary_competition}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pl.fate\_bias\_from\_binary\_competition}}}}}(adata)
&
Plot fate bias to given two fate/ancestor clusters (A, B).
\\
\hline
{\hyperref[\detokenize{cospar.pl.dynamic_trajectory_from_intrinsic_bias:cospar.pl.dynamic_trajectory_from_intrinsic_bias}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pl.dynamic\_trajectory\_from\_intrinsic\_bias}}}}}(adata)
&
Identify trajectory towards/from two given clusters.
\\
\hline
{\hyperref[\detokenize{cospar.pl.dynamic_trajectory_from_competition_bias:cospar.pl.dynamic_trajectory_from_competition_bias}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pl.dynamic\_trajectory\_from\_competition\_bias}}}}}(adata)
&
Identify trajectory towards/from two given clusters.
\\
\hline
{\hyperref[\detokenize{cospar.pl.dynamic_trajectory_via_iterative_mapping:cospar.pl.dynamic_trajectory_via_iterative_mapping}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pl.dynamic\_trajectory\_via\_iterative\_mapping}}}}}(…)
&
Infer trajectory towards/from a cluster
\\
\hline
{\hyperref[\detokenize{cospar.pl.gene_expression_dynamics:cospar.pl.gene_expression_dynamics}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pl.gene\_expression\_dynamics}}}}}(adata, …{[}, …{]})
&
Plot gene trend along inferred dynamic trajectory
\\
\hline
{\hyperref[\detokenize{cospar.pl.fate_coupling_from_Tmap:cospar.pl.fate_coupling_from_Tmap}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pl.fate\_coupling\_from\_Tmap}}}}}(adata{[}, …{]})
&
Plot fate coupling determined by Tmap.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subsubsection{cospar.pl.fate\_map}
\label{\detokenize{cospar.pl.fate_map:cospar-pl-fate-map}}\label{\detokenize{cospar.pl.fate_map::doc}}\index{fate\_map() (in module cospar.pl)@\spxentry{fate\_map()}\spxextra{in module cospar.pl}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.pl.fate_map:cospar.pl.fate_map}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.pl.}}\sphinxbfcode{\sphinxupquote{fate\_map}}}{\emph{\DUrole{n}{adata}}, \emph{\DUrole{n}{selected\_fates}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}, \emph{\DUrole{n}{used\_map\_name}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}transition\_map\textquotesingle{}}}, \emph{\DUrole{n}{map\_backwards}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{plot\_time\_points}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}, \emph{\DUrole{n}{plot\_background}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{plot\_target\_state}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{normalize}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{auto\_color\_scale}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{plot\_color\_bar}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{point\_size}\DUrole{o}{=}\DUrole{default_value}{2}}, \emph{\DUrole{n}{alpha\_target}\DUrole{o}{=}\DUrole{default_value}{0.2}}, \emph{\DUrole{n}{figure\_index}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{plot\_horizontal}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Plot transition probability to given fate/ancestor clusters

If \sphinxtitleref{map\_backwards=True}, plot transition probability of early
states to given fate clusters (fate map); else, plot transition
probability of later states from given ancestor clusters (ancestor map).
Figures are saved at defined directory at settings.figure\_path.

\sphinxtitleref{selected\_fates} could contain a nested list of clusters. If so, we
combine each sub list into a mega\sphinxhyphen{}fate cluster and combine the fate
map correspondingly.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{adata}} : \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object}] \leavevmode
Assume to contain transition maps at adata.uns.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{selected\_fates}} : \sphinxtitleref{list}}] \leavevmode
List of cluster\_ids consistent with adata.obs{[}‘state\_info’{]}

\item[{\sphinxstyleliteralstrong{\sphinxupquote{used\_map\_name}} : \sphinxtitleref{str}}] \leavevmode
The transition map to be used for plotting: \{‘transition\_map’,
‘intraclone\_transition\_map’,’weinreb\_transition\_map’,’naive\_transition\_map’,
‘OT\_transition\_map’,’HighVar\_transition\_map’\}. The actual available
map depends on adata itself, which can be accessed at adata.uns{[}‘available\_map’{]}

\item[{\sphinxstyleliteralstrong{\sphinxupquote{map\_backwards}} : \sphinxtitleref{bool}, optional (default: True)}] \leavevmode
If \sphinxtitleref{map\_backwards=True}, plot initial cell states (rows of Tmap, at t1);
else, plot later cell states (columns of Tmap, at t2)

\item[{\sphinxstyleliteralstrong{\sphinxupquote{plot\_time\_points}} : \sphinxtitleref{list}, optional (default: all)}] \leavevmode
A list of time points to further restrict the cell states to plot.
If map\_backwards=True, plot initial states that are among these time points;
else, plot later states that are among these time points.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{plot\_background}} : \sphinxtitleref{bool}, optional (default: True)}] \leavevmode
If true, plot all cell states (t1+t2) in grey color as the background.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{plot\_target\_state}} : \sphinxtitleref{bool}, optional (default: True)}] \leavevmode
If true, color the target cluster as defined in selected\_fates in cyan.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{normalize}} : \sphinxtitleref{bool}, optional (default: False)}] \leavevmode
If true, normalize the fate map towards selected clusters. This
seems to be redundant as the computation of fate\_map requires
normalization at the whole Tmap level.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{plot\_color\_bar}} : \sphinxtitleref{bool}, optional (default: True)}] \leavevmode
plot the color bar if True.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{point\_size}} : \sphinxtitleref{int}, optional (default: 2)}] \leavevmode
Size of the data point.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{alpha\_target}} : \sphinxtitleref{float}, optional (default: 0.2)}] \leavevmode
It controls the transpancy of the plotted target cell states,
for visual effect. Range: {[}0,1{]}.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{figure\_index}} : \sphinxtitleref{str}, optional (default, ‘’)}] \leavevmode
A string to label different figures when saving.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{plot\_horizontal}} : \sphinxtitleref{bool}, optional (default: False)}] \leavevmode
If true, plot the figure panels horizontally; else, vertically.

\end{description}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{Store a dictionary of results \{“fate\_map”,”relative\_bias”,”expected\_prob”\} at adata.uns{[}‘fate\_map\_output’{]}.}

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.pl.single\_cell\_transition}
\label{\detokenize{cospar.pl.single_cell_transition:cospar-pl-single-cell-transition}}\label{\detokenize{cospar.pl.single_cell_transition::doc}}\index{single\_cell\_transition() (in module cospar.pl)@\spxentry{single\_cell\_transition()}\spxextra{in module cospar.pl}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.pl.single_cell_transition:cospar.pl.single_cell_transition}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.pl.}}\sphinxbfcode{\sphinxupquote{single\_cell\_transition}}}{\emph{\DUrole{n}{adata}}, \emph{\DUrole{n}{selected\_state\_id\_list}}, \emph{\DUrole{n}{used\_map\_name}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}transition\_map\textquotesingle{}}}, \emph{\DUrole{n}{map\_backwards}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{savefig}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{point\_size}\DUrole{o}{=}\DUrole{default_value}{3}}}{}
Plot transition probability from given initial cell states

If \sphinxtitleref{map\_backwards=True}, plot future state probability starting from given initial;
else, plot probability of source states where the current cell state come from.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{adata}} : \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object}] \leavevmode
Assume to contain transition maps at adata.uns.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{selected\_state\_id\_list}} : \sphinxtitleref{list}}] \leavevmode
List of cell id’s. Like {[}0,1,2{]}.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{used\_map\_name}} : \sphinxtitleref{str}}] \leavevmode
The transition map to be used for plotting: \{‘transition\_map’,
‘intraclone\_transition\_map’,’weinreb\_transition\_map’,’naive\_transition\_map’,
‘OT\_transition\_map’,’HighVar\_transition\_map’\}. The actual available
map depends on adata itself, which can be accessed at adata.uns{[}‘available\_map’{]}

\item[{\sphinxstyleliteralstrong{\sphinxupquote{map\_backwards}} : \sphinxtitleref{bool}, optional (default: True)}] \leavevmode
If \sphinxtitleref{map\_backwards=True}, plot initial cell states (rows of Tmap, at t1);
else, plot later cell states (columns of Tmap, at t2)

\item[{\sphinxstyleliteralstrong{\sphinxupquote{point\_size}} : \sphinxtitleref{int}, optional (default: 2)}] \leavevmode
Size of the data point.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{save\_fig}} : \sphinxtitleref{bool}, optional (default: False)}] \leavevmode
If true, save figure to defined directory at settings.figure\_path

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.pl.fate\_bias\_intrinsic}
\label{\detokenize{cospar.pl.fate_bias_intrinsic:cospar-pl-fate-bias-intrinsic}}\label{\detokenize{cospar.pl.fate_bias_intrinsic::doc}}\index{fate\_bias\_intrinsic() (in module cospar.pl)@\spxentry{fate\_bias\_intrinsic()}\spxextra{in module cospar.pl}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.pl.fate_bias_intrinsic:cospar.pl.fate_bias_intrinsic}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.pl.}}\sphinxbfcode{\sphinxupquote{fate\_bias\_intrinsic}}}{\emph{\DUrole{n}{adata}}, \emph{\DUrole{n}{selected\_fates}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}, \emph{\DUrole{n}{used\_map\_name}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}transition\_map\textquotesingle{}}}, \emph{\DUrole{n}{map\_backwards}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{plot\_time\_points}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}, \emph{\DUrole{n}{point\_size}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{plot\_background}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{plot\_target\_state}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{plot\_color\_bar}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{plot\_horizontal}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{alpha\_target}\DUrole{o}{=}\DUrole{default_value}{0.2}}}{}
Plot the relative fate bias (predicted/expected) towards a cluster.

Compared with {\hyperref[\detokenize{cospar.pl.fate_map:cospar.pl.fate_map}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fate\_map()}}}}}, we normalized the fate probability by the
relative proportion of the targeted cluster, as the plotted relative fate bias.

If \sphinxtitleref{map\_backwards=True}, plot fate bias of early
states to given fate clusters; else, plot fate bias of later states
from given ancestor clusters. Figures are saved at defined
directory at settings.figure\_path.

\sphinxtitleref{selected\_fates} could contain a nested list of clusters. If so, we
combine each sub list into a mega\sphinxhyphen{}fate cluster and combine the fate
map correspondingly.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{adata}} : \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object}] \leavevmode
Assume to contain transition maps at adata.uns.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{selected\_fates}} : \sphinxtitleref{list}}] \leavevmode
List of cluster\_ids consistent with adata.obs{[}‘state\_info’{]}

\item[{\sphinxstyleliteralstrong{\sphinxupquote{used\_map\_name}} : \sphinxtitleref{str}}] \leavevmode
The transition map to be used for plotting: \{‘transition\_map’,
‘intraclone\_transition\_map’,’weinreb\_transition\_map’,’naive\_transition\_map’,
‘OT\_transition\_map’,’HighVar\_transition\_map’\}. The actual available
map depends on adata itself, which can be accessed at adata.uns{[}‘available\_map’{]}

\item[{\sphinxstyleliteralstrong{\sphinxupquote{map\_backwards}} : \sphinxtitleref{bool}, optional (default: True)}] \leavevmode
If \sphinxtitleref{map\_backwards=True}, plot initial cell states (rows of Tmap, at t1);
else, plot later cell states (columns of Tmap, at t2)

\item[{\sphinxstyleliteralstrong{\sphinxupquote{plot\_time\_points}} : \sphinxtitleref{list}, optional (default: all)}] \leavevmode
A list of time points to further restrict the cell states to plot.
If map\_backwards=True, plot initial states that are among these time points;
else, plot later states that are among these time points.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{plot\_target\_state}} : \sphinxtitleref{bool}, optional (default: True)}] \leavevmode
If true, color the target clusters as defined in selected\_fates in cyan.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{plot\_background}} : \sphinxtitleref{bool}, optional (default: True)}] \leavevmode
If true, plot all cell states (t1+t2) in grey color as the background.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{plot\_color\_bar}} : \sphinxtitleref{bool}, optional (default: True)}] \leavevmode
plot the color bar if True.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{point\_size}} : \sphinxtitleref{int}, optional (default: 2)}] \leavevmode
Size of the data point.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{plot\_horizontal}} : \sphinxtitleref{bool}, optional (default: True)}] \leavevmode
Arrange the subplots horizontally.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{alpha\_target}} : \sphinxtitleref{float}, optional (default: 0.2)}] \leavevmode
It controls the transpancy of the plotted target cell states,
for visual effect. Range: {[}0,1{]}.

\end{description}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{Store a dictionary of results \{“fate\_map”,”relative\_bias”,”expected\_prob”\} at adata.uns{[}‘fate\_map\_output’{]}.}

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.pl.fate\_bias\_from\_binary\_competition}
\label{\detokenize{cospar.pl.fate_bias_from_binary_competition:cospar-pl-fate-bias-from-binary-competition}}\label{\detokenize{cospar.pl.fate_bias_from_binary_competition::doc}}\index{fate\_bias\_from\_binary\_competition() (in module cospar.pl)@\spxentry{fate\_bias\_from\_binary\_competition()}\spxextra{in module cospar.pl}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.pl.fate_bias_from_binary_competition:cospar.pl.fate_bias_from_binary_competition}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.pl.}}\sphinxbfcode{\sphinxupquote{fate\_bias\_from\_binary\_competition}}}{\emph{\DUrole{n}{adata}}, \emph{\DUrole{n}{selected\_fates}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}, \emph{\DUrole{n}{used\_map\_name}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}transition\_map\textquotesingle{}}}, \emph{\DUrole{n}{map\_backwards}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{sum\_fate\_prob\_thresh}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{plot\_time\_points}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}, \emph{\DUrole{n}{point\_size}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{plot\_target\_state}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{plot\_color\_bar}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{alpha\_target}\DUrole{o}{=}\DUrole{default_value}{0.2}}}{}
Plot fate bias to given two fate/ancestor clusters (A, B).

If \sphinxtitleref{map\_backwards=True}, plot fate bias of early
states to given fate clusters; else, plot fate bias of later states
from given ancestor clusters. Figures are saved at defined
directory at settings.figure\_path.

\sphinxtitleref{selected\_fates} could contain a nested list of clusters. If so, we
combine each sub list into a mega\sphinxhyphen{}fate cluster and combine the fate
map correspondingly.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{adata}} : \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object}] \leavevmode
Assume to contain transition maps at adata.uns.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{selected\_fates}} : \sphinxtitleref{list}}] \leavevmode
List of cluster\_ids consistent with adata.obs{[}‘state\_info’{]}

\item[{\sphinxstyleliteralstrong{\sphinxupquote{used\_map\_name}} : \sphinxtitleref{str}}] \leavevmode
The transition map to be used for plotting: \{‘transition\_map’,
‘intraclone\_transition\_map’,’weinreb\_transition\_map’,’naive\_transition\_map’,
‘OT\_transition\_map’,’HighVar\_transition\_map’\}. The actual available
map depends on adata itself, which can be accessed at adata.uns{[}‘available\_map’{]}

\item[{\sphinxstyleliteralstrong{\sphinxupquote{map\_backwards}} : \sphinxtitleref{bool}, optional (default: True)}] \leavevmode
If \sphinxtitleref{map\_backwards=True}, plot initial cell states (rows of Tmap, at t1);
else, plot later cell states (columns of Tmap, at t2)

\item[{\sphinxstyleliteralstrong{\sphinxupquote{sum\_fate\_prob\_thresh}} : \sphinxtitleref{float}, optional (default: 0)}] \leavevmode
The fate bias of a state is plotted only when it has a cumulative fate
probability to the combined cluster (A+B) larger than this threshold,
i.e., P(i\sphinxhyphen{}\textgreater{}A)+P(i+\textgreater{}B) \textgreater{}  sum\_fate\_prob\_thresh.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{plot\_time\_points}} : \sphinxtitleref{list}, optional (default: all)}] \leavevmode
A list of time points to further restrict the cell states to plot.
If map\_backwards=True, plot initial states that are among these time points;
else, plot later states that are among these time points.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{plot\_target\_state}} : \sphinxtitleref{bool}, optional (default: True)}] \leavevmode
If true, color the target clusters as defined in selected\_fates in cyan.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{plot\_color\_bar}} : \sphinxtitleref{bool}, optional (default: True)}] \leavevmode
plot the color bar if True.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{point\_size}} : \sphinxtitleref{int}, optional (default: 2)}] \leavevmode
Size of the data point.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{alpha\_target}} : \sphinxtitleref{float}, optional (default: 0.2)}] \leavevmode
It controls the transpancy of the plotted target cell states,
for visual effect. Range: {[}0,1{]}.

\end{description}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{The results are stored at adata.uns{[}‘relative\_fate\_bias’{]}}

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.pl.dynamic\_trajectory\_from\_intrinsic\_bias}
\label{\detokenize{cospar.pl.dynamic_trajectory_from_intrinsic_bias:cospar-pl-dynamic-trajectory-from-intrinsic-bias}}\label{\detokenize{cospar.pl.dynamic_trajectory_from_intrinsic_bias::doc}}\index{dynamic\_trajectory\_from\_intrinsic\_bias() (in module cospar.pl)@\spxentry{dynamic\_trajectory\_from\_intrinsic\_bias()}\spxextra{in module cospar.pl}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.pl.dynamic_trajectory_from_intrinsic_bias:cospar.pl.dynamic_trajectory_from_intrinsic_bias}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.pl.}}\sphinxbfcode{\sphinxupquote{dynamic\_trajectory\_from\_intrinsic\_bias}}}{\emph{\DUrole{n}{adata}}, \emph{\DUrole{n}{selected\_fates}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}, \emph{\DUrole{n}{used\_map\_name}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}transition\_map\textquotesingle{}}}, \emph{\DUrole{n}{map\_backwards}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{plot\_time\_points}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}, \emph{\DUrole{n}{bias\_threshold\_A}\DUrole{o}{=}\DUrole{default_value}{0.5}}, \emph{\DUrole{n}{bias\_threshold\_B}\DUrole{o}{=}\DUrole{default_value}{0.5}}, \emph{\DUrole{n}{plot\_ancestor}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{point\_size}\DUrole{o}{=}\DUrole{default_value}{2}}, \emph{\DUrole{n}{savefig}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{plot\_target\_state}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{alpha\_target}\DUrole{o}{=}\DUrole{default_value}{0.2}}, \emph{\DUrole{n}{avoid\_target\_states}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Identify trajectory towards/from two given clusters.

If \sphinxtitleref{map\_backwards=True}, use the fate probability towards given clusters (A,B)
to define the ancestor population for A and B. The ancestor population + target fates
are the dynamic trajectory.

Fate bias at each state is a \sphinxtitleref{vector}: (\sphinxtitleref{relative\_bias\_A,relative\_bias\_B}).
For a given cluster, is defined by comparing predicted fate probability with
expected one, same as {\hyperref[\detokenize{cospar.pl.fate_map:cospar.pl.fate_map}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fate\_map()}}}}}. It sales from {[}0,1{]}, with 0.5 as the
neutral prediction that agrees with null hypothesis. Selected ancestors satisfy:
\begin{itemize}
\item {} 
For A: \sphinxtitleref{relative\_bias\_A} \textgreater{} \sphinxtitleref{bias\_threshold\_A}

\item {} 
For B: \sphinxtitleref{relative\_bias\_B} \textgreater{} \sphinxtitleref{bias\_threshold\_B}

\end{itemize}

If \sphinxtitleref{map\_backwards=False}, use the probability from given clusters (A,B)
to define the fate population, and perform DGE analysis. This is not useful.

\sphinxtitleref{selected\_fates} could contain a nested list of clusters. If so, we
combine each sub list into a mega\sphinxhyphen{}fate cluster and combine the fate
map correspondingly.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{adata}} : \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object}] \leavevmode
Assume to contain transition maps at adata.uns.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{selected\_fates}} : \sphinxtitleref{list}}] \leavevmode
List of cluster\_ids consistent with adata.obs{[}‘state\_info’{]}

\item[{\sphinxstyleliteralstrong{\sphinxupquote{used\_map\_name}} : \sphinxtitleref{str}}] \leavevmode
The transition map to be used for plotting: \{‘transition\_map’,
‘intraclone\_transition\_map’,’weinreb\_transition\_map’,’naive\_transition\_map’,
‘OT\_transition\_map’,’HighVar\_transition\_map’\}. The actual available
map depends on adata itself, which can be accessed at adata.uns{[}‘available\_map’{]}

\item[{\sphinxstyleliteralstrong{\sphinxupquote{map\_backwards}} : \sphinxtitleref{bool}, optional (default: True)}] \leavevmode
If \sphinxtitleref{map\_backwards=True}, plot initial cell states (rows of Tmap, at t1);
else, plot later cell states (columns of Tmap, at t2)

\item[{\sphinxstyleliteralstrong{\sphinxupquote{plot\_time\_points}} : \sphinxtitleref{list}, optional (default: all)}] \leavevmode
A list of time points to further restrict the cell states to plot.
If map\_backwards=True, plot initial states that are among these time points;
else, plot later states that are among these time points.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{bias\_threshold\_A}} : \sphinxtitleref{float}, optional (default: 0.5)}] \leavevmode
Relative fate bias threshold to select ancestor population for cluster A.
The 0.5 is the neural bias point. Range: {[}0,1{]}.
Closer to 1 means more stringent selection.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{bias\_threshold\_B}} : \sphinxtitleref{float}, optional (default: 0.5)}] \leavevmode
Relative fate bias threshold to select ancestor population for cluster B.
Closer to 1 means more stringent selection.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{savefig}} : \sphinxtitleref{bool}, optional (default: False)}] \leavevmode
Save all plots.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{point\_size}} : \sphinxtitleref{int}, optional (default: 2)}] \leavevmode
Size of the data point.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{avoid\_target\_states}} : \sphinxtitleref{bool}, optional (default: False)}] \leavevmode
If true, avoid selecting cells at the target cluster (A, or B) as
ancestor popolation.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{plot\_target\_state}} : \sphinxtitleref{bool}, optional (default: True)}] \leavevmode
Plot the target states in the state manifold.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{alpha\_target}} : \sphinxtitleref{float}, optional (default: 0.2)}] \leavevmode
Transparency parameter for plotting.

\end{description}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstyleemphasis{Store the inferred ancestor states in adata.uns{[}‘Cell\_group\_A’{]} and adata.uns{[}‘Cell\_group\_B’{]}}

\item {} 
\sphinxstyleemphasis{Combine ancestor states and target states into adata.uns{[}‘dynamic\_trajectory’{]} for each fate.}

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.pl.dynamic\_trajectory\_from\_competition\_bias}
\label{\detokenize{cospar.pl.dynamic_trajectory_from_competition_bias:cospar-pl-dynamic-trajectory-from-competition-bias}}\label{\detokenize{cospar.pl.dynamic_trajectory_from_competition_bias::doc}}\index{dynamic\_trajectory\_from\_competition\_bias() (in module cospar.pl)@\spxentry{dynamic\_trajectory\_from\_competition\_bias()}\spxextra{in module cospar.pl}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.pl.dynamic_trajectory_from_competition_bias:cospar.pl.dynamic_trajectory_from_competition_bias}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.pl.}}\sphinxbfcode{\sphinxupquote{dynamic\_trajectory\_from\_competition\_bias}}}{\emph{\DUrole{n}{adata}}, \emph{\DUrole{n}{selected\_fates}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}, \emph{\DUrole{n}{used\_map\_name}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}transition\_map\textquotesingle{}}}, \emph{\DUrole{n}{map\_backwards}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{plot\_time\_points}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}, \emph{\DUrole{n}{bias\_threshold}\DUrole{o}{=}\DUrole{default_value}{0.1}}, \emph{\DUrole{n}{sum\_fate\_prob\_thresh}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{avoid\_target\_states}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{plot\_ancestor}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{point\_size}\DUrole{o}{=}\DUrole{default_value}{2}}, \emph{\DUrole{n}{savefig}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{plot\_target\_state}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{alpha\_target}\DUrole{o}{=}\DUrole{default_value}{0.2}}}{}
Identify trajectory towards/from two given clusters.

If \sphinxtitleref{map\_backwards=True}, use the fate probability towards given clusters (A,B)
to define the ancestor population for A and B. The ancestor population + target fates
are the dynamic trajectory.

Fate bias is a \sphinxtitleref{scalar} between (0,1) at each state, defined as competition between
two fate clusters, as in {\hyperref[\detokenize{cospar.pl.fate_bias_from_binary_competition:cospar.pl.fate_bias_from_binary_competition}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fate\_bias\_from\_binary\_competition()}}}}}. Selected ancestor population satisfies:
\begin{itemize}
\item {} 
Prob(A)+Prob(B)\textgreater{}sum\_fate\_prob\_thresh;

\item {} 
for A: Bias\textgreater{}0.5+bias\_threshold

\item {} 
for B: bias\textless{}0.5+bias\_threshold

\end{itemize}

If \sphinxtitleref{map\_backwards=False}, use the probability from given clusters (A,B)
to define the fate population, and perform DGE analysis. This is not useful.

\sphinxtitleref{selected\_fates} could contain a nested list of clusters. If so, we
combine each sub list into a mega\sphinxhyphen{}fate cluster and combine the fate
map correspondingly.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{adata}} : \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object}] \leavevmode
Assume to contain transition maps at adata.uns.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{selected\_fates}} : \sphinxtitleref{list}}] \leavevmode
List of cluster\_ids consistent with adata.obs{[}‘state\_info’{]}

\item[{\sphinxstyleliteralstrong{\sphinxupquote{used\_map\_name}} : \sphinxtitleref{str}}] \leavevmode
The transition map to be used for plotting: \{‘transition\_map’,
‘intraclone\_transition\_map’,’weinreb\_transition\_map’,’naive\_transition\_map’,
‘OT\_transition\_map’,’HighVar\_transition\_map’\}. The actual available
map depends on adata itself, which can be accessed at adata.uns{[}‘available\_map’{]}

\item[{\sphinxstyleliteralstrong{\sphinxupquote{map\_backwards}} : \sphinxtitleref{bool}, optional (default: True)}] \leavevmode
If \sphinxtitleref{map\_backwards=True}, plot initial cell states (rows of Tmap, at t1);
else, plot later cell states (columns of Tmap, at t2)

\item[{\sphinxstyleliteralstrong{\sphinxupquote{plot\_time\_points}} : \sphinxtitleref{list}, optional (default: all)}] \leavevmode
A list of time points to further restrict the cell states to plot.
If map\_backwards=True, plot initial states that are among these time points;
else, plot later states that are among these time points.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{bias\_threshold}} : \sphinxtitleref{float}, optional (default: 0), range: (0,0.5)}] \leavevmode
Threshold for ancestor population selection.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{sum\_fate\_prob\_thresh}} : \sphinxtitleref{float}, optional (default: 0), range: (0,1)}] \leavevmode
Minimum cumulative probability towards joint cluster (A,B)
to qualify for ancestor selection.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{savefig}} : \sphinxtitleref{bool}, optional (default: False)}] \leavevmode
Save all plots.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{point\_size}} : \sphinxtitleref{int}, optional (default: 2)}] \leavevmode
Size of the data point.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{avoid\_target\_states}} : \sphinxtitleref{bool}, optional (default: False)}] \leavevmode
If true, avoid selecting cells at the target cluster (A, or B) as
ancestor popolation.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{plot\_target\_state}} : \sphinxtitleref{bool}, optional (default: True)}] \leavevmode
Plot the target states in the state manifold.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{alpha\_target}} : \sphinxtitleref{float}, optional (default: 0.2)}] \leavevmode
Transparency parameter for plotting.

\end{description}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstyleemphasis{Store the inferred ancestor states in adata.uns{[}‘Cell\_group\_A’{]} and adata.uns{[}‘Cell\_group\_B’{]}}

\item {} 
\sphinxstyleemphasis{Combine ancestor states and target states into adata.uns{[}‘dynamic\_trajectory’{]} for each fate.}

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.pl.dynamic\_trajectory\_via\_iterative\_mapping}
\label{\detokenize{cospar.pl.dynamic_trajectory_via_iterative_mapping:cospar-pl-dynamic-trajectory-via-iterative-mapping}}\label{\detokenize{cospar.pl.dynamic_trajectory_via_iterative_mapping::doc}}\index{dynamic\_trajectory\_via\_iterative\_mapping() (in module cospar.pl)@\spxentry{dynamic\_trajectory\_via\_iterative\_mapping()}\spxextra{in module cospar.pl}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.pl.dynamic_trajectory_via_iterative_mapping:cospar.pl.dynamic_trajectory_via_iterative_mapping}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.pl.}}\sphinxbfcode{\sphinxupquote{dynamic\_trajectory\_via\_iterative\_mapping}}}{\emph{\DUrole{n}{adata}}, \emph{\DUrole{n}{selected\_fate}}, \emph{\DUrole{n}{used\_map\_name}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}transition\_map\textquotesingle{}}}, \emph{\DUrole{n}{map\_backwards}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{map\_threshold}\DUrole{o}{=}\DUrole{default_value}{0.1}}, \emph{\DUrole{n}{plot\_separately}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{apply\_time\_constaint}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{point\_size}\DUrole{o}{=}\DUrole{default_value}{2}}, \emph{\DUrole{n}{plot\_color\_bar}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
Infer trajectory towards/from a cluster

It only works for Tmap from multi\sphinxhyphen{}time clones, since we are
iteratively map states forward/backward in time.

If map\_backwards=True, infer the trajectory backwards in time.
Using inferred transitino map, the inference is applied recursively.
Start with the cell states for the selected fate, then use selected
map to infer the immediate ancestor states. Then, using these putative
ancestor state as the input, find the immediate ancestors for these
input states. This goes on until all time points are exhausted.

If map\_backwards=False, infer the trajectory forward in time.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{adata}} : \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object}] \leavevmode
Assume to contain transition maps at adata.uns.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{selected\_fate}} : \sphinxtitleref{str}, or \sphinxtitleref{list}}] \leavevmode
targeted cluster of the trajectory, as consistent with adata.obs{[}‘state\_info’{]}
When it is a list, the listed clusters are combined into a single fate cluster.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{used\_map\_name}} : \sphinxtitleref{str}}] \leavevmode
The transition map to be used for plotting: \{‘transition\_map’,
‘intraclone\_transition\_map’,’weinreb\_transition\_map’,’naive\_transition\_map’,
‘OT\_transition\_map’,’HighVar\_transition\_map’\}. The actual available
map depends on adata itself, which can be accessed at adata.uns{[}‘available\_map’{]}

\item[{\sphinxstyleliteralstrong{\sphinxupquote{map\_backwards}} : \sphinxtitleref{bool}, optional (default: True)}] \leavevmode
If \sphinxtitleref{map\_backwards=True}, plot initial cell states (rows of Tmap, at t1);
else, plot later cell states (columns of Tmap, at t2)

\item[{\sphinxstyleliteralstrong{\sphinxupquote{plot\_separately}} : \sphinxtitleref{bool}, optional (default: False)}] \leavevmode
Plot the inferred trajecotry separately for each time point.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{map\_threshold}} : \sphinxtitleref{float}, optional (default: 0.1)}] \leavevmode
Relative threshold in the range {[}0,1{]} for truncating the fate map
towards the cluster. Only states above the threshold will be selected.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{apply\_time\_constaint}} : \sphinxtitleref{bool}, optional (default: False)}] \leavevmode
If true, in each iteration of finding the immediate ancestor states, select cell states
at the corresponding time point.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{point\_size}} : \sphinxtitleref{int}, optional (default: 2)}] \leavevmode
Size of the data point.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{plot\_color\_bar}} : \sphinxtitleref{bool}, optional (default: True)}] \leavevmode


\end{description}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{Results are stored at adata.uns{[}‘dynamic\_trajectory’{]}}

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.pl.gene\_expression\_dynamics}
\label{\detokenize{cospar.pl.gene_expression_dynamics:cospar-pl-gene-expression-dynamics}}\label{\detokenize{cospar.pl.gene_expression_dynamics::doc}}\index{gene\_expression\_dynamics() (in module cospar.pl)@\spxentry{gene\_expression\_dynamics()}\spxextra{in module cospar.pl}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.pl.gene_expression_dynamics:cospar.pl.gene_expression_dynamics}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.pl.}}\sphinxbfcode{\sphinxupquote{gene\_expression\_dynamics}}}{\emph{\DUrole{n}{adata}}, \emph{\DUrole{n}{selected\_fate}}, \emph{\DUrole{n}{gene\_name\_list}}, \emph{\DUrole{n}{traj\_threshold}\DUrole{o}{=}\DUrole{default_value}{0.1}}, \emph{\DUrole{n}{map\_backwards}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{invert\_PseudoTime}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{include\_target\_states}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{compute\_new}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{fig\_width}\DUrole{o}{=}\DUrole{default_value}{3.5}}, \emph{\DUrole{n}{gene\_exp\_percentile}\DUrole{o}{=}\DUrole{default_value}{99}}, \emph{\DUrole{n}{n\_neighbors}\DUrole{o}{=}\DUrole{default_value}{8}}, \emph{\DUrole{n}{plot\_raw\_data}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{point\_size}\DUrole{o}{=}\DUrole{default_value}{2}}, \emph{\DUrole{n}{stat\_smooth\_method}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}loess\textquotesingle{}}}}{}
Plot gene trend along inferred dynamic trajectory

We assume that the dynamic trajecotry at given specification is already
computed via \sphinxcode{\sphinxupquote{dynamic\_trajectory()}}. Using the states belong to the
trajectory, it computes the pseudotime for these states, plot gene trend
along the pseudo time. This needs to be updated from existing packages.

Given the states, we first construct KNN graph, compute spectral embedding,
take the first component as the pseudotime. For the gene trend, we provide
gene expression value of each cell, re\sphinxhyphen{}weighted by its probability belonging
to this trajectory, and also rescaled by the global background. Finally, we
fit a curve to the data points.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{adata}} : \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object}] \leavevmode
Assume to contain transition maps at adata.uns.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{selected\_fate}} : \sphinxtitleref{str}, or \sphinxtitleref{list}}] \leavevmode
targeted cluster of the trajectory, as consistent with adata.obs{[}‘state\_info’{]}
When it is a list, the listed clusters are combined into a single fate cluster.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{gene\_name\_list}} : \sphinxtitleref{list}}] \leavevmode
List of genes to plot on the dynamic trajectory.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{traj\_threshold}} : \sphinxtitleref{float}, optional (default: 0.1), range: (0,1)}] \leavevmode
Relative threshold, used to thresholding the inferred dynamic trajecotry to select states.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{map\_backwards}} : \sphinxtitleref{bool}, optional (default: True)}] \leavevmode
If \sphinxtitleref{map\_backwards=True}, plot initial cell states (rows of Tmap, at t1);
else, plot later cell states (columns of Tmap, at t2)

\item[{\sphinxstyleliteralstrong{\sphinxupquote{invert\_PseudoTime}} : \sphinxtitleref{bool}, optional (default: False)}] \leavevmode
If true, invert the pseudotime: 1\sphinxhyphen{}pseuotime. This is useful when the direction
of pseudo time does not agree with intuition.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{include\_target\_states}} : \sphinxtitleref{bool}, optional (default: False)}] \leavevmode
If true, include the target states to the dynamic trajectory.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{compute\_new}} : \sphinxtitleref{bool}, optional (default: True)}] \leavevmode
If true, compute everyting from stratch (as we save computed pseudotime)

\item[{\sphinxstyleliteralstrong{\sphinxupquote{fig\_width}} : \sphinxtitleref{float}, optional (default: 3.5)}] \leavevmode
Figure width.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{gene\_exp\_percentile}} : \sphinxtitleref{int}, optional (default: 99)}] \leavevmode
Plot gene expression below this percentile.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{n\_neighbors}} : \sphinxtitleref{int}, optional (default: 8)}] \leavevmode
Number of nearest neighbors for constructing KNN graph.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{plot\_raw\_data}} : \sphinxtitleref{bool}, optional (default: False)}] \leavevmode
Plot the raw gene expression values of each cell along the pseudotime.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{point\_size}} : \sphinxtitleref{int}, optional (default: 2)}] \leavevmode
Size of the data point.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{stat\_smooth\_method}} : \sphinxtitleref{str}, optional (default: ‘loess’)}] \leavevmode
Smooth method used in the ggplot. Current availabel choices are:
‘auto’ (Use loess if (n\textless{}1000), glm otherwise),
‘lm’ (Linear Model),
‘wls’ (Linear Model),
‘rlm’ (Robust Linear Model),
‘glm’ (Generalized linear Model),
‘gls’ (Generalized Least Squares),
‘lowess’ (Locally Weighted Regression (simple)),
‘loess’ (Locally Weighted Regression)
‘mavg’ (Moving Average)
‘gpr’ (Gaussian Process Regressor)\}

\end{description}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{An adata object with only selected cell states. It can be used for dynamic inference with other packages.}

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.pl.fate\_coupling\_from\_Tmap}
\label{\detokenize{cospar.pl.fate_coupling_from_Tmap:cospar-pl-fate-coupling-from-tmap}}\label{\detokenize{cospar.pl.fate_coupling_from_Tmap::doc}}\index{fate\_coupling\_from\_Tmap() (in module cospar.pl)@\spxentry{fate\_coupling\_from\_Tmap()}\spxextra{in module cospar.pl}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.pl.fate_coupling_from_Tmap:cospar.pl.fate_coupling_from_Tmap}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.pl.}}\sphinxbfcode{\sphinxupquote{fate\_coupling\_from\_Tmap}}}{\emph{\DUrole{n}{adata}}, \emph{\DUrole{n}{selected\_fates}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}, \emph{\DUrole{n}{used\_map\_name}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}transition\_map\textquotesingle{}}}, \emph{\DUrole{n}{plot\_time\_points}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}, \emph{\DUrole{n}{normalize\_fate\_map}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{color\_bar}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{coupling\_normalization}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}SW\textquotesingle{}}}, \emph{\DUrole{n}{rename\_selected\_fates}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}}{}
Plot fate coupling determined by Tmap.

We use the fate map of cell states at t1 to compute the fate coupling.

\sphinxtitleref{selected\_fates} could contain a nested list of clusters. If so, we
combine each sub list into a mega\sphinxhyphen{}fate cluster and combine the fate
map correspondingly.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{adata}} : \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object}] \leavevmode
Assume to contain transition maps at adata.uns.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{selected\_fates}} : \sphinxtitleref{list}}] \leavevmode
List of cluster\_ids consistent with adata.obs{[}‘state\_info’{]}

\item[{\sphinxstyleliteralstrong{\sphinxupquote{used\_map\_name}} : \sphinxtitleref{str}}] \leavevmode
The transition map to be used for plotting: \{‘transition\_map’,
‘intraclone\_transition\_map’,’weinreb\_transition\_map’,’naive\_transition\_map’,
‘OT\_transition\_map’,’HighVar\_transition\_map’\}. The actual available
map depends on adata itself, which can be accessed at adata.uns{[}‘available\_map’{]}

\item[{\sphinxstyleliteralstrong{\sphinxupquote{plot\_time\_points}} : \sphinxtitleref{list}, optional (default: all)}] \leavevmode
A list of time points to further restrict the cell states to plot.
If map\_backwards=True, plot initial states that are among these time points;
else, plot later states that are among these time points.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{normalize\_fate\_map}} : \sphinxtitleref{bool}, optional (default: False)}] \leavevmode
If true, normalize fate map before computing the fate coupling.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{color\_bar}} : \sphinxtitleref{bool}, optional (default: True)}] \leavevmode
Plot the color bar.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{coupling\_normalization}} : \sphinxtitleref{str}, optional (default: ‘SW’)}] \leavevmode
Method to normalize the coupling matrix: \{‘SW’,’Weinreb’\}

\item[{\sphinxstyleliteralstrong{\sphinxupquote{rename\_selected\_fates}} : \sphinxtitleref{list}, optional (default: {[}{]})}] \leavevmode
Provide new names in substitution of names in selected\_fates.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstylestrong{Differential gene expression analysis}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{cospar.pl.differential_genes:cospar.pl.differential_genes}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pl.differential\_genes}}}}}(adata{[}, plot\_groups, …{]})
&
Perform differential gene expression analysis and plot top DGE genes.
\\
\hline
{\hyperref[\detokenize{cospar.pl.differential_genes_for_given_fates:cospar.pl.differential_genes_for_given_fates}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pl.differential\_genes\_for\_given\_fates}}}}}(adata)
&
Find and plot DGE genes between different clusters
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subsubsection{cospar.pl.differential\_genes}
\label{\detokenize{cospar.pl.differential_genes:cospar-pl-differential-genes}}\label{\detokenize{cospar.pl.differential_genes::doc}}\index{differential\_genes() (in module cospar.pl)@\spxentry{differential\_genes()}\spxextra{in module cospar.pl}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.pl.differential_genes:cospar.pl.differential_genes}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.pl.}}\sphinxbfcode{\sphinxupquote{differential\_genes}}}{\emph{\DUrole{n}{adata}}, \emph{\DUrole{n}{plot\_groups}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{gene\_N}\DUrole{o}{=}\DUrole{default_value}{100}}, \emph{\DUrole{n}{plot\_gene\_N}\DUrole{o}{=}\DUrole{default_value}{5}}, \emph{\DUrole{n}{savefig}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{point\_size}\DUrole{o}{=}\DUrole{default_value}{1}}}{}
Perform differential gene expression analysis and plot top DGE genes.

We use Wilcoxon rank\sphinxhyphen{}sum test to calculate P values, followed by
Benjamini\sphinxhyphen{}Hochberg correction.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{adata}} : \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object}] \leavevmode
Need to contain gene expression matrix, and DGE cell groups A, B.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{plot\_groups}} : \sphinxtitleref{bool}, optional (default: True)}] \leavevmode
If true, plot the selected ancestor states for A, B

\item[{\sphinxstyleliteralstrong{\sphinxupquote{gene\_N}} : \sphinxtitleref{int}, optional (default: 100)}] \leavevmode
Number of top differentially expressed genes to selected.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{plot\_gene\_N}} : \sphinxtitleref{int}, optional (default: 5)}] \leavevmode
Number of top DGE genes to plot

\item[{\sphinxstyleliteralstrong{\sphinxupquote{savefig}} : \sphinxtitleref{bool}, optional (default: False)}] \leavevmode
Save all plots.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{point\_size}} : \sphinxtitleref{int}, optional (default: 2)}] \leavevmode
Size of the data point.

\end{description}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{diff\_gene\_A} (\sphinxtitleref{pd.DataFrame}) \textendash{} Genes differentially expressed in cell state group A, ranked
by the ratio of mean expressions between
the two groups, with the top being more differentially expressed.

\item {} 
\sphinxstylestrong{diff\_gene\_B} (\sphinxtitleref{pd.DataFrame}) \textendash{} Genes differentially expressed in cell state group B, ranked
by the ratio of mean expressions between
the two groups, with the top being more differentially expressed.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.pl.differential\_genes\_for\_given\_fates}
\label{\detokenize{cospar.pl.differential_genes_for_given_fates:cospar-pl-differential-genes-for-given-fates}}\label{\detokenize{cospar.pl.differential_genes_for_given_fates::doc}}\index{differential\_genes\_for\_given\_fates() (in module cospar.pl)@\spxentry{differential\_genes\_for\_given\_fates()}\spxextra{in module cospar.pl}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.pl.differential_genes_for_given_fates:cospar.pl.differential_genes_for_given_fates}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.pl.}}\sphinxbfcode{\sphinxupquote{differential\_genes\_for\_given\_fates}}}{\emph{\DUrole{n}{adata}}, \emph{\DUrole{n}{selected\_fates}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}, \emph{\DUrole{n}{plot\_time\_points}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}, \emph{\DUrole{n}{plot\_groups}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{gene\_N}\DUrole{o}{=}\DUrole{default_value}{100}}, \emph{\DUrole{n}{plot\_gene\_N}\DUrole{o}{=}\DUrole{default_value}{5}}, \emph{\DUrole{n}{savefig}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{point\_size}\DUrole{o}{=}\DUrole{default_value}{1}}}{}
Find and plot DGE genes between different clusters

\sphinxtitleref{selected\_fates} could contain a nested list of clusters. If so, we
combine each sub list into a mega\sphinxhyphen{}fate cluster and combine the fate
map correspondingly.

\sphinxtitleref{selected\_fates} could contain a nested list of clusters. If so, we
combine each sub list into a mega\sphinxhyphen{}fate cluster and combine the fate
map correspondingly.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{adata}} : \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object}] \leavevmode


\item[{\sphinxstyleliteralstrong{\sphinxupquote{selected\_fates}} : \sphinxtitleref{list}}] \leavevmode
List of cluster\_ids consistent with adata.obs{[}‘state\_info’{]}

\item[{\sphinxstyleliteralstrong{\sphinxupquote{plot\_time\_points}} : \sphinxtitleref{list}, optional (default: all)}] \leavevmode
A list of time points to further restrict the cell states to plot.
If map\_backwards=True, plot initial states that are among these time points;
else, plot later states that are among these time points.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{plot\_groups}} : \sphinxtitleref{bool}, optional (default: True)}] \leavevmode
If true, plot the selected ancestor states for A, B

\item[{\sphinxstyleliteralstrong{\sphinxupquote{gene\_N}} : \sphinxtitleref{int}, optional (default: 100)}] \leavevmode
Number of top differentially expressed genes to selected.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{plot\_gene\_N}} : \sphinxtitleref{int}, optional (default: 5)}] \leavevmode
Number of top DGE genes to plot

\item[{\sphinxstyleliteralstrong{\sphinxupquote{savefig}} : \sphinxtitleref{bool}, optional (default: False)}] \leavevmode
Save all plots.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{point\_size}} : \sphinxtitleref{int}, optional (default: 2)}] \leavevmode
Size of the data point.

\end{description}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{diff\_gene\_A} (\sphinxtitleref{pd.DataFrame}) \textendash{} Genes differentially expressed in cell state group A, ranked
by the ratio of mean expressions between
the two groups, with the top being more differentially expressed.

\item {} 
\sphinxstylestrong{diff\_gene\_B} (\sphinxtitleref{pd.DataFrame}) \textendash{} Genes differentially expressed in cell state group B, ranked
by the ratio of mean expressions between
the two groups, with the top being more differentially expressed.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}


\sphinxstylestrong{General}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{cospar.pl.embedding:cospar.pl.embedding}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pl.embedding}}}}}(adata{[}, basis, color{]})
&
Scatter plot for user specified embedding basis.
\\
\hline
{\hyperref[\detokenize{cospar.pl.gene_expression_on_manifold:cospar.pl.gene_expression_on_manifold}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pl.gene\_expression\_on\_manifold}}}}}(adata, …{[}, …{]})
&
Plot gene expression on the state manifold
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subsubsection{cospar.pl.embedding}
\label{\detokenize{cospar.pl.embedding:cospar-pl-embedding}}\label{\detokenize{cospar.pl.embedding::doc}}\index{embedding() (in module cospar.pl)@\spxentry{embedding()}\spxextra{in module cospar.pl}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.pl.embedding:cospar.pl.embedding}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.pl.}}\sphinxbfcode{\sphinxupquote{embedding}}}{\emph{\DUrole{n}{adata}}, \emph{\DUrole{n}{basis}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}X\_emb\textquotesingle{}}}, \emph{\DUrole{n}{color}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Scatter plot for user specified embedding basis.

We imported scanpy.pl.embedding for this purpose.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{adata}} : \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object}] \leavevmode
Assume to contain transition maps at adata.uns.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{basis}} : \sphinxtitleref{str}, optional (default: ‘X\_emb’)}] \leavevmode
The embedding to use for the plot.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{color}} : \sphinxtitleref{str, list of str, or None} (default: None)}] \leavevmode
Keys for annotations of observations/cells or variables/genes,
e.g., ‘state\_info’, ‘time\_info’,{[}‘Gata1’,’Gata2’{]}

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.pl.gene\_expression\_on\_manifold}
\label{\detokenize{cospar.pl.gene_expression_on_manifold:cospar-pl-gene-expression-on-manifold}}\label{\detokenize{cospar.pl.gene_expression_on_manifold::doc}}\index{gene\_expression\_on\_manifold() (in module cospar.pl)@\spxentry{gene\_expression\_on\_manifold()}\spxextra{in module cospar.pl}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.pl.gene_expression_on_manifold:cospar.pl.gene_expression_on_manifold}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.pl.}}\sphinxbfcode{\sphinxupquote{gene\_expression\_on\_manifold}}}{\emph{\DUrole{n}{adata}}, \emph{\DUrole{n}{selected\_genes}}, \emph{\DUrole{n}{savefig}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{plot\_time\_points}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}, \emph{\DUrole{n}{color\_bar}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Plot gene expression on the state manifold
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{adata}} : \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object}] \leavevmode
Assume to contain transition maps at adata.uns.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{selected\_genes}} : \sphinxtitleref{list} or ‘str’}] \leavevmode
List of genes to plot.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{savefig}} : \sphinxtitleref{bool}, optional (default: False)}] \leavevmode
Save the figure.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{plot\_time\_points}} : \sphinxtitleref{list}, optional (default: all)}] \leavevmode
A list of time points to further restrict the cell states to plot.
If map\_backwards=True, plot initial states that are among these time points;
else, plot later states that are among these time points.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{color\_bar}} : \sphinxtitleref{bool}, (default: False)}] \leavevmode
If True, plot the color bar.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{Datasets}
\label{\detokenize{api:datasets}}

\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{cospar.datasets.hematopoiesis_subsampled:cospar.datasets.hematopoiesis_subsampled}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{datasets.hematopoiesis\_subsampled}}}}}({[}data\_des{]})
&
Top 15\% most heterogeneous clones of the hematopoiesis data set from
\\
\hline
{\hyperref[\detokenize{cospar.datasets.hematopoiesis_all:cospar.datasets.hematopoiesis_all}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{datasets.hematopoiesis\_all}}}}}({[}data\_des{]})
&
All of the hematopoiesis data set from
\\
\hline
{\hyperref[\detokenize{cospar.datasets.lung:cospar.datasets.lung}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{datasets.lung}}}}}({[}data\_des{]})
&
The direct lung differentiation dataset from
\\
\hline
{\hyperref[\detokenize{cospar.datasets.reprogramming_no_merge_tags:cospar.datasets.reprogramming_no_merge_tags}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{datasets.reprogramming\_no\_merge\_tags}}}}}({[}data\_des{]})
&
The reprogramming dataset from
\\
\hline
{\hyperref[\detokenize{cospar.datasets.reprogramming_merge_tags:cospar.datasets.reprogramming_merge_tags}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{datasets.reprogramming\_merge\_tags}}}}}({[}data\_des{]})
&
The reprogramming dataset from
\\
\hline
{\hyperref[\detokenize{cospar.datasets.synthetic_bifurcation_static_BC:cospar.datasets.synthetic_bifurcation_static_BC}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{datasets.synthetic\_bifurcation\_static\_BC}}}}}({[}…{]})
&
Synthetic clonal datasets with static barcoding.
\\
\hline
{\hyperref[\detokenize{cospar.datasets.synthetic_bifurcation_dynamic_BC:cospar.datasets.synthetic_bifurcation_dynamic_BC}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{datasets.synthetic\_bifurcation\_dynamic\_BC}}}}}({[}…{]})
&
Synthetic clonal datasets with dynamic barcoding.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subsubsection{cospar.datasets.hematopoiesis\_subsampled}
\label{\detokenize{cospar.datasets.hematopoiesis_subsampled:cospar-datasets-hematopoiesis-subsampled}}\label{\detokenize{cospar.datasets.hematopoiesis_subsampled::doc}}\index{hematopoiesis\_subsampled() (in module cospar.datasets)@\spxentry{hematopoiesis\_subsampled()}\spxextra{in module cospar.datasets}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.datasets.hematopoiesis_subsampled:cospar.datasets.hematopoiesis_subsampled}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.datasets.}}\sphinxbfcode{\sphinxupquote{hematopoiesis\_subsampled}}}{\emph{\DUrole{n}{data\_des}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}LARRY\_sp500\_ranking1\textquotesingle{}}}}{}
Top 15\% most heterogeneous clones of the hematopoiesis data set from
\begin{itemize}
\item {} 
Weinreb, C., Rodriguez\sphinxhyphen{}Fraticelli, A., Camargo, F. D. \& Klein, A. M. Science 367, (2020)

\end{itemize}

This dataset has 3 time points for both the clones and the state measurements.
This sub\sphinxhyphen{}sampled data better illustrates the power of CoSpar in robstly
inferring differentiation dynamics from a noisy clonal dataset. Also, it
is smaller, and much faster to analyze.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\item[{\sphinxstyleliteralstrong{\sphinxupquote{data\_des}} : \sphinxtitleref{str}}] \leavevmode
A key to label this dataset.


\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.datasets.hematopoiesis\_all}
\label{\detokenize{cospar.datasets.hematopoiesis_all:cospar-datasets-hematopoiesis-all}}\label{\detokenize{cospar.datasets.hematopoiesis_all::doc}}\index{hematopoiesis\_all() (in module cospar.datasets)@\spxentry{hematopoiesis\_all()}\spxextra{in module cospar.datasets}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.datasets.hematopoiesis_all:cospar.datasets.hematopoiesis_all}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.datasets.}}\sphinxbfcode{\sphinxupquote{hematopoiesis\_all}}}{\emph{\DUrole{n}{data\_des}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}LARRY\textquotesingle{}}}}{}
All of the hematopoiesis data set from
\begin{itemize}
\item {} 
Weinreb, C., Rodriguez\sphinxhyphen{}Fraticelli, A., Camargo, F. D. \& Klein, A. M. Science 367, (2020)

\end{itemize}

This dataset has 3 time points for both the clones and the state measurements.
This dataset is very big. Generating the transition map for this datset
could take many hours when run for the first time.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\item[{\sphinxstyleliteralstrong{\sphinxupquote{data\_des}} : \sphinxtitleref{str}}] \leavevmode
A key to label this dataset.


\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.datasets.lung}
\label{\detokenize{cospar.datasets.lung:cospar-datasets-lung}}\label{\detokenize{cospar.datasets.lung::doc}}\index{lung() (in module cospar.datasets)@\spxentry{lung()}\spxextra{in module cospar.datasets}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.datasets.lung:cospar.datasets.lung}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.datasets.}}\sphinxbfcode{\sphinxupquote{lung}}}{\emph{\DUrole{n}{data\_des}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}Lung\textquotesingle{}}}}{}
The direct lung differentiation dataset from
\begin{itemize}
\item {} 
Hurley, K. et al. Cell Stem Cell (2020) doi:10.1016/j.stem.2019.12.009.

\end{itemize}

This dataset has multiple time points for the state manifold, but only one time point
for the clonal observation on day 27.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\item[{\sphinxstyleliteralstrong{\sphinxupquote{data\_des}} : \sphinxtitleref{str}}] \leavevmode
A key to label this dataset.


\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.datasets.reprogramming\_no\_merge\_tags}
\label{\detokenize{cospar.datasets.reprogramming_no_merge_tags:cospar-datasets-reprogramming-no-merge-tags}}\label{\detokenize{cospar.datasets.reprogramming_no_merge_tags::doc}}\index{reprogramming\_no\_merge\_tags() (in module cospar.datasets)@\spxentry{reprogramming\_no\_merge\_tags()}\spxextra{in module cospar.datasets}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.datasets.reprogramming_no_merge_tags:cospar.datasets.reprogramming_no_merge_tags}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.datasets.}}\sphinxbfcode{\sphinxupquote{reprogramming\_no\_merge\_tags}}}{\emph{\DUrole{n}{data\_des}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}CellTagging\_NoConcat\textquotesingle{}}}}{}
The reprogramming dataset from
\begin{itemize}
\item {} 
Biddy, B. A. et al. \sphinxtitleref{Single\sphinxhyphen{}cell mapping of lineage and identity in direct reprogramming}. Nature 564, 219\textendash{}224 (2018).

\end{itemize}

This dataset has multiple time points for both the clones and the state measurements.

The cells are barcoded over 3 rounds (i.e., 3 tags) during the entire differentiation
process. We treat barcode tags from each round as independent clonal label here.
In this representation, each cell has at most one clonal label. Effectively,
we convert the barcodes into static labels that do not carry temporal information.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\item[{\sphinxstyleliteralstrong{\sphinxupquote{data\_des}} : \sphinxtitleref{str}}] \leavevmode
A key to label this dataset.


\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.datasets.reprogramming\_merge\_tags}
\label{\detokenize{cospar.datasets.reprogramming_merge_tags:cospar-datasets-reprogramming-merge-tags}}\label{\detokenize{cospar.datasets.reprogramming_merge_tags::doc}}\index{reprogramming\_merge\_tags() (in module cospar.datasets)@\spxentry{reprogramming\_merge\_tags()}\spxextra{in module cospar.datasets}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.datasets.reprogramming_merge_tags:cospar.datasets.reprogramming_merge_tags}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.datasets.}}\sphinxbfcode{\sphinxupquote{reprogramming\_merge\_tags}}}{\emph{\DUrole{n}{data\_des}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}CellTagging\textquotesingle{}}}}{}
The reprogramming dataset from
\begin{itemize}
\item {} 
Biddy, B. A. et al. \sphinxtitleref{Single\sphinxhyphen{}cell mapping of lineage and identity in direct reprogramming}. Nature 564, 219\textendash{}224 (2018).

\end{itemize}

This dataset has multiple time points for both the clones and the state measurements.

The cells are barcoded over 3 rounds (i.e., 3 tags) during the entire differentiation
process. We treat barcode tags from each round as independent clonal label
here. In this representation, each cell can have multiple clonal labels
at different time points.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\item[{\sphinxstyleliteralstrong{\sphinxupquote{data\_des}} : \sphinxtitleref{str}}] \leavevmode
A key to label this dataset.


\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.datasets.synthetic\_bifurcation\_static\_BC}
\label{\detokenize{cospar.datasets.synthetic_bifurcation_static_BC:cospar-datasets-synthetic-bifurcation-static-bc}}\label{\detokenize{cospar.datasets.synthetic_bifurcation_static_BC::doc}}\index{synthetic\_bifurcation\_static\_BC() (in module cospar.datasets)@\spxentry{synthetic\_bifurcation\_static\_BC()}\spxextra{in module cospar.datasets}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.datasets.synthetic_bifurcation_static_BC:cospar.datasets.synthetic_bifurcation_static_BC}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.datasets.}}\sphinxbfcode{\sphinxupquote{synthetic\_bifurcation\_static\_BC}}}{\emph{\DUrole{n}{data\_des}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}bifur\textquotesingle{}}}}{}
Synthetic clonal datasets with static barcoding.

We simulated a differentiation process over a bifurcation fork. In this simulation,
cells are barcoded in the beginning, and the barcodes remain un\sphinxhyphen{}changed.
In the simulation we resample clones over time,
like the experimental design to obtain the hematopoietic dataset
or the reprogramming dataset. The dataset has two time points.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\item[{\sphinxstyleliteralstrong{\sphinxupquote{data\_des}} : \sphinxtitleref{str}}] \leavevmode
A key to label this dataset.


\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.datasets.synthetic\_bifurcation\_dynamic\_BC}
\label{\detokenize{cospar.datasets.synthetic_bifurcation_dynamic_BC:cospar-datasets-synthetic-bifurcation-dynamic-bc}}\label{\detokenize{cospar.datasets.synthetic_bifurcation_dynamic_BC::doc}}\index{synthetic\_bifurcation\_dynamic\_BC() (in module cospar.datasets)@\spxentry{synthetic\_bifurcation\_dynamic\_BC()}\spxextra{in module cospar.datasets}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.datasets.synthetic_bifurcation_dynamic_BC:cospar.datasets.synthetic_bifurcation_dynamic_BC}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.datasets.}}\sphinxbfcode{\sphinxupquote{synthetic\_bifurcation\_dynamic\_BC}}}{\emph{\DUrole{n}{data\_des}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}bifur\_conBC\textquotesingle{}}}}{}
Synthetic clonal datasets with dynamic barcoding.

We simulated a differentiation process over a bifurcation fork. In this simulation,
cells are barcoded, and the barcodes could accumulate mutations, which we call
\sphinxtitleref{dynamic barcoding}. In the simulation we resample clones over time,
like the experimental design to obtain the hematopoietic dataset
or the reprogramming dataset. The dataset has two time points.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\item[{\sphinxstyleliteralstrong{\sphinxupquote{data\_des}} : \sphinxtitleref{str}}] \leavevmode
A key to label this dataset.


\end{description}\end{quote}

\end{fulllineitems}



\subsection{Help functions}
\label{\detokenize{api:help-functions}}

\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{cospar.hf.read:cospar.hf.read}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hf.read}}}}}(filename{[}, backed, sheet, ext, …{]})
&
Read file and return \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object.
\\
\hline
{\hyperref[\detokenize{cospar.hf.check_available_map:cospar.hf.check_available_map}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hf.check\_available\_map}}}}}(adata)
&
Check available transition map.
\\
\hline
{\hyperref[\detokenize{cospar.hf.get_dge_SW:cospar.hf.get_dge_SW}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hf.get\_dge\_SW}}}}}(ad, mask1, mask2{[}, …{]})
&
Perform differential gene expression analysis.
\\
\hline
{\hyperref[\detokenize{cospar.hf.compute_fate_probability_map:cospar.hf.compute_fate_probability_map}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hf.compute\_fate\_probability\_map}}}}}(adata{[}, …{]})
&
Compute fate map from the adata object
\\
\hline
{\hyperref[\detokenize{cospar.hf.compute_state_potential:cospar.hf.compute_state_potential}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hf.compute\_state\_potential}}}}}(transition\_map, …)
&
Compute state probability towards/from given clusters
\\
\hline
{\hyperref[\detokenize{cospar.hf.filter_genes:cospar.hf.filter_genes}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hf.filter\_genes}}}}}(E{[}, base\_ix, …{]})
&
Filter genes by expression level and variability
\\
\hline
{\hyperref[\detokenize{cospar.hf.compute_fate_map_and_intrinsic_bias:cospar.hf.compute_fate_map_and_intrinsic_bias}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hf.compute\_fate\_map\_and\_intrinsic\_bias}}}}}(adata)
&
Compute fate map and the relative bias compared to expectation.
\\
\hline
{\hyperref[\detokenize{cospar.hf.mapout_trajectories:cospar.hf.mapout_trajectories}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hf.mapout\_trajectories}}}}}(transition\_map, …)
&
map out the ancestor probability for a given later state distribution.
\\
\hline
{\hyperref[\detokenize{cospar.hf.save_map:cospar.hf.save_map}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hf.save\_map}}}}}(adata)
&
Save the adata and print file name prefix.
\\
\hline
{\hyperref[\detokenize{cospar.hf.get_normalized_covariance:cospar.hf.get_normalized_covariance}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hf.get\_normalized\_covariance}}}}}(data{[}, method{]})
&
Compute the normalized correlation of the data matrix.
\\
\hline
{\hyperref[\detokenize{cospar.hf.add_neighboring_cells_to_a_map:cospar.hf.add_neighboring_cells_to_a_map}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hf.add\_neighboring\_cells\_to\_a\_map}}}}}(…{[}, …{]})
&
Add neighboring cells to an initially selected population
\\
\hline
{\hyperref[\detokenize{cospar.hf.compute_shortest_path_distance:cospar.hf.compute_shortest_path_distance}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hf.compute\_shortest\_path\_distance}}}}}(adata{[}, …{]})
&
Compute shortest path distance from raw data.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subsubsection{cospar.hf.read}
\label{\detokenize{cospar.hf.read:cospar-hf-read}}\label{\detokenize{cospar.hf.read::doc}}\index{read() (in module cospar.hf)@\spxentry{read()}\spxextra{in module cospar.hf}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.hf.read:cospar.hf.read}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.hf.}}\sphinxbfcode{\sphinxupquote{read}}}{\emph{filename}, \emph{backed=None}, \emph{sheet=None}, \emph{ext=None}, \emph{delimiter=None}, \emph{first\_column\_names=False}, \emph{backup\_url=None}, \emph{cache=False}, \emph{cache\_compression=\textless{}Empty.token: 0\textgreater{}}, \emph{**kwargs}}{}
Read file and return \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object.

To speed up reading, consider passing \sphinxcode{\sphinxupquote{cache=True}}, which creates an hdf5
cache file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{filename}} : \sphinxhref{https://docs.python.org/3/library/pathlib.html\#pathlib.Path}{\sphinxcode{\sphinxupquote{Path}}}, \sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxcode{\sphinxupquote{str}}}}] \leavevmode
If the filename has no file extension, it is interpreted as a key for
generating a filename via \sphinxcode{\sphinxupquote{sc.settings.writedir / (filename +
sc.settings.file\_format\_data)}}.  This is the same behavior as in
\sphinxcode{\sphinxupquote{sc.read(filename, ...)}}.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{backed}} : typing\_extensions.Literal{[}‘r’, ‘r+’{]}, \sphinxcode{\sphinxupquote{None}}}] \leavevmode
If \sphinxcode{\sphinxupquote{\textquotesingle{}r\textquotesingle{}}}, load \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} in \sphinxcode{\sphinxupquote{backed}} mode instead
of fully loading it into memory (\sphinxtitleref{memory} mode). If you want to modify
backed attributes of the AnnData object, you need to choose \sphinxcode{\sphinxupquote{\textquotesingle{}r+\textquotesingle{}}}.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{sheet}} : \sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxcode{\sphinxupquote{str}}}, \sphinxcode{\sphinxupquote{None}}}] \leavevmode
Name of sheet/table in hdf5 or Excel file.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{ext}} : \sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxcode{\sphinxupquote{str}}}, \sphinxcode{\sphinxupquote{None}}}] \leavevmode
Extension that indicates the file type. If \sphinxcode{\sphinxupquote{None}}, uses extension of
filename.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{delimiter}} : \sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxcode{\sphinxupquote{str}}}, \sphinxcode{\sphinxupquote{None}}}] \leavevmode
Delimiter that separates data within text file. If \sphinxcode{\sphinxupquote{None}}, will split at
arbitrary number of white spaces, which is different from enforcing
splitting at any single white space \sphinxcode{\sphinxupquote{\textquotesingle{} \textquotesingle{}}}.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{first\_column\_names}} : \sphinxhref{https://docs.python.org/3/library/functions.html\#bool}{\sphinxcode{\sphinxupquote{bool}}}}] \leavevmode
Assume the first column stores row names. This is only necessary if
these are not strings: strings in the first column are automatically
assumed to be row names.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{backup\_url}} : \sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxcode{\sphinxupquote{str}}}, \sphinxcode{\sphinxupquote{None}}}] \leavevmode
Retrieve the file from an URL if not present on disk.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{cache}} : \sphinxhref{https://docs.python.org/3/library/functions.html\#bool}{\sphinxcode{\sphinxupquote{bool}}}}] \leavevmode
If \sphinxtitleref{False}, read from source, if \sphinxtitleref{True}, read from fast ‘h5ad’ cache.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{cache\_compression}} : typing\_extensions.Literal{[}‘gzip’, ‘lzf’{]}, \sphinxcode{\sphinxupquote{None}}, \sphinxcode{\sphinxupquote{Empty}}}] \leavevmode
See the h5py \DUrole{xref,std,std-ref}{dataset\_compression}.
(Default: \sphinxtitleref{settings.cache\_compression})

\item[{\sphinxstyleliteralstrong{\sphinxupquote{kwargs}}}] \leavevmode
Parameters passed to \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.read\_loom.html\#anndata.read\_loom}{\sphinxcode{\sphinxupquote{read\_loom()}}}.

\end{description}

\item[{Return type}] \leavevmode
\sphinxcode{\sphinxupquote{AnnData}}

\item[{Returns}] \leavevmode
An \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.hf.check\_available\_map}
\label{\detokenize{cospar.hf.check_available_map:cospar-hf-check-available-map}}\label{\detokenize{cospar.hf.check_available_map::doc}}\index{check\_available\_map() (in module cospar.hf)@\spxentry{check\_available\_map()}\spxextra{in module cospar.hf}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.hf.check_available_map:cospar.hf.check_available_map}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.hf.}}\sphinxbfcode{\sphinxupquote{check\_available\_map}}}{\emph{\DUrole{n}{adata}}}{}
Check available transition map.

Update adata.uns{[}‘available\_map’{]}.

\end{fulllineitems}



\subsubsection{cospar.hf.get\_dge\_SW}
\label{\detokenize{cospar.hf.get_dge_SW:cospar-hf-get-dge-sw}}\label{\detokenize{cospar.hf.get_dge_SW::doc}}\index{get\_dge\_SW() (in module cospar.hf)@\spxentry{get\_dge\_SW()}\spxextra{in module cospar.hf}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.hf.get_dge_SW:cospar.hf.get_dge_SW}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.hf.}}\sphinxbfcode{\sphinxupquote{get\_dge\_SW}}}{\emph{\DUrole{n}{ad}}, \emph{\DUrole{n}{mask1}}, \emph{\DUrole{n}{mask2}}, \emph{\DUrole{n}{min\_frac\_expr}\DUrole{o}{=}\DUrole{default_value}{0.05}}, \emph{\DUrole{n}{pseudocount}\DUrole{o}{=}\DUrole{default_value}{1}}}{}
Perform differential gene expression analysis.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{ad}} : \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object}] \leavevmode


\item[{\sphinxstyleliteralstrong{\sphinxupquote{mask1}} : \sphinxtitleref{np.array}}] \leavevmode
A np.array of \sphinxtitleref{bool} for selecting group\_1 cells.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{mask2}} : \sphinxtitleref{np.array}}] \leavevmode
A np.array of \sphinxtitleref{bool} for selecting group\_2 cells.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{min\_frac\_expr}} : \sphinxtitleref{float}, optional (default: 0.05)}] \leavevmode
Minimum expression fraction among selected states for a
gene to be considered for DGE analysis.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{pseudocount}} : \sphinxtitleref{int}, optional (default: 1)}] \leavevmode
pseudo count for taking the gene expression ratio between the two groups

\end{description}

\item[{Returns}] \leavevmode
\sphinxstylestrong{df} (\sphinxcode{\sphinxupquote{pandas.DataFrame}}) \textendash{} A pandas dataFrame, with columns: \sphinxtitleref{gene}, \sphinxtitleref{pv}, \sphinxtitleref{mean\_1}, \sphinxtitleref{mean\_2}, \sphinxtitleref{ratio}

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.hf.compute\_fate\_probability\_map}
\label{\detokenize{cospar.hf.compute_fate_probability_map:cospar-hf-compute-fate-probability-map}}\label{\detokenize{cospar.hf.compute_fate_probability_map::doc}}\index{compute\_fate\_probability\_map() (in module cospar.hf)@\spxentry{compute\_fate\_probability\_map()}\spxextra{in module cospar.hf}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.hf.compute_fate_probability_map:cospar.hf.compute_fate_probability_map}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.hf.}}\sphinxbfcode{\sphinxupquote{compute\_fate\_probability\_map}}}{\emph{\DUrole{n}{adata}}, \emph{\DUrole{n}{fate\_array}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}, \emph{\DUrole{n}{used\_map\_name}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}transition\_map\textquotesingle{}}}, \emph{\DUrole{n}{map\_backwards}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
Compute fate map from the adata object
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{adata}} : \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object}] \leavevmode
Assume to contain transition maps at adata.uns.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{fate\_array}} : \sphinxtitleref{list}, optional (default: all)}] \leavevmode
List of targeted clusters, consistent with adata.obs{[}‘state\_info’{]}.
If set to be {[}{]}, use all fate clusters in adata.obs{[}‘state\_info’{]}.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{used\_map\_name}} : \sphinxtitleref{str}}] \leavevmode
The transition map to be used for plotting: \{‘transition\_map’,
‘intraclone\_transition\_map’,’weinreb\_transition\_map’,’naive\_transition\_map’,
‘OT\_transition\_map’,’HighVar\_transition\_map’\}. The actual available
map depends on adata itself, which can be accessed at adata.uns{[}‘available\_map’{]}

\item[{\sphinxstyleliteralstrong{\sphinxupquote{map\_backwards}} : \sphinxtitleref{bool}, optional (default: True)}] \leavevmode
If \sphinxtitleref{map\_backwards=True}, compute for initial cell states (rows of Tmap, at t1);
else, compute for later cell states (columns of Tmap, at t2)

\end{description}

\item[{Returns}] \leavevmode
Update \sphinxtitleref{fate\_array}, \sphinxtitleref{fate\_map}, \sphinxtitleref{fate\_entropy} as a dictionary in adata.uns{[}‘fate\_map’{]}.

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.hf.compute\_state\_potential}
\label{\detokenize{cospar.hf.compute_state_potential:cospar-hf-compute-state-potential}}\label{\detokenize{cospar.hf.compute_state_potential::doc}}\index{compute\_state\_potential() (in module cospar.hf)@\spxentry{compute\_state\_potential()}\spxextra{in module cospar.hf}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.hf.compute_state_potential:cospar.hf.compute_state_potential}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.hf.}}\sphinxbfcode{\sphinxupquote{compute\_state\_potential}}}{\emph{\DUrole{n}{transition\_map}}, \emph{\DUrole{n}{state\_annote}}, \emph{\DUrole{n}{fate\_array}}, \emph{\DUrole{n}{fate\_count}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{map\_backwards}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
Compute state probability towards/from given clusters

Before any calculation, we row\sphinxhyphen{}normalize the transition map.
If map\_backwards=True, compute the fate map towards given
clusters. Otherwise, compute the ancestor map, the probabilities
of a state to originate from given clusters.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{transition\_map}} : \sphinxtitleref{sp.spmatrix} (also accept \sphinxtitleref{np.array})}] \leavevmode
Transition map of the shape: (n\_t1\_cells, n\_t2\_cells).

\item[{\sphinxstyleliteralstrong{\sphinxupquote{state\_annote}} : \sphinxtitleref{np.array}}] \leavevmode
Annotation for each cell state.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{fate\_array}} : \sphinxtitleref{np.array} or \sphinxtitleref{list}}] \leavevmode
List of targeted clusters, consistent with state\_annote.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{fate\_count}} : \sphinxtitleref{bool}, optional (default: False)}] \leavevmode
Relevant for compute the fate\_entropy. If true, just count
the number of possible (Prob\textgreater{}0) fate outcomes for each state;
otherwise, compute the shannon entropy of fate outcome for each state

\item[{\sphinxstyleliteralstrong{\sphinxupquote{map\_backwards}} : \sphinxtitleref{bool}, optional (default: True)}] \leavevmode
If \sphinxtitleref{map\_backwards=True}, compute for initial cell states (rows of Tmap, at t1);
else, for later cell states (columns of Tmap, at t2)

\end{description}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{fate\_map} (\sphinxtitleref{np.array}, shape (n\_cells, n\_fates)) \textendash{} A matrix of fate potential for each state

\item {} 
\sphinxstylestrong{fate\_entropy} (\sphinxtitleref{np.array}, shape (n\_fates,)) \textendash{} A vector of fate entropy for each state

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.hf.filter\_genes}
\label{\detokenize{cospar.hf.filter_genes:cospar-hf-filter-genes}}\label{\detokenize{cospar.hf.filter_genes::doc}}\index{filter\_genes() (in module cospar.hf)@\spxentry{filter\_genes()}\spxextra{in module cospar.hf}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.hf.filter_genes:cospar.hf.filter_genes}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.hf.}}\sphinxbfcode{\sphinxupquote{filter\_genes}}}{\emph{\DUrole{n}{E}}, \emph{\DUrole{n}{base\_ix}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}, \emph{\DUrole{n}{min\_vscore\_pctl}\DUrole{o}{=}\DUrole{default_value}{85}}, \emph{\DUrole{n}{min\_counts}\DUrole{o}{=}\DUrole{default_value}{3}}, \emph{\DUrole{n}{min\_cells}\DUrole{o}{=}\DUrole{default_value}{3}}, \emph{\DUrole{n}{show\_vscore\_plot}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{sample\_name}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}}{}
Filter genes by expression level and variability
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{E}} : \sphinxtitleref{sp.spmatrix}}] \leavevmode
sparse count matrix

\item[{\sphinxstyleliteralstrong{\sphinxupquote{base\_ix}} : \sphinxtitleref{np.array}}] \leavevmode
List of column id’s to sub\sphinxhyphen{}sample the matrix

\item[{\sphinxstyleliteralstrong{\sphinxupquote{min\_counts}} : \sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{default: 3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}}] \leavevmode
Minimum number of UMIs per cell to be considered for selecting highly variable genes.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{min\_cells}} : \sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{default: 3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}}] \leavevmode
Minimum number of cells per gene to be considered for selecting highly variable genes.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{min\_vscore\_pctl}} : \sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{default: 85}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}}] \leavevmode
Genes wht a variability percentile higher than this threshold are marked as
highly variable genes for dimension reduction. Range: {[}0,100{]}

\item[{\sphinxstyleliteralstrong{\sphinxupquote{show\_vscore\_plot}} : \sphinxtitleref{bool}, optional (default: False)}] \leavevmode
If true, show the vscore plot for all genes

\item[{\sphinxstyleliteralstrong{\sphinxupquote{sample\_name}} : \sphinxtitleref{str}, optional (default: ‘’)}] \leavevmode
Name of the plot title.

\end{description}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{List of filtered gene indices (id’s)}

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.hf.compute\_fate\_map\_and\_intrinsic\_bias}
\label{\detokenize{cospar.hf.compute_fate_map_and_intrinsic_bias:cospar-hf-compute-fate-map-and-intrinsic-bias}}\label{\detokenize{cospar.hf.compute_fate_map_and_intrinsic_bias::doc}}\index{compute\_fate\_map\_and\_intrinsic\_bias() (in module cospar.hf)@\spxentry{compute\_fate\_map\_and\_intrinsic\_bias()}\spxextra{in module cospar.hf}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.hf.compute_fate_map_and_intrinsic_bias:cospar.hf.compute_fate_map_and_intrinsic_bias}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.hf.}}\sphinxbfcode{\sphinxupquote{compute\_fate\_map\_and\_intrinsic\_bias}}}{\emph{\DUrole{n}{adata}}, \emph{\DUrole{n}{selected\_fates}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}, \emph{\DUrole{n}{used\_map\_name}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}transition\_map\textquotesingle{}}}, \emph{\DUrole{n}{map\_backwards}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
Compute fate map and the relative bias compared to expectation.

\sphinxtitleref{selected\_fates} could contain a nested list of clusters. If so, we combine each sub list
into a mega\sphinxhyphen{}fate cluster and combine the fate map correspondingly.

The relative bias is obtained by comparing the fate\_prob with the
expected\_prob from targeted cluster size. It ranges from {[}0,1{]},
with 0.5 being the point that the fate\_prob agrees with expected\_prob.
1 is extremely biased.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{adata}} : \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object}] \leavevmode
Assume to contain transition maps at adata.uns.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{selected\_fates}} : \sphinxtitleref{list}, optional (default: all)}] \leavevmode
List of targeted clusters, consistent with adata.obs{[}‘state\_info’{]}.
If set to be {[}{]}, use all fate clusters in adata.obs{[}‘state\_info’{]}.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{used\_map\_name}} : \sphinxtitleref{str}}] \leavevmode
The transition map to be used for plotting: \{‘transition\_map’,
‘intraclone\_transition\_map’,’weinreb\_transition\_map’,’naive\_transition\_map’,
‘OT\_transition\_map’,’HighVar\_transition\_map’\}. The actual available
map depends on adata itself, which can be accessed at adata.uns{[}‘available\_map’{]}

\item[{\sphinxstyleliteralstrong{\sphinxupquote{map\_backwards}} : \sphinxtitleref{bool}, optional (default: True)}] \leavevmode
If \sphinxtitleref{map\_backwards=True}, compute for initial cell states (rows of Tmap, at t1);
else, compute for later cell states (columns of Tmap, at t2)

\end{description}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
Store \sphinxtitleref{fate\_array}, \sphinxtitleref{fate\_map}, \sphinxtitleref{fate\_entropy} in adata.uns{[}‘fate\_map’{]}.

\item {} 
\sphinxstylestrong{fate\_map} (\sphinxtitleref{np.array}, shape (n\_cell, n\_fate)) \textendash{} n\_fate is the number of mega cluster, equals len(selected\_fates).

\item {} 
\sphinxstylestrong{mega\_cluster\_list} (\sphinxtitleref{list}, shape (n\_fate)) \textendash{} The list of names for the mega cluster. This is relevant when
\sphinxtitleref{selected\_fates} is a list of list.

\item {} 
\sphinxstylestrong{relative\_bias} (\sphinxtitleref{np.array}, shape (n\_cell, n\_fate))

\item {} 
\sphinxstylestrong{expected\_prob} (\sphinxtitleref{np.array}, shape (n\_fate,))

\item {} 
\sphinxstylestrong{valid\_fate\_list} (\sphinxtitleref{list}, shape (n\_fate)) \textendash{} It is basically the same as selected\_fates, could contain a nested list
of fate clusters. It screens for valid fates, though.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.hf.mapout\_trajectories}
\label{\detokenize{cospar.hf.mapout_trajectories:cospar-hf-mapout-trajectories}}\label{\detokenize{cospar.hf.mapout_trajectories::doc}}\index{mapout\_trajectories() (in module cospar.hf)@\spxentry{mapout\_trajectories()}\spxextra{in module cospar.hf}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.hf.mapout_trajectories:cospar.hf.mapout_trajectories}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.hf.}}\sphinxbfcode{\sphinxupquote{mapout\_trajectories}}}{\emph{\DUrole{n}{transition\_map}}, \emph{\DUrole{n}{state\_prob\_t2}}, \emph{\DUrole{n}{threshold}\DUrole{o}{=}\DUrole{default_value}{0.1}}, \emph{\DUrole{n}{cell\_id\_t1}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}, \emph{\DUrole{n}{cell\_id\_t2}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}}{}
map out the ancestor probability for a given later state distribution.

We assume that transition\_map is a normalized probablistic map from
t1\sphinxhyphen{}state to t2\sphinxhyphen{}states. Given a distribution of states at t2, we find
and return the initial state distribution.

Although it is designed to map trajectories backwards, one can simply
tanspose the Tmap, and swap everything related to t1 and t2, to map forward.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{transition\_map}} : \sphinxtitleref{np.array} (also accept \sphinxtitleref{sp.spsparse}), shape (n\_t1, n\_t2)}] \leavevmode
A transition matrix that is properly normalized.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{state\_prob\_t2}} : \sphinxtitleref{np.array}, shape (n\_t2,)}] \leavevmode
A continuous\sphinxhyphen{}valued vector that defines the probability of the final states.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{threshold}} : \sphinxtitleref{float}, optional (default: 0.1), range ({[}0,1{]})}] \leavevmode
We set to zero entries \textless{} threshold * max(state\_prob\_t1).

\item[{\sphinxstyleliteralstrong{\sphinxupquote{cell\_id\_t1}} : \sphinxtitleref{np.array} (also accept \sphinxtitleref{list})}] \leavevmode
The id array for cell states at t1 in the full space

\item[{\sphinxstyleliteralstrong{\sphinxupquote{cell\_id\_t2}} : \sphinxtitleref{np.array} (also accept \sphinxtitleref{list})}] \leavevmode
The id array for cell states at t2 in the full space

\end{description}

\item[{Returns}] \leavevmode
\sphinxstylestrong{state\_prob\_t1\_truc} (\sphinxtitleref{np.array}, shape (n\_t1,)) \textendash{} The fate probability of each t1\sphinxhyphen{}cell state to enter the soft
t2\sphinxhyphen{}cluster as defined by state\_prob\_t2.

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.hf.save\_map}
\label{\detokenize{cospar.hf.save_map:cospar-hf-save-map}}\label{\detokenize{cospar.hf.save_map::doc}}\index{save\_map() (in module cospar.hf)@\spxentry{save\_map()}\spxextra{in module cospar.hf}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.hf.save_map:cospar.hf.save_map}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.hf.}}\sphinxbfcode{\sphinxupquote{save\_map}}}{\emph{\DUrole{n}{adata}}}{}
Save the adata and print file name prefix.

The file name prefix \sphinxtitleref{data\_des} will be printed, and
the saved file can be accessed again using this prefix.

\end{fulllineitems}



\subsubsection{cospar.hf.get\_normalized\_covariance}
\label{\detokenize{cospar.hf.get_normalized_covariance:cospar-hf-get-normalized-covariance}}\label{\detokenize{cospar.hf.get_normalized_covariance::doc}}\index{get\_normalized\_covariance() (in module cospar.hf)@\spxentry{get\_normalized\_covariance()}\spxextra{in module cospar.hf}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.hf.get_normalized_covariance:cospar.hf.get_normalized_covariance}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.hf.}}\sphinxbfcode{\sphinxupquote{get\_normalized\_covariance}}}{\emph{\DUrole{n}{data}}, \emph{\DUrole{n}{method}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}Weinreb\textquotesingle{}}}}{}
Compute the normalized correlation of the data matrix.

This is used to compute the fate coupling.
Two methods are provided, \sphinxtitleref{Weinreb} method and ‘SW’.
The \sphinxtitleref{Weinreb} method perform normalization against the mean observation
for each fate; while the \sphinxtitleref{SW} method normalizes against the square root of
the self coupling, brining the self coupling to 1 after normalization.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{data}} : \sphinxtitleref{np.array}, shape (n\_obs, n\_fates)}] \leavevmode
A observation matrix for the fate distribution. The observable
could be the number of barcodes in each fate, or the probability
of a cell to enter a fate.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{method}} : \sphinxtitleref{str}, optional (default: ‘Weinreb’)}] \leavevmode
Method for computing the normalized covariance. Choice: \{‘Weinreb’,’SW’\}

\end{description}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{Normalized covariance matrix.}

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.hf.add\_neighboring\_cells\_to\_a\_map}
\label{\detokenize{cospar.hf.add_neighboring_cells_to_a_map:cospar-hf-add-neighboring-cells-to-a-map}}\label{\detokenize{cospar.hf.add_neighboring_cells_to_a_map::doc}}\index{add\_neighboring\_cells\_to\_a\_map() (in module cospar.hf)@\spxentry{add\_neighboring\_cells\_to\_a\_map()}\spxextra{in module cospar.hf}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.hf.add_neighboring_cells_to_a_map:cospar.hf.add_neighboring_cells_to_a_map}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.hf.}}\sphinxbfcode{\sphinxupquote{add\_neighboring\_cells\_to\_a\_map}}}{\emph{\DUrole{n}{initial\_idx}}, \emph{\DUrole{n}{adata}}, \emph{\DUrole{n}{neighbor\_N}\DUrole{o}{=}\DUrole{default_value}{5}}}{}
Add neighboring cells to an initially selected population
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{initial\_idx}} : \sphinxtitleref{np.array}, shape (n\_cell,)}] \leavevmode
A boolean array for state selection.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{adata}} : \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object, shape (n\_cell, n\_genes)}] \leavevmode


\item[{\sphinxstyleliteralstrong{\sphinxupquote{neighbor\_N}} : \sphinxtitleref{int}, optional (default: 5)}] \leavevmode
Number of neighbors for KNN graph construction.

\end{description}

\item[{Returns}] \leavevmode
\sphinxstylestrong{post\_idx} (\sphinxtitleref{np.array}, shape (n\_cell,)) \textendash{} A boolean array of selected cell states post expansion.

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{cospar.hf.compute\_shortest\_path\_distance}
\label{\detokenize{cospar.hf.compute_shortest_path_distance:cospar-hf-compute-shortest-path-distance}}\label{\detokenize{cospar.hf.compute_shortest_path_distance::doc}}\index{compute\_shortest\_path\_distance() (in module cospar.hf)@\spxentry{compute\_shortest\_path\_distance()}\spxextra{in module cospar.hf}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cospar.hf.compute_shortest_path_distance:cospar.hf.compute_shortest_path_distance}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cospar.hf.}}\sphinxbfcode{\sphinxupquote{compute\_shortest\_path\_distance}}}{\emph{\DUrole{n}{adata}}, \emph{\DUrole{n}{num\_neighbors\_target}\DUrole{o}{=}\DUrole{default_value}{5}}, \emph{\DUrole{n}{mode}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}distances\textquotesingle{}}}, \emph{\DUrole{n}{limit}\DUrole{o}{=}\DUrole{default_value}{inf}}, \emph{\DUrole{n}{method}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}umap\textquotesingle{}}}}{}
Compute shortest path distance from raw data.

The distance matrix has two mode: ‘connectivity’ or ‘distance’.
We found that the ‘connectivity’ version is sensitive to local cell
density heterogeneity, and the ‘distance’ version is more robust.
This discrepancy might be due to that the KNN graph construction does not
direclty take into account of local density heterogeneity.

The default is the UMAP method, which takes into account of local
density heterogeneity into account when constructing the KNN graph.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstyleliteralstrong{\sphinxupquote{adata}} : \sphinxcode{\sphinxupquote{AnnaData}} object}] \leavevmode


\item[{\sphinxstyleliteralstrong{\sphinxupquote{num\_neighbors\_target}} : \sphinxtitleref{int}, optional (default: 5)}] \leavevmode
Used to construct the KNN graph.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{mode}} : \sphinxtitleref{str}, optional (default: ‘distance’)}] \leavevmode
Options: \{‘distance’,’connectivity’)

\item[{\sphinxstyleliteralstrong{\sphinxupquote{limit}} : \sphinxtitleref{float}, optional (default: np.inf)}] \leavevmode
If the distance is about this, stop computation, and set
the distance beyong this limist by \sphinxtitleref{limit}. This can speed up computation.

\item[{\sphinxstyleliteralstrong{\sphinxupquote{method}} : \sphinxtitleref{str}, optional (default: ‘umap’)}] \leavevmode
The method to construct the KNN graph. Options: \{‘umap’,’gauss’,’others’\}.
The frist two methods are based on sc.pp.neighbors, while the last is from
kneighbors\_graph.

\end{description}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{The normaized distance matrix is returned.}

\end{description}\end{quote}

\end{fulllineitems}



\section{Installation}
\label{\detokenize{installation:installation}}\label{\detokenize{installation::doc}}
CoSpar requires Python 3.6 or later. We recommend to use \sphinxhref{http://conda.pydata.org/miniconda.html}{Miniconda}.


\subsection{PyPI}
\label{\detokenize{installation:pypi}}
Install CoSpar from \sphinxhref{https://pypi.org/project/CoSpar}{PyPI} using:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pip} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{n}{U} \PYG{n}{cospar}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{\sphinxhyphen{}U}} is short for \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}upgrade}}.
If you get a \sphinxcode{\sphinxupquote{Permission denied}} error, use \sphinxcode{\sphinxupquote{pip install \sphinxhyphen{}U CoSpar \sphinxhyphen{}\sphinxhyphen{}user}} instead.


\subsection{Development Version}
\label{\detokenize{installation:development-version}}
To work with the latest development version, install from \sphinxhref{https://github.com/theislab/CoSpar}{GitHub} using:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pip} \PYG{n}{install} \PYG{n}{git}\PYG{o}{+}\PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{AllonKleinLab}\PYG{o}{/}\PYG{n}{cospar}
\end{sphinxVerbatim}

or:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{git} \PYG{n}{clone} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{AllonKleinLab}\PYG{o}{/}\PYG{n}{cospar}
\PYG{n}{pip} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{n}{cospar}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{\sphinxhyphen{}e}} is short for \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}editable}} and links the package to the original cloned
location such that pulled changes are also reflected in the environment.

To contribute to CoSpar, \sphinxcode{\sphinxupquote{cd}} into the cloned directory and
install the latest packages required for development together with the pre\sphinxhyphen{}commit hooks:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pip} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{n}{r} \PYG{n}{requirements}\PYG{o}{\PYGZhy{}}\PYG{n}{dev}\PYG{o}{.}\PYG{n}{txt}
\PYG{n}{pre}\PYG{o}{\PYGZhy{}}\PYG{n}{commit} \PYG{n}{install}
\end{sphinxVerbatim}


\subsection{Dependencies}
\label{\detokenize{installation:dependencies}}\begin{itemize}
\item {} 
\sphinxhref{https://anndata.readthedocs.io/}{anndata} \sphinxhyphen{} annotated data object.

\item {} 
\sphinxhref{https://scanpy.readthedocs.io/}{scanpy} \sphinxhyphen{} toolkit for single\sphinxhyphen{}cell analysis.

\item {} 
\sphinxhref{https://docs.scipy.org/}{numpy}, \sphinxhref{https://docs.scipy.org/}{scipy}, \sphinxhref{https://pandas.pydata.org/}{pandas}, \sphinxhref{https://scikit-learn.org/}{scikit\sphinxhyphen{}learn}, \sphinxhref{https://matplotlib.org/}{matplotlib}, \sphinxhref{https://plotnine.readthedocs.io/}{plotnine},

\end{itemize}


\subsection{Jupyter Notebook}
\label{\detokenize{installation:jupyter-notebook}}
To run the tutorials in a notebook locally, please install:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{conda} \PYG{n}{install} \PYG{n}{notebook}
\end{sphinxVerbatim}

and run \sphinxcode{\sphinxupquote{jupyter notebook}} in the terminal. If you get the error \sphinxcode{\sphinxupquote{Not a directory: \textquotesingle{}xdg\sphinxhyphen{}settings\textquotesingle{}}},
use \sphinxcode{\sphinxupquote{jupyter notebook \sphinxhyphen{}\sphinxhyphen{}no\sphinxhyphen{}browser}} instead and open the url manually (or use this
\sphinxhref{https://github.com/jupyter/notebook/issues/3746\#issuecomment-444957821}{bugfix}).

If you run into issues, do not hesitate to approach us or raise a \sphinxhref{https://github.com/AllonKleinLab/cospar/issues/new/choose}{GitHub issue}.


\section{Getting Started}
\label{\detokenize{getting_started:getting-started}}\label{\detokenize{getting_started::doc}}
Here, you will be briefly guided through the basics of how to use CoSpar.
Once you are set, the following tutorials go straight into analysis of transition dynamics.

The input data for CoSpar are matrices for state and clonal information, and a vector for temporal annotation. We assume that the data have more than one time points.


\subsection{CoSpar workflow at a glance}
\label{\detokenize{getting_started:cospar-workflow-at-a-glance}}
Import CoSpar as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{cospar} \PYG{k}{as} \PYG{n+nn}{cs}
\end{sphinxVerbatim}

For beautified visualization you can change the matplotlib settings to our defaults with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{set\PYGZus{}figure\PYGZus{}params}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{Initialization}
\label{\detokenize{getting_started:initialization}}
Given the gene expression matrix, clonal matrix, and other information, initialize the anndata object using:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{adata} \PYG{o}{=} \PYG{n}{cs}\PYG{o}{.}\PYG{n}{initialize\PYGZus{}adata\PYGZus{}object}\PYG{p}{(}\PYG{n}{RNA\PYGZus{}count\PYGZus{}matrix}\PYG{p}{,}\PYG{n}{gene\PYGZus{}names}\PYG{p}{,}\PYG{n}{time\PYGZus{}info}\PYG{p}{,}
\PYG{n}{X\PYGZus{}clone}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{n}{X\PYGZus{}pca}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{n}{X\PYGZus{}emb}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{n}{state\PYGZus{}info}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{params}\PYG{p}{)}
\end{sphinxVerbatim}

The \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object adata stores the count matrix (\sphinxcode{\sphinxupquote{adata.X}}), genes / variables (\sphinxcode{\sphinxupquote{adata.var}}), and  annotation of cells / observations (\sphinxcode{\sphinxupquote{adata.obs{[}\textquotesingle{}time\_info\textquotesingle{}{]}}}).  The clonal matrix \sphinxtitleref{X\_clone} is optional, and will be stored at  \sphinxcode{\sphinxupquote{adata.obsm{[}\textquotesingle{}X\_clone\textquotesingle{}{]}}}.  If not provided, you can still infer transition map based on state and temporal information alone, and proceed with the analysis. You can also provide the selected PCA matrix \sphinxtitleref{X\_pca},  the embedding matrix \sphinxtitleref{X\_emb}, and the state annotation \sphinxtitleref{state\_info}, which will be stored at \sphinxcode{\sphinxupquote{adata.obsm{[}\textquotesingle{}X\_pca\textquotesingle{}{]}}}, \sphinxcode{\sphinxupquote{adata.obsm{[}\textquotesingle{}X\_emb\textquotesingle{}{]}}}, and \sphinxcode{\sphinxupquote{adata.obs{[}\textquotesingle{}state\_info\textquotesingle{}{]}}}, respectively.



If you do not have a datasets yet, you can still play around using one of the in\sphinxhyphen{}built datasets, e.g.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{adata} \PYG{o}{=} \PYG{n}{cs}\PYG{o}{.}\PYG{n}{datasets}\PYG{o}{.}\PYG{n}{hematopoiesis\PYGZus{}15perct}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{Basic preprocessing}
\label{\detokenize{getting_started:basic-preprocessing}}
Assuming basic quality control (excluding cells with low read count etc.) have been done, we provide basic preprocessing (gene selection and normalization) and dimension reduction related analysis (PCA, UMAP embedding etc.)  at (\sphinxcode{\sphinxupquote{cs.pp.*}}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pp}\PYG{o}{.}\PYG{n}{get\PYGZus{}highly\PYGZus{}variable\PYGZus{}genes}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{params}\PYG{p}{)}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pp}\PYG{o}{.}\PYG{n}{remove\PYGZus{}cell\PYGZus{}cycle\PYGZus{}correlated\PYGZus{}genes}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{params}\PYG{p}{)}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pp}\PYG{o}{.}\PYG{n}{get\PYGZus{}X\PYGZus{}pca}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{params}\PYG{p}{)}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pp}\PYG{o}{.}\PYG{n}{get\PYGZus{}X\PYGZus{}emb}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{params}\PYG{p}{)}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pp}\PYG{o}{.}\PYG{n}{get\PYGZus{}state\PYGZus{}info}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{params}\PYG{p}{)}
\end{sphinxVerbatim}

The first step \sphinxtitleref{get\_highly\_variable\_genes} alrealdy includes count matrix normalization. The second step removes cell cycle correlated genes among the selected highly variable genes.
This is optional, but recommended.

These steps can also be performed by  external packages like \sphinxhref{https://scanpy.readthedocs.io/en/latest/api/index.html\#module-scanpy}{\sphinxcode{\sphinxupquote{scanpy}}}, which is also built around the \sphinxhref{https://anndata.readthedocs.io/en/latest/anndata.AnnData.html\#anndata.AnnData}{\sphinxcode{\sphinxupquote{AnnData}}} object.


\subsubsection{Simple clonal analysis}
\label{\detokenize{getting_started:simple-clonal-analysis}}
We provide a few plotting functions to visually explore the clonal data before any downstream analysis. You can visualize clones on state manifold directly:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{clones\PYGZus{}on\PYGZus{}manifold}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{params}\PYG{p}{)}
\end{sphinxVerbatim}

You can generate the barcode heatmap across given clusters to inspect clonal behavior:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{barcode\PYGZus{}heatmap}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{params}\PYG{p}{)}
\end{sphinxVerbatim}

You can quantify the clonal coupling across different fate clusters:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}coupling\PYGZus{}from\PYGZus{}clones}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{params}\PYG{p}{)}
\end{sphinxVerbatim}

Strong coupling implies the existence of bi\sphinxhyphen{}potent or multi\sphinxhyphen{}potent cell states at the time of barcoding. Finally, you can infer the fate bias of each clone towards a designated fate cluster:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{clonal\PYGZus{}fate\PYGZus{}bias}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{params}\PYG{p}{)}
\end{sphinxVerbatim}

A biased clone towards this cluster has a statistically significant cell fraction in this cluster.


\subsubsection{Transition map inference}
\label{\detokenize{getting_started:transition-map-inference}}
The core of the software is the efficient and robust inference of a transition map by integrating state and clonal information. If the data have multiple clonal time points, you can run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{adata}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{tmap}\PYG{o}{.}\PYG{n}{infer\PYGZus{}Tmap\PYGZus{}from\PYGZus{}multitime\PYGZus{}clones}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{selected\PYGZus{}clonal\PYGZus{}time\PYGZus{}points}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{params}\PYG{p}{)}
\end{sphinxVerbatim}

It subsamples the input data according to selected time points (\(\ge 2\)) with clonal information, computes the transition map (stored at \sphinxtitleref{adata.uns{[}‘transition\_map’{]}}), and return the subsampled adata object. The inferred map allows transitions between neighboring time points. For example, if selected\_clonal\_time\_points={[}‘day1’, ‘day2’, ‘day3’{]}, then it computes transitions for pairs (‘day1’, ‘day2’) and (‘day2’, ‘day3’), but not (‘day1’, ‘day3’). As a byproduct, it also returns a transition map that allows only intra\sphinxhyphen{}clone transitions (\sphinxtitleref{adata.uns{[}‘intraclone\_transition\_map’{]}}). The intra\sphinxhyphen{}clone transition map can also be computed from \sphinxtitleref{adata.uns{[}‘transition\_map’{]}}) at preferred parameters by running:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{tmap}\PYG{o}{.}\PYG{n}{infer\PYGZus{}intraclone\PYGZus{}Tmap}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{params}\PYG{p}{)}
\end{sphinxVerbatim}

If the data have only one clonal time point, or you wish to infer the transition map just based on a single clonal time point, you can run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{tmap}\PYG{o}{.}\PYG{n}{infer\PYGZus{}Tmap\PYGZus{}from\PYGZus{}one\PYGZus{}time\PYGZus{}clones}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{initial\PYGZus{}time\PYGZus{}points}\PYG{p}{,} \PYG{n}{clonal\PYGZus{}time\PYGZus{}point}\PYG{p}{,}\PYG{n}{initialize\PYGZus{}method}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{OT}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{params}\PYG{p}{)}
\end{sphinxVerbatim}

You need to define both \sphinxtitleref{initial\_time\_points} and \sphinxtitleref{clonal\_time\_point}. We provide two methods for initializing the map using state information alone: 1) ‘OT’ for using standard optimal transport approach; 2) ‘HighVar’ for a customized approach that convert highly variable genes into pseudo multi\sphinxhyphen{}time clones and run \sphinxtitleref{cs.tmap.infer\_Tmap\_from\_multitime\_clones} to construct the map. Depending on the choice,  the initialized map is stored at \sphinxtitleref{adata.uns{[}‘OT\_transition\_map’{]}} or  \sphinxtitleref{adata.uns{[}‘HighVar\_transition\_map’{]}}. Afterwards, CoSpar performs a joint optimization to infer both the initial clonal structure and also the transition map. The final product is stored at \sphinxtitleref{adata.uns{[}‘transition\_map’{]}}. This method returns a map for transitions from all given initial time points to the designated clonal time point.  For example, if initial\_time\_points={[}‘day1’, ‘day2’{]}, and clonal\_time\_point=’day3’, then the method computes transitions for pairs (‘day1’, ‘day3’) and (‘day2’, ‘day3’).

If you do not have any clonal information, you can still run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{tmap}\PYG{o}{.}\PYG{n}{infer\PYGZus{}Tmap\PYGZus{}from\PYGZus{}state\PYGZus{}info\PYGZus{}alone}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{initial\PYGZus{}time\PYGZus{}points}\PYG{p}{,}\PYG{n}{target\PYGZus{}time\PYGZus{}point}\PYG{p}{,}\PYG{n}{initialize\PYGZus{}method}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{OT}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{params}\PYG{p}{)}
\end{sphinxVerbatim}

It is the same as \sphinxtitleref{cs.tmap.infer\_Tmap\_from\_one\_time\_clones} except that we exclude the the final joint optimization that requires clonal information.

We also provide simple methods that infer transition map from only the clonal information:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{tmap}\PYG{o}{.}\PYG{n}{infer\PYGZus{}Tmap\PYGZus{}from\PYGZus{}clonal\PYGZus{}info\PYGZus{}alone}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{params}\PYG{p}{)}
\end{sphinxVerbatim}

The result is stored at \sphinxtitleref{adata.uns{[}‘clonal\_transition\_map’{]}}.


\subsubsection{Visualization}
\label{\detokenize{getting_started:visualization}}
Finally, each of the computed transition maps can be explored on state embedding at single cell level using a variaty of plotting functions. There are some common parameters:
\begin{itemize}
\item {} 
\sphinxtitleref{used\_map\_name} (\sphinxtitleref{str}). Determines which transition map to use for analysis. Choices: \{‘transition\_map’, ‘intraclone\_transition\_map’, ‘OT\_transition\_map’, ‘HighVar\_transition\_map’,’clonal\_transition\_map’\}

\item {} 
\sphinxtitleref{selected\_fates} (\sphinxtitleref{list} of \sphinxtitleref{str}). Selected clusters to aggregate differentiation dynamics and visualize fate bias etc.. The selected\_fates allows nested structure, e.g., selected\_fates={[}‘1’, {[}‘0’, ‘2’{]}{]} selects two clusters:  cluster ‘1’ and the other that combines ‘0’ and ‘2’.

\item {} 
\sphinxtitleref{map\_backwards} (\sphinxtitleref{bool}).  We can analyze either the forward transitions, i.e., where the selected states or clusters are going (\sphinxtitleref{map\_backwards=False}), or the backward transitions, i.e., where these selected states or clusters came from (\sphinxtitleref{map\_backwards=False}). The latter is more useful, and is the default.

\end{itemize}

Below, we frame the task in the language of analyzing backward transitions for convenience. To see transition probability from one cell to others, run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{single\PYGZus{}cell\PYGZus{}transition}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{params}\PYG{p}{)}
\end{sphinxVerbatim}

To see the probability of initial cell states to give rise to given fate clusters (or the other way around if \sphinxtitleref{map\_backwards=False}), run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}map}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{params}\PYG{p}{)}
\end{sphinxVerbatim}

To infer the relative fate bias of initial cell states to given fate clusters, run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}bias\PYGZus{}intrinsic}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{params}\PYG{p}{)}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}bias\PYGZus{}from\PYGZus{}binary\PYGZus{}competition}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{params}\PYG{p}{)}
\end{sphinxVerbatim}

The first method (\sphinxtitleref{fate\_bias\_intrinsic}) quantify the fate bias of a state towards each designated cluster by normalizing the predicted fate probability with the expected fate bias, the relative proportion of this cluster among all cell states in the target state space of the map. The second method evaluates the fate bias of a state towards one cluster over the other.

To infer the dynamic trajectory towards given fate clusters, run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{dynamic\PYGZus{}trajectory\PYGZus{}from\PYGZus{}intrinsic\PYGZus{}bias}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{params}\PYG{p}{)}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{dynamic\PYGZus{}trajectory\PYGZus{}from\PYGZus{}competition\PYGZus{}bias}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{params}\PYG{p}{)}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{dynamic\PYGZus{}trajectory\PYGZus{}via\PYGZus{}iterative\PYGZus{}mapping}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{params}\PYG{p}{)}
\end{sphinxVerbatim}

The first two methods assumes two input fate clusters, and infer the each corresponding trajectory by thresholding the fate bias using either the intrinsic method or the binary competition method. They export the selected ancestor state for the two fate clusters at \sphinxtitleref{adata.obs{[}‘Cell\_group\_A’{]}} and \sphinxtitleref{adata.obs{[}‘Cell\_group\_B’{]}}, which can be used to infer the differentially expressed genes (specifically, driver genes for fate bifurcation here) by running:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{differential\PYGZus{}genes}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{params}\PYG{p}{)}
\end{sphinxVerbatim}

The last method (\sphinxtitleref{dynamic\_trajectory\_via\_iterative\_mapping}) infers the trajectory by iteratively tracing a selected fate cluster all the way back to the initial time point. The inferred trajectory for each fate from all three methods will be saved at \sphinxtitleref{adata.uns{[}‘dynamic\_trajectory’{]}{[}fate\_name{]}}, and we can explore the gene expression dynamics along this trajectory using:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{gene\PYGZus{}expression\PYGZus{}dynamics}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fate}\PYG{p}{,}\PYG{n}{gene\PYGZus{}name\PYGZus{}list}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{params}\PYG{p}{)}
\end{sphinxVerbatim}

The \sphinxtitleref{selected\_fate} should be among those that have run the dynamic trajectory inference stated above.

If there are multiple mature fate clusters, you can infer the their differentiation coupling by:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}coupling\PYGZus{}from\PYGZus{}Tmap}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{params}\PYG{p}{)}
\end{sphinxVerbatim}


\section{CoSpar basics}
\label{\detokenize{20210121_cospar_tutorial:CoSpar-basics}}\label{\detokenize{20210121_cospar_tutorial::doc}}
Below, we walk you through typical steps of analysis. We use the subsampled hematopoiesis dataset so that this tutorial an be run within a few minutes. For further demonstration, please see notebooks at the \sphinxstylestrong{Examples} section.

\sphinxstylestrong{Contents}:
\begin{itemize}
\item {} 
Initialization

\item {} 
Preprocessing and dimension reduction (optional)

\item {} 
Raw clonal data analysis (without using state information)

\item {} 
Transition map inference

\item {} 
Plotting

\item {} 
Miscellaneous

\end{itemize}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[1]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{n}{new\PYGZus{}path}\PYG{o}{=}\PYG{n}{os}\PYG{o}{.}\PYG{n}{getcwd}\PYG{p}{(}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{/CoSpar/}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{new\PYGZus{}path}\PYG{p}{)}

\PYG{k+kn}{import} \PYG{n+nn}{cospar} \PYG{k}{as} \PYG{n+nn}{cs}
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[2]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{verbosity}\PYG{o}{=}\PYG{l+m+mi}{3} \PYG{c+c1}{\PYGZsh{}range: 0 (error),1 (warning),2 (info),3 (hint). Set it at a given value will print information at and below its level.}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{set\PYGZus{}figure\PYGZus{}params}\PYG{p}{(}\PYG{n+nb}{format}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{png}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{dpi}\PYG{o}{=}\PYG{l+m+mi}{75}\PYG{p}{,}\PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{14}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} figure setting.}
\end{sphinxVerbatim}
}

Each dataset should have its own folder to avoid conflict.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[3]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{c+c1}{\PYGZsh{} set the directory for figures and data. If not existed yet, it will be created automtaically.}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{data\PYGZus{}path}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{data\PYGZus{}cospar}\PYG{l+s+s1}{\PYGZsq{}} \PYG{c+c1}{\PYGZsh{}data\PYGZus{}path}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{figure\PYGZus{}path}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{fig\PYGZus{}path}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}
}


\subsection{Initialization}
\label{\detokenize{20210121_cospar_tutorial:Initialization}}
The first step is to construct an adata object that stores all relevant data. The input data are:
\begin{itemize}
\item {} 
\sphinxstylestrong{RNA\_count\_matrix}: shape (n\_cell, n\_gene), mandatory, stored at \sphinxcode{\sphinxupquote{adata.X}}

\item {} 
\sphinxstylestrong{gene\_names}: list of gene names, shape (n\_genes,), mandatory, stored at \sphinxcode{\sphinxupquote{adata.var\_names}}

\item {} 
\sphinxstylestrong{time\_info}: list of time annotation in string, shape (n\_cell,), mandatory, stored at \sphinxcode{\sphinxupquote{adata.obs{[}\textquotesingle{}time\_info\textquotesingle{}{]}}}

\item {} 
\sphinxstylestrong{X\_clone}: clonal label for each cell in the form of np.array or sparse matrix, shape (n\_cell, n\_clone), optional, stored at \sphinxcode{\sphinxupquote{adata.obsm{[}\textquotesingle{}X\_clone\textquotesingle{}{]}}}

\item {} 
\sphinxstylestrong{X\_pca}: PCA matrixs, shape (n\_cell, n\_pcs), optional, stored at \sphinxcode{\sphinxupquote{adata.obsm{[}\textquotesingle{}X\_pca\textquotesingle{}{]}}}

\item {} 
\sphinxstylestrong{X\_emb}: two\sphinxhyphen{}dimensional embedding, shape (n\_cell, 2), optional, stored at \sphinxcode{\sphinxupquote{adata.obsm{[}\textquotesingle{}X\_emb\textquotesingle{}{]}}}

\item {} 
\sphinxstylestrong{state\_info}: state annotation for each cell, shape (n\_cell, 1), optional, stored at \sphinxcode{\sphinxupquote{adata.obsm{[}\textquotesingle{}state\_info\textquotesingle{}{]}}}

\end{itemize}

The clonal data \sphinxcode{\sphinxupquote{X\_clone}} is optional. If not provided, cospar generates the transition map based on state information only. A clone means a barcode that labels cells. We allow a cell have multiple barcodes, thus belonging to multiple clones.

\sphinxcode{\sphinxupquote{X\_pca}}, \sphinxcode{\sphinxupquote{X\_emb}}, and \sphinxcode{\sphinxupquote{state\_info}} are also optional. They can be generated in downstream preprocessing and dimension reduction steps.

We provide a function to help initializing this object. We mimic this step by loading a preprocessed dataset, extracting each component, and then re\sphinxhyphen{}assembling them using our initialization function.

Load an existing dataset (if you have pre\sphinxhyphen{}processed data, you can load it with \sphinxcode{\sphinxupquote{cs.hf.read(file\_name)}})

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[4]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{adata\PYGZus{}orig\PYGZus{}0}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{datasets}\PYG{o}{.}\PYG{n}{hematopoiesis\PYGZus{}subsampled}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}
}

Extract each component

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[5]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{c+c1}{\PYGZsh{} This is just a name to indicate this data.}
\PYG{c+c1}{\PYGZsh{} Will be used to name the saved results. Can be arbitrary.}
\PYG{n}{data\PYGZus{}des}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blood}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{n}{RNA\PYGZus{}count\PYGZus{}matrix}\PYG{o}{=}\PYG{n}{adata\PYGZus{}orig\PYGZus{}0}\PYG{o}{.}\PYG{n}{X} \PYG{c+c1}{\PYGZsh{} np.array or sparse matrix, shape (n\PYGZus{}cell, n\PYGZus{}gene)}
\PYG{n}{gene\PYGZus{}names}\PYG{o}{=}\PYG{n}{adata\PYGZus{}orig\PYGZus{}0}\PYG{o}{.}\PYG{n}{var\PYGZus{}names} \PYG{c+c1}{\PYGZsh{} List of gene names, shape (n\PYGZus{}genes,)}

\PYG{c+c1}{\PYGZsh{} Clonal data matrix, np.array or sparse matrix, shape: (n\PYGZus{}cell, n\PYGZus{}clone)}
\PYG{n}{X\PYGZus{}clone}\PYG{o}{=}\PYG{n}{adata\PYGZus{}orig\PYGZus{}0}\PYG{o}{.}\PYG{n}{obsm}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X\PYGZus{}clone}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} 2\PYGZhy{}d embedding, np.array, shape: (n\PYGZus{}cell, 2)}
\PYG{n}{X\PYGZus{}emb}\PYG{o}{=}\PYG{n}{adata\PYGZus{}orig\PYGZus{}0}\PYG{o}{.}\PYG{n}{obsm}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X\PYGZus{}emb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} A vector of cluster id for each cell, np.array, shape: (n\PYGZus{}cell, 2),}
\PYG{n}{state\PYGZus{}info}\PYG{o}{=}\PYG{n}{adata\PYGZus{}orig\PYGZus{}0}\PYG{o}{.}\PYG{n}{obs}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{state\PYGZus{}info}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} principle component matrix, np.array, shape: (n\PYGZus{}cell, n\PYGZus{}pcs)}
\PYG{n}{X\PYGZus{}pca}\PYG{o}{=}\PYG{n}{adata\PYGZus{}orig\PYGZus{}0}\PYG{o}{.}\PYG{n}{obsm}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X\PYGZus{}pca}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} A vector of time info, np.array of string, shape: (n\PYGZus{}cell,)}
\PYG{n}{time\PYGZus{}info}\PYG{o}{=}\PYG{n}{adata\PYGZus{}orig\PYGZus{}0}\PYG{o}{.}\PYG{n}{obs}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{time\PYGZus{}info}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\end{sphinxVerbatim}
}

Now, initialize the adata object

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[6]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{adata\PYGZus{}orig}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pp}\PYG{o}{.}\PYG{n}{initialize\PYGZus{}adata\PYGZus{}object}\PYG{p}{(}\PYG{n}{RNA\PYGZus{}count\PYGZus{}matrix}\PYG{p}{,}\PYG{n}{gene\PYGZus{}names}\PYG{p}{,}\PYG{n}{time\PYGZus{}info}\PYG{p}{,}
     \PYG{n}{X\PYGZus{}clone}\PYG{o}{=}\PYG{n}{X\PYGZus{}clone}\PYG{p}{,}\PYG{n}{X\PYGZus{}pca}\PYG{o}{=}\PYG{n}{X\PYGZus{}pca}\PYG{p}{,}\PYG{n}{X\PYGZus{}emb}\PYG{o}{=}\PYG{n}{X\PYGZus{}emb}\PYG{p}{,}\PYG{n}{state\PYGZus{}info}\PYG{o}{=}\PYG{n}{state\PYGZus{}info}\PYG{p}{,}\PYG{n}{data\PYGZus{}des}\PYG{o}{=}\PYG{n}{data\PYGZus{}des}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
All time points: \{'4', '6', '2'\}
Time points with clonal info: \{'4', '6', '2'\}
\end{sphinxVerbatim}
}

This is the structure of the initialized adata object

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[7]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{adata\PYGZus{}orig}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxout}[7]:\,\hspace{\fboxrule}\hspace{\fboxsep}}AnnData object with n\_obs × n\_vars = 7438 × 25289
    obs: 'time\_info', 'state\_info'
    uns: 'data\_des', 'clonal\_time\_points'
    obsm: 'X\_clone', 'X\_pca', 'X\_emb'
\end{sphinxVerbatim}
}


\subsection{Preprocessing and dimension reduction (optional)}
\label{\detokenize{20210121_cospar_tutorial:Preprocessing-and-dimension-reduction-(optional)}}
If the data do not yet have one of \sphinxcode{\sphinxupquote{X\_pca}}, \sphinxcode{\sphinxupquote{X\_emb}}, or \sphinxcode{\sphinxupquote{state\_info}}, you will need to run the preprocessing and dimension reduction.

Select highly variable genes. Before this, there is count normalization.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[8]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pp}\PYG{o}{.}\PYG{n}{get\PYGZus{}highly\PYGZus{}variable\PYGZus{}genes}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{normalized\PYGZus{}counts\PYGZus{}per\PYGZus{}cell}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{,}\PYG{n}{min\PYGZus{}counts}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,}
        \PYG{n}{min\PYGZus{}cells}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{min\PYGZus{}gene\PYGZus{}vscore\PYGZus{}pctl}\PYG{o}{=}\PYG{l+m+mi}{85}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Finding highly variable genes{\ldots}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=278\sphinxpxdimen,height=220\sphinxpxdimen]{{20210121_cospar_tutorial_18_1}.png}

\end{nbsphinxfancyoutput}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Keeping 2489 genes
\end{sphinxVerbatim}
}

Compute for each gene its correlation with a set of cell cycle genes. There is a default cell cycle gene set for mouse. You might need to use your own genes. This step is optional, but recommended.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[9]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pp}\PYG{o}{.}\PYG{n}{remove\PYGZus{}cell\PYGZus{}cycle\PYGZus{}correlated\PYGZus{}genes}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
adata.var['highly\_variable'] not updated.
Please choose corr\_threshold properly, and set confirm\_change=True
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=296\sphinxpxdimen,height=248\sphinxpxdimen]{{20210121_cospar_tutorial_20_1}.png}

\end{nbsphinxfancyoutput}

Now, actually confirm the change at a specific cutoff threshold.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[10]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pp}\PYG{o}{.}\PYG{n}{remove\PYGZus{}cell\PYGZus{}cycle\PYGZus{}correlated\PYGZus{}genes}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{corr\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{,}\PYG{n}{confirm\PYGZus{}change}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Number of selected non-cycling highly variable genes: 2481
Remove 8 cell cycle correlated genes.
adata.var['highly\_variable'] updated
\end{sphinxVerbatim}
}

Compute the \sphinxcode{\sphinxupquote{X\_pca}}, \sphinxcode{\sphinxupquote{X\_emb}}, and \sphinxcode{\sphinxupquote{state\_info}} (from clustering).

\sphinxcode{\sphinxupquote{X\_pca}} will be used to build the similarity matrix later. \sphinxcode{\sphinxupquote{X\_emb}} is only used for visualization. You can also pass your favoriate embedding directly to \sphinxcode{\sphinxupquote{adata.obsm{[}\textquotesingle{}X\_emb\textquotesingle{}{]}}}.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[11]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{update}\PYG{o}{=}\PYG{k+kc}{False}
\PYG{k}{if} \PYG{n}{update}\PYG{p}{:}
    \PYG{n}{cs}\PYG{o}{.}\PYG{n}{pp}\PYG{o}{.}\PYG{n}{get\PYGZus{}X\PYGZus{}pca}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{n\PYGZus{}pca\PYGZus{}comp}\PYG{o}{=}\PYG{l+m+mi}{40}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}cs.pp.get\PYGZus{}X\PYGZus{}emb(adata\PYGZus{}orig,n\PYGZus{}neighbors=20,umap\PYGZus{}min\PYGZus{}dist=0.3) \PYGZsh{}Do not run this, as we want to keep the original embedding}
    \PYG{c+c1}{\PYGZsh{}cs.pp.get\PYGZus{}state\PYGZus{}info(adata\PYGZus{}orig,leiden\PYGZus{}resolution=0.5) \PYGZsh{} Do not run this, as we want to keep the original state annotation.}
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[12]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{embedding}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{state\PYGZus{}info}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=470\sphinxpxdimen,height=274\sphinxpxdimen]{{20210121_cospar_tutorial_25_0}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[13]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{hf}\PYG{o}{.}\PYG{n}{check\PYGZus{}available\PYGZus{}choices}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Available transition maps: []
Availabel clusters: ['undiff', 'pDC', 'Erythroid', 'Neutrophil', 'Meg', 'Neu\_Mon', 'Lymphoid', 'Ccr7\_DC', 'Eos', 'Monocyte', 'Mast', 'Baso']
Availabel time points: ['4', '6', '2']
Clonal time points: ['4', '6', '2']
\end{sphinxVerbatim}
}

You can choose to save preprocessed data. It can be loaded using \sphinxcode{\sphinxupquote{cs.hf.read(file\_name)}}.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[14]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{save}\PYG{o}{=}\PYG{k+kc}{False}
\PYG{k}{if} \PYG{n}{save}\PYG{p}{:}
    \PYG{n}{cs}\PYG{o}{.}\PYG{n}{hf}\PYG{o}{.}\PYG{n}{save\PYGZus{}preprocessed\PYGZus{}adata}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{)}
\end{sphinxVerbatim}
}


\subsubsection{Raw clonal data analysis (without using state information)}
\label{\detokenize{20210121_cospar_tutorial:Raw-clonal-data-analysis-(without-using-state-information)}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[15]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{clones\PYGZus{}on\PYGZus{}manifold}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{selected\PYGZus{}clone\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{n}{color\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{black}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{point\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=247\sphinxpxdimen,height=184\sphinxpxdimen]{{20210121_cospar_tutorial_30_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=247\sphinxpxdimen,height=184\sphinxpxdimen]{{20210121_cospar_tutorial_30_1}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=247\sphinxpxdimen,height=184\sphinxpxdimen]{{20210121_cospar_tutorial_30_2}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[16]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{plot\PYGZus{}time\PYGZus{}point}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{4}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Erythroid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mast}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Neutrophil}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Monocyte}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Lymphoid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ccr7\PYGZus{}DC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Baso}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}  \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pDC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Eos}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Meg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}coupling\PYGZus{}from\PYGZus{}clones}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{plot\PYGZus{}time\PYGZus{}point}\PYG{p}{,} \PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{n}{selected\PYGZus{}fates}\PYG{p}{,} \PYG{n}{color\PYGZus{}bar}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=358\sphinxpxdimen,height=283\sphinxpxdimen]{{20210121_cospar_tutorial_31_0}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[17]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{plot\PYGZus{}time\PYGZus{}point}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{4}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{barcode\PYGZus{}heatmap}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{plot\PYGZus{}time\PYGZus{}point}\PYG{p}{,} \PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{n}{selected\PYGZus{}fates}\PYG{p}{,} \PYG{n}{color\PYGZus{}bar}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=284\sphinxpxdimen,height=433\sphinxpxdimen]{{20210121_cospar_tutorial_32_0}.png}

\end{nbsphinxfancyoutput}

This step is slow and optional. The time is linearly proportional to the multiplication of clone number and N\_resampling. It takes half a minute for the given parameters.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[18]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{select\PYGZus{}fate\PYGZus{}cluster}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Monocyte}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{clonal\PYGZus{}fate\PYGZus{}bias}\PYG{p}{,}\PYG{n}{clone\PYGZus{}id}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{clonal\PYGZus{}fate\PYGZus{}bias}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{select\PYGZus{}fate\PYGZus{}cluster}\PYG{p}{,}
            \PYG{n}{clone\PYGZus{}size\PYGZus{}thresh}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{n}{N\PYGZus{}resampling}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{n}{compute\PYGZus{}new}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=283\sphinxpxdimen,height=246\sphinxpxdimen]{{20210121_cospar_tutorial_34_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=302\sphinxpxdimen,height=265\sphinxpxdimen]{{20210121_cospar_tutorial_34_1}.png}

\end{nbsphinxfancyoutput}


\subsection{Transition map inference}
\label{\detokenize{20210121_cospar_tutorial:Transition-map-inference}}
As mentioned in \sphinxstylestrong{Getting Started}, there are several methods for map inference. Below, we illustrate the one that uses multiple clonal time points and integrate state and clonal information together.

The first time it runs, it will compute the similarity matrix at different smooth rounds and save them. Then, it will infer the transition map. It takes 2 mins to run for the first time, and 11 s for later runs.

Some key parameters: * \sphinxstylestrong{smooth\_array}: a list of numbers defining the smooth rounds at each iteration of coherent sparsity optimization. Its length determins the number of iteration. We found that 3 rounds of iteration is generally sufficient. It is better to use a number at the multiple of 5, i.e., 5, 10, 15, 20,…
\begin{itemize}
\item {} 
\sphinxstylestrong{noise\_threshold}: noise threshold to remove spurious transitions in the updated transition map, in the range {[}0,1{]}.

\end{itemize}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[19]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{noise\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mf}{0.2} \PYG{c+c1}{\PYGZsh{}}
\PYG{n}{selected\PYGZus{}clonal\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{6}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{adata}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{tmap}\PYG{o}{.}\PYG{n}{infer\PYGZus{}Tmap\PYGZus{}from\PYGZus{}multitime\PYGZus{}clones}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{selected\PYGZus{}clonal\PYGZus{}time\PYGZus{}points}\PYG{p}{,}\PYG{n}{smooth\PYGZus{}array}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{15}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,}
        \PYG{n}{noise\PYGZus{}threshold}\PYG{o}{=}\PYG{n}{noise\PYGZus{}threshold}\PYG{p}{,}\PYG{n}{demulti\PYGZus{}threshold}\PYG{o}{=}\PYG{n}{noise\PYGZus{}threshold}\PYG{p}{,}\PYG{n}{use\PYGZus{}full\PYGZus{}Smatrix}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
-------Step 1: Select time points---------
--> Clonal cell fraction (day 2-4): 1.0
--> Clonal cell fraction (day 4-6): 1.0
--> Clonal cell fraction (day 4-2): 0.3892466194462331
--> Clonal cell fraction (day 6-4): 1.0
--> Numer of cells that are clonally related -- day 2: 286  and day 4: 1209
--> Numer of cells that are clonally related -- day 4: 3106  and day 6: 4046
Valid clone number 'FOR' post selection 500
Cell number=7438, Clone number=500
-------Step 2: Compute the full Similarity matrix if necessary---------
-------Step 3: Optimize the transition map recursively---------
---------Compute the transition map-----------
Compute similarity matrix: load existing data
--> Time elapsed:  0.10666298866271973
--> Time elapsed:  0.330460786819458
--> Time elapsed:  0.09987902641296387
--> Time elapsed:  0.3382446765899658
Compute similarity matrix: load existing data
--> Time elapsed:  0.09616303443908691
--> Time elapsed:  0.27065300941467285
--> Time elapsed:  0.08978414535522461
--> Time elapsed:  0.3071787357330322
Compute similarity matrix: load existing data
--> Time elapsed:  0.06744384765625
--> Time elapsed:  0.2183530330657959
--> Time elapsed:  0.06598091125488281
--> Time elapsed:  0.19800972938537598
Current iteration: 0
Use smooth\_round=20
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
--> Relative time point pair index: 1
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  0.5561578273773193
Phase II: time elapsed --  1.0665109157562256
Current iteration: 1
Use smooth\_round=15
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
--> Relative time point pair index: 1
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  0.45022106170654297
Phase II: time elapsed --  0.8973500728607178
Current iteration: 2
Use smooth\_round=10
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
--> Relative time point pair index: 1
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  0.45832180976867676
Phase II: time elapsed --  0.9774909019470215
No need for Final Smooth (i.e., clonally states are the final state space for Tmap)
----Demultiplexed transition map----
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
--> Relative time point pair index: 1
--> Clone id: 0
-----------Total used time: 14.393146991729736 s ------------
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=363\sphinxpxdimen,height=241\sphinxpxdimen]{{20210121_cospar_tutorial_38_1}.png}

\end{nbsphinxfancyoutput}

We can see that after this step, we have two maps: \sphinxcode{\sphinxupquote{\textquotesingle{}transition\_map\textquotesingle{}}} and \sphinxcode{\sphinxupquote{\textquotesingle{}intraclone\_transition\_map\textquotesingle{}}}. Both of them can be used for downstream analysis.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[20]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{hf}\PYG{o}{.}\PYG{n}{check\PYGZus{}available\PYGZus{}choices}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Available transition maps: ['transition\_map', 'intraclone\_transition\_map']
Availabel clusters: ['undiff', 'pDC', 'Erythroid', 'Neutrophil', 'Meg', 'Neu\_Mon', 'Lymphoid', 'Ccr7\_DC', 'Eos', 'Monocyte', 'Mast', 'Baso']
Availabel time points: ['4', '6', '2']
Clonal time points: ['4', '6', '2']
\end{sphinxVerbatim}
}


\subsection{Save or load pre\sphinxhyphen{}computed data}
\label{\detokenize{20210121_cospar_tutorial:Save-or-load-pre-computed-data}}
This can be used to save adata with maps computed from different tools or parameters. Usually, different parameter choices will result in different ‘data\_des’, a prefix to identify the anndata. Saving an adata would print the ‘data\_des’, which can be used to load the corresponding adata.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[21]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{save\PYGZus{}data}\PYG{o}{=}\PYG{k+kc}{False}
\PYG{k}{if} \PYG{n}{save\PYGZus{}data}\PYG{p}{:}
    \PYG{n}{cs}\PYG{o}{.}\PYG{n}{hf}\PYG{o}{.}\PYG{n}{save\PYGZus{}map}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{)}

\PYG{n}{load\PYGZus{}data}\PYG{o}{=}\PYG{k+kc}{False}
\PYG{k}{if} \PYG{n}{load\PYGZus{}data}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} updated Jan 27, 2021}
    \PYG{c+c1}{\PYGZsh{}data\PYGZus{}des=\PYGZsq{}blood\PYGZus{}TwoTimeClone\PYGZus{}t*4*6\PYGZsq{}}
    \PYG{n}{data\PYGZus{}des}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blood\PYGZus{}TwoTimeClone\PYGZus{}t*2*4*6}\PYG{l+s+s1}{\PYGZsq{}}
    \PYG{c+c1}{\PYGZsh{}data\PYGZus{}des=\PYGZsq{}LARRY\PYGZus{}sp500\PYGZus{}ranking1\PYGZus{}TwoTimeClone\PYGZus{}t*4*6\PYGZsq{}}
    \PYG{c+c1}{\PYGZsh{}data\PYGZus{}des=\PYGZsq{}LARRY\PYGZus{}sp500\PYGZus{}ranking1\PYGZus{}TwoTimeClone\PYGZus{}t*2*4*6\PYGZsq{}}
    \PYG{c+c1}{\PYGZsh{}data\PYGZus{}des=\PYGZsq{}LARRY\PYGZus{}sp500\PYGZus{}ranking1\PYGZus{}OneTimeClone\PYGZus{}t*4*6\PYGZsq{}}
    \PYG{n}{adata}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{hf}\PYG{o}{.}\PYG{n}{load\PYGZus{}saved\PYGZus{}adata\PYGZus{}with\PYGZus{}key}\PYG{p}{(}\PYG{n}{data\PYGZus{}des}\PYG{p}{)}
\end{sphinxVerbatim}
}


\subsection{Plotting}
\label{\detokenize{20210121_cospar_tutorial:Plotting}}
There are some common parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{used\_map\_name}} (str). Determines which transition map to use for analysis. Choices: \{‘transition\_map’, ‘intraclone\_transition\_map’, ‘OT\_transition\_map’, ‘HighVar\_transition\_map’,’clonal\_transition\_map’\}

\item {} 
\sphinxcode{\sphinxupquote{selected\_fates}} (list of str). Selected clusters to aggregate differentiation dynamics and visualize fate bias etc.. The selected\_fates allows nested structure, e.g., selected\_fates={[}‘1’, {[}‘0’, ‘2’{]}{]} selects two clusters: cluster ‘1’ and the other that combines ‘0’ and ‘2’.

\item {} 
\sphinxcode{\sphinxupquote{map\_backwards}} (bool). We can analyze either the forward transitions, i.e., where the selected states or clusters are going (map\_backwards=False), or the backward transitions, i.e., where these selected states or clusters came from (map\_backwards=False). The latter is more useful, and is the default.

\item {} 
\sphinxcode{\sphinxupquote{plot\_time\_points}} (list). List of time points to use. By default, all are used.

\end{itemize}


\subsubsection{Plotting transition profiles for single cells}
\label{\detokenize{20210121_cospar_tutorial:Plotting-transition-profiles-for-single-cells}}
First, check the forward transitions (i.e., future states) from the \sphinxcode{\sphinxupquote{\textquotesingle{}transition\_map\textquotesingle{}}}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[22]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{selected\PYGZus{}state\PYGZus{}id\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}

\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{False}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{single\PYGZus{}cell\PYGZus{}transition}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}state\PYGZus{}id\PYGZus{}list}\PYG{o}{=}\PYG{n}{selected\PYGZus{}state\PYGZus{}id\PYGZus{}list}\PYG{p}{,}
                                    \PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{n}{map\PYGZus{}backwards}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=281\sphinxpxdimen,height=433\sphinxpxdimen]{{20210121_cospar_tutorial_46_0}.png}

\end{nbsphinxfancyoutput}

Now, backward transitions (i.e., past states) from the same map

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[23]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{selected\PYGZus{}state\PYGZus{}id\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{single\PYGZus{}cell\PYGZus{}transition}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}state\PYGZus{}id\PYGZus{}list}\PYG{o}{=}\PYG{n}{selected\PYGZus{}state\PYGZus{}id\PYGZus{}list}\PYG{p}{,}
                                    \PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{n}{map\PYGZus{}backwards}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=281\sphinxpxdimen,height=433\sphinxpxdimen]{{20210121_cospar_tutorial_48_0}.png}

\end{nbsphinxfancyoutput}

Finally, switch to the \sphinxcode{\sphinxupquote{\textquotesingle{}intraclone\_transition\_map\textquotesingle{}}}, and check backward transitions. We can see that the second id (5) does not have corresponding clonally related initial states

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[24]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{selected\PYGZus{}state\PYGZus{}id\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{single\PYGZus{}cell\PYGZus{}transition}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}state\PYGZus{}id\PYGZus{}list}\PYG{o}{=}\PYG{n}{selected\PYGZus{}state\PYGZus{}id\PYGZus{}list}\PYG{p}{,}
                                    \PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{intraclone\PYGZus{}transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{n}{map\PYGZus{}backwards}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=281\sphinxpxdimen,height=433\sphinxpxdimen]{{20210121_cospar_tutorial_50_0}.png}

\end{nbsphinxfancyoutput}


\subsubsection{Fate map}
\label{\detokenize{20210121_cospar_tutorial:Fate-map}}
Inspect the backward transitions, and ask where the selected fate clusters are at the previous time point

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[25]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}map}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Neutrophil}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Monocyte}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
               \PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=288\sphinxpxdimen,height=435\sphinxpxdimen]{{20210121_cospar_tutorial_53_0}.png}

\end{nbsphinxfancyoutput}

Now, do the same thing with \sphinxcode{\sphinxupquote{\textquotesingle{}intraclone\_transition\_map\textquotesingle{}}}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[26]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}map}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Neutrophil}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Monocyte}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
               \PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{intraclone\PYGZus{}transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=288\sphinxpxdimen,height=435\sphinxpxdimen]{{20210121_cospar_tutorial_55_0}.png}

\end{nbsphinxfancyoutput}

As a comparison, if we use only the clonal information to construct the transition map, this is what is looks like:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[27]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{tmap}\PYG{o}{.}\PYG{n}{infer\PYGZus{}Tmap\PYGZus{}from\PYGZus{}clonal\PYGZus{}info\PYGZus{}alone}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{method}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{weinreb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}map}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Neutrophil}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Monocyte}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
               \PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{clonal\PYGZus{}transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Used uni-potent clone fraction 0.472
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=288\sphinxpxdimen,height=435\sphinxpxdimen]{{20210121_cospar_tutorial_57_1}.png}

\end{nbsphinxfancyoutput}


\subsubsection{Relative fate bias}
\label{\detokenize{20210121_cospar_tutorial:Relative-fate-bias}}
\begin{DUlineblock}{0em}
\item[] First, check the intrinsic fate bias of initial states, which is basically the predicted fate map normalized by the expected fate probability. The null expectation is
\item[] is the fraction of cells at later time point that are in the corresponding cluster. A state has an intrinsic fate bias for each fate cluster.
\end{DUlineblock}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[28]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}bias\PYGZus{}intrinsic}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Monocyte}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Neutrophil}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{intraclone\PYGZus{}transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
            \PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=528\sphinxpxdimen,height=230\sphinxpxdimen]{{20210121_cospar_tutorial_60_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=600\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_cospar_tutorial_60_1}.png}

\end{nbsphinxfancyoutput}

Next, check the fate bias of initial states defined by competition between two fate clusters A and B, i.e., how strongly A is favored than B.

Only states with fate probabilities satisfying this criterion will be shown:
\begin{itemize}
\item {} 
P(A)+P(B)\textgreater{}sum\_fate\_prob\_thresh

\end{itemize}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[29]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}bias\PYGZus{}from\PYGZus{}binary\PYGZus{}competition}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Monocyte}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Neutrophil}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{intraclone\PYGZus{}transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
            \PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{sum\PYGZus{}fate\PYGZus{}prob\PYGZus{}thresh}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=315\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_cospar_tutorial_62_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=302\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_cospar_tutorial_62_1}.png}

\end{nbsphinxfancyoutput}


\subsubsection{Dynamic trajectory inference}
\label{\detokenize{20210121_cospar_tutorial:Dynamic-trajectory-inference}}
One way to define the dynamic trajectory is simply mapping a given fate cluster backward in time. The whole trajectory across multiple time points will be saved at \sphinxcode{\sphinxupquote{adata.uns{[}\textquotesingle{}dynamic\_trajectory\textquotesingle{}{]}}}. This method performs best if there are multiple clonal time points.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[30]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{dynamic\PYGZus{}trajectory\PYGZus{}via\PYGZus{}iterative\PYGZus{}mapping}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fate}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Neutrophil}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{plot\PYGZus{}separately}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{intraclone\PYGZus{}transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=733\sphinxpxdimen,height=237\sphinxpxdimen]{{20210121_cospar_tutorial_65_0}.png}

\end{nbsphinxfancyoutput}

In the second approach, we use the intrinsic fate bias to define the dynamic trajectory and also the ancestor population. It requires input of two selected fates A and B, and states with bias for A higher than bias\_threshold\_A will be selected as ancestor states for fate A; so does for fate B. The selected cell states will be stored at \sphinxcode{\sphinxupquote{adata.uns{[}\textquotesingle{}Cell\_group\_A\textquotesingle{}{]}}} and \sphinxcode{\sphinxupquote{adata.uns{[}\textquotesingle{}Cell\_group\_B\textquotesingle{}{]}}}. The selected states along with the corresponding fate cluster will be stored at
\sphinxcode{\sphinxupquote{adata.uns{[}\textquotesingle{}dynamic\_trajectory\textquotesingle{}{]}}} for inspecting dynamic gene expression.

Setting \sphinxcode{\sphinxupquote{avoid\_target\_states=True}} will remove ancestor states already inside the given fate cluster.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[31]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{dynamic\PYGZus{}trajectory\PYGZus{}from\PYGZus{}intrinsic\PYGZus{}bias}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,} \PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Neutrophil}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Monocyte}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
 \PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{intraclone\PYGZus{}transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}
    \PYG{n}{bias\PYGZus{}threshold\PYGZus{}A}\PYG{o}{=}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{n}{bias\PYGZus{}threshold\PYGZus{}B}\PYG{o}{=}\PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{n}{avoid\PYGZus{}target\PYGZus{}states}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=583\sphinxpxdimen,height=283\sphinxpxdimen]{{20210121_cospar_tutorial_67_0}.png}

\end{nbsphinxfancyoutput}

We can also infer the dynamic trajectory and ancestor population using the fate bias from binary fate competition. Here, fate bias is a scalar between (0,1) at each state. Selected ancestor population satisfies:
\begin{itemize}
\item {} 
Prob(A)+Prob(B)\textgreater{}sum\_fate\_prob\_thresh;

\item {} 
Ancestor states for A: Bias\textgreater{}0.5+bias\_threshold

\item {} 
Ancestor states for B: bias\textless{}0.5+bias\_threshold

\end{itemize}

They will be stored at \sphinxcode{\sphinxupquote{adata.uns{[}\textquotesingle{}Cell\_group\_A\textquotesingle{}{]}}} and \sphinxcode{\sphinxupquote{adata.uns{[}\textquotesingle{}Cell\_group\_B\textquotesingle{}{]}}}. The selected states along with the corresponding fate cluster will be stored at \sphinxcode{\sphinxupquote{adata.uns{[}\textquotesingle{}dynamic\_trajectory\textquotesingle{}{]}}} for inspecting dynamic gene expression.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[32]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{dynamic\PYGZus{}trajectory\PYGZus{}from\PYGZus{}competition\PYGZus{}bias}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,} \PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Neutrophil}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Monocyte}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
 \PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{intraclone\PYGZus{}transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}
    \PYG{n}{bias\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{sum\PYGZus{}fate\PYGZus{}prob\PYGZus{}thresh}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{n}{avoid\PYGZus{}target\PYGZus{}states}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=583\sphinxpxdimen,height=283\sphinxpxdimen]{{20210121_cospar_tutorial_69_0}.png}

\end{nbsphinxfancyoutput}


\subsubsection{Differential genes for two ancestor groups}
\label{\detokenize{20210121_cospar_tutorial:Differential-genes-for-two-ancestor-groups}}
It would be interesting to see what genes are differentially expressed between these two ancestor population, which might drive the fate bifurcation.

The two population can be accessed at \sphinxcode{\sphinxupquote{adata.obs{[}\textquotesingle{}Cell\_group\_A\textquotesingle{}{]}}} and \sphinxcode{\sphinxupquote{adata.obs{[}\textquotesingle{}Cell\_group\_B\textquotesingle{}{]}}}. We provide a simple differentiation gene expression analysis that use Wilcoxon rank\sphinxhyphen{}sum test to calculate P values, followed by Benjamini\sphinxhyphen{}Hochberg correction. You can always use your own method.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[33]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{c+c1}{\PYGZsh{} This step requires that adata.obs[\PYGZsq{}Cell\PYGZus{}group\PYGZus{}A\PYGZsq{}] and adata.obs[\PYGZsq{}Cell\PYGZus{}group\PYGZus{}B\PYGZsq{}] exist.}
\PYG{n}{dge\PYGZus{}gene\PYGZus{}A}\PYG{p}{,} \PYG{n}{dge\PYGZus{}gene\PYGZus{}B}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{differential\PYGZus{}genes}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{plot\PYGZus{}gene\PYGZus{}N}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=583\sphinxpxdimen,height=283\sphinxpxdimen]{{20210121_cospar_tutorial_72_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=709\sphinxpxdimen,height=171\sphinxpxdimen]{{20210121_cospar_tutorial_72_1}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=709\sphinxpxdimen,height=171\sphinxpxdimen]{{20210121_cospar_tutorial_72_2}.png}

\end{nbsphinxfancyoutput}


\subsubsection{Gene trend along the dynamic trajectory}
\label{\detokenize{20210121_cospar_tutorial:Gene-trend-along-the-dynamic-trajectory}}
Any one of the 3 dynamic trajectory inference methods will save the trajectory at \sphinxcode{\sphinxupquote{adata.uns{[}\textquotesingle{}dynamic\_trajectory\textquotesingle{}{]}}}. We can calculate the pseudotime along this trajectory and plot the gene expression along this pseudo time.

This method requires that \sphinxcode{\sphinxupquote{adata.uns{[}\textquotesingle{}dynamic\_trajectory\textquotesingle{}{]}}} exists, and the selected fate is in the pre\sphinxhyphen{}computed list.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[34]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{gene\PYGZus{}name\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Gata1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mpo}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Elane}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{S100a8}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{selected\PYGZus{}fate}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Neutrophil}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{adata\PYGZus{}selected}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{gene\PYGZus{}expression\PYGZus{}dynamics}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fate}\PYG{p}{,}\PYG{n}{gene\PYGZus{}name\PYGZus{}list}\PYG{p}{,} \PYG{n}{traj\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{,}
      \PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{invert\PYGZus{}PseudoTime}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{include\PYGZus{}target\PYGZus{}states}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{compute\PYGZus{}new}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}
    \PYG{n}{fig\PYGZus{}width}\PYG{o}{=}\PYG{l+m+mf}{3.5}\PYG{p}{,} \PYG{n}{gene\PYGZus{}exp\PYGZus{}percentile}\PYG{o}{=}\PYG{l+m+mi}{99}\PYG{p}{,} \PYG{n}{n\PYGZus{}neighbors}\PYG{o}{=}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{n}{plot\PYGZus{}raw\PYGZus{}data}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{point\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{nbsphinx-stderr}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
/Users/shouwenwang/miniconda3/envs/CoSpar\_env/lib/python3.6/site-packages/plotnine/ggplot.py:729: PlotnineWarning: Saving 3.5 x 2.163 in image.
/Users/shouwenwang/miniconda3/envs/CoSpar\_env/lib/python3.6/site-packages/plotnine/ggplot.py:730: PlotnineWarning: Filename: fig\_path/blood\_TwoTimeClone\_t*2*4*6\_fate\_trajectory\_pseutoTime\_gene\_expression\_Neutrophil\_True.png
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=718\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_cospar_tutorial_76_1}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=695\sphinxpxdimen,height=429\sphinxpxdimen]{{20210121_cospar_tutorial_76_2}.png}

\end{nbsphinxfancyoutput}

The method outputs a new adata object with the selected cell states. This can be used to run your favoriate pseudotime analysis methods.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[35]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{embedding}\PYG{p}{(}\PYG{n}{adata\PYGZus{}selected}\PYG{p}{,}\PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{state\PYGZus{}info}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{nbsphinx-stderr}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Trying to set attribute `.uns` of view, copying.
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=470\sphinxpxdimen,height=274\sphinxpxdimen]{{20210121_cospar_tutorial_78_1}.png}

\end{nbsphinxfancyoutput}


\subsubsection{Fate coupling of the transition map}
\label{\detokenize{20210121_cospar_tutorial:Fate-coupling-of-the-transition-map}}
The inferred transition map can be used to estimate differentiation coupling between different fate clusters.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[36]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{fate\PYGZus{}array}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ccr7\PYGZus{}DC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mast}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Meg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pDC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Eos}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Lymphoid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Erythroid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Baso}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}  \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Neutrophil}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Monocyte}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{celltype\PYGZus{}names}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mDC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}  \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mast}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Meg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pDC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Eos}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ly}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ery}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Baso}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Neu}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mon}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}coupling\PYGZus{}from\PYGZus{}Tmap}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{n}{fate\PYGZus{}array}\PYG{p}{,}\PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                        \PYG{n}{rename\PYGZus{}selected\PYGZus{}fates}\PYG{o}{=}\PYG{n}{celltype\PYGZus{}names}\PYG{p}{)}

\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=359\sphinxpxdimen,height=283\sphinxpxdimen]{{20210121_cospar_tutorial_81_0}.png}

\end{nbsphinxfancyoutput}


\subsection{Miscellaneous}
\label{\detokenize{20210121_cospar_tutorial:Miscellaneous}}

\subsubsection{Transition map from state information and the last clonal time point}
\label{\detokenize{20210121_cospar_tutorial:Transition-map-from-state-information-and-the-last-clonal-time-point}}
After initializing the map by either \sphinxstyleemphasis{OT} method or \sphinxstyleemphasis{HighVar} method, We jointly infer the likely clonal ancestors and the transition map between cell states in across given time points.

You need to choose the initialization method, and set the corresponding parameters.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{OT}}: optional transport based method. It tends to be more accurate than \sphinxcode{\sphinxupquote{HighVar}}, but not reliable under batch differences between time points. Key parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{OT\_epsilon}} for the entropic regularization

\item {} 
\sphinxcode{\sphinxupquote{OT\_cost}}: \{‘GED’, ‘SPD’\}, method for computing the cost function. ‘GED’ uses simple gene expression distances. It is faster. ‘SPD’ uses the shortest path distances. It is slower, but more accurate.

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{HighVar}}: a method that converts highly variable genes into pseudo clones and run coherent sparsity optimization to generate initialized map. Although it is not as accurate as \sphinxcode{\sphinxupquote{OT}}, it is robust to batch effect across time points, and is used to analyze the lung dataset.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{HighVar\_gene\_pctl}}: percentile threshold to select highly variable genes. Range: {[}0,100{]}. A higher value selects more variable genes.

\end{itemize}

\end{itemize}

Let us try the OT method that uses gene expression distancs. It takes around 1 min to run.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[37]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{initial\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{}[\PYGZsq{}2\PYGZsq{},\PYGZsq{}4\PYGZsq{}]}
\PYG{n}{clonal\PYGZus{}time\PYGZus{}point}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{6}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{adata}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{tmap}\PYG{o}{.}\PYG{n}{infer\PYGZus{}Tmap\PYGZus{}from\PYGZus{}one\PYGZus{}time\PYGZus{}clones}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{initial\PYGZus{}time\PYGZus{}points}\PYG{p}{,}\PYG{n}{clonal\PYGZus{}time\PYGZus{}point}\PYG{p}{,}\PYG{n}{Clone\PYGZus{}update\PYGZus{}iter\PYGZus{}N}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}
        \PYG{n}{initialize\PYGZus{}method}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{OT}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{OT\PYGZus{}cost}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{GED}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{smooth\PYGZus{}array}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{15}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,}\PYG{n}{noise\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{,}\PYG{n}{use\PYGZus{}full\PYGZus{}Smatrix}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
-------------------------------New Start--------------------------------------------------
Current time point: 4
-----------Pre-processing and sub-sampling cells------------
----------------
Step 1: Use OT method for initialization
Finishing computing gene expression distance, used time 5.845627307891846
Load pre-computed custon OT matrix
----------------
Step 2: Jointly optimize the transition map and the initial clonal states!
Joint optimization that consider possibility of clonal overlap: v2
--> original clone shape: (7152, 500)
--> After excluding zero-sized clones at t2: (7152, 500)
Sort clones by size (small to large)
Infer the number of initial cells to extract for each clone in advance
--> Inferring early clonal states: current clone id 0
--> Inferring early clonal states: current clone id 100
--> Inferring early clonal states: current clone id 200
--> Inferring early clonal states: current clone id 300
--> Inferring early clonal states: current clone id 400
---------Compute the transition map-----------
Compute similarity matrix: load existing data
--> Time elapsed:  0.07742595672607422
--> Time elapsed:  0.11342000961303711
--> Time elapsed:  0.07841730117797852
--> Time elapsed:  0.1302661895751953
Compute similarity matrix: load existing data
--> Time elapsed:  0.0654458999633789
--> Time elapsed:  0.09871602058410645
--> Time elapsed:  0.07186508178710938
--> Time elapsed:  0.10639524459838867
Compute similarity matrix: load existing data
--> Time elapsed:  0.05588507652282715
--> Time elapsed:  0.08137392997741699
--> Time elapsed:  0.08660697937011719
--> Time elapsed:  0.08424496650695801
Current iteration: 0
Use smooth\_round=20
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  0.35403895378112793
Phase II: time elapsed --  0.7963449954986572
Current iteration: 1
Use smooth\_round=15
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  0.21891403198242188
Phase II: time elapsed --  0.633296012878418
Current iteration: 2
Use smooth\_round=10
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  0.2083740234375
Phase II: time elapsed --  0.5867331027984619
No need for Final Smooth (i.e., clonally states are the final state space for Tmap)
----Demultiplexed transition map----
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Finishing computing transport map from CoSpar using inferred clonal data, used time 10.520820140838623
-----------Total used time: 17.815898895263672 s ------------
\end{sphinxVerbatim}
}

Now, check the result of the initialized map \sphinxcode{\sphinxupquote{OT\_transition\_map}}.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[38]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}bias\PYGZus{}from\PYGZus{}binary\PYGZus{}competition}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Monocyte}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Neutrophil}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
    \PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{OT\PYGZus{}transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}
                                \PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{sum\PYGZus{}fate\PYGZus{}prob\PYGZus{}thresh}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=315\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_cospar_tutorial_89_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=302\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_cospar_tutorial_89_1}.png}

\end{nbsphinxfancyoutput}

After joint optimization, the final result of the transition map is much better:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[39]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}bias\PYGZus{}from\PYGZus{}binary\PYGZus{}competition}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Monocyte}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Neutrophil}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
    \PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}
                                \PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{sum\PYGZus{}fate\PYGZus{}prob\PYGZus{}thresh}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=315\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_cospar_tutorial_91_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=302\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_cospar_tutorial_91_1}.png}

\end{nbsphinxfancyoutput}


\subsubsection{Transition map from state information alone}
\label{\detokenize{20210121_cospar_tutorial:Transition-map-from-state-information-alone}}
This is the same as \sphinxcode{\sphinxupquote{cs.tmap.infer\_Tmap\_from\_one\_time\_clones}}, except that we only compute the initialized map.

Let us try \sphinxcode{\sphinxupquote{HighVar}} method:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[40]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{initial\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{}[\PYGZsq{}2\PYGZsq{},\PYGZsq{}4\PYGZsq{}]}
\PYG{n}{target\PYGZus{}time\PYGZus{}point}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{6}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{adata}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{tmap}\PYG{o}{.}\PYG{n}{infer\PYGZus{}Tmap\PYGZus{}from\PYGZus{}state\PYGZus{}info\PYGZus{}alone}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{initial\PYGZus{}time\PYGZus{}points}\PYG{p}{,}\PYG{n}{target\PYGZus{}time\PYGZus{}point}\PYG{p}{,}
        \PYG{n}{method}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{HighVar}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{HighVar\PYGZus{}gene\PYGZus{}pctl}\PYG{o}{=}\PYG{l+m+mi}{85}\PYG{p}{,}\PYG{n}{smooth\PYGZus{}array}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{15}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,}\PYG{n}{noise\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{,}\PYG{n}{use\PYGZus{}full\PYGZus{}Smatrix}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
-------------------------------New Start--------------------------------------------------
Current time point: 4
-----------Pre-processing and sub-sampling cells------------
----------------
Step 1: Use highly variable genes to construct pseudo-clones, and apply CoSpar to generate initialized map!
HighVar-v0: avoid cells that have been selected
----------------
Step a: find the commonly shared highly variable genes
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=278\sphinxpxdimen,height=220\sphinxpxdimen]{{20210121_cospar_tutorial_94_1}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=278\sphinxpxdimen,height=220\sphinxpxdimen]{{20210121_cospar_tutorial_94_2}.png}

\end{nbsphinxfancyoutput}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Highly varable gene number at t1 is 2136, Highly varable gene number at t2 is 2245
Common gene set is 978
----------------
Step b: convert the shared highly variable genes into clonal info
No cells left for assignment, total used genes=850
----------------
Step c: compute the transition map based on clonal info from highly variable genes
---------Compute the transition map-----------
Compute similarity matrix: load existing data
--> Time elapsed:  0.1092829704284668
--> Time elapsed:  0.14886212348937988
--> Time elapsed:  0.07950091361999512
--> Time elapsed:  0.11178112030029297
Compute similarity matrix: load existing data
--> Time elapsed:  0.06927180290222168
--> Time elapsed:  0.10271787643432617
--> Time elapsed:  0.07293009757995605
--> Time elapsed:  0.10834097862243652
Compute similarity matrix: load existing data
--> Time elapsed:  0.07581591606140137
--> Time elapsed:  0.08312821388244629
--> Time elapsed:  0.0559239387512207
--> Time elapsed:  0.10451817512512207
Current iteration: 0
Use smooth\_round=20
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  0.20914101600646973
Phase II: time elapsed --  0.6100800037384033
Current iteration: 1
Use smooth\_round=15
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  0.1894700527191162
Phase II: time elapsed --  0.5436420440673828
Current iteration: 2
Use smooth\_round=10
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  0.18822312355041504
Phase II: time elapsed --  0.5829341411590576
No need for Final Smooth (i.e., clonally states are the final state space for Tmap)
----Demultiplexed transition map----
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Finishing computing transport map from highly variable genes, used time 26.875142097473145
-----------Total used time: 27.308759212493896 s ------------
\end{sphinxVerbatim}
}

You can see that this method is not as accurate for this dataset.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[41]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}bias\PYGZus{}from\PYGZus{}binary\PYGZus{}competition}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Monocyte}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Neutrophil}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
    \PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{HighVar\PYGZus{}transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}
                                \PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{sum\PYGZus{}fate\PYGZus{}prob\PYGZus{}thresh}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=315\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_cospar_tutorial_96_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=302\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_cospar_tutorial_96_1}.png}

\end{nbsphinxfancyoutput}


\subsubsection{Gene expression}
\label{\detokenize{20210121_cospar_tutorial:Gene-expression}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[42]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{gene\PYGZus{}expression\PYGZus{}on\PYGZus{}manifold}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}genes}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Gata2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mpo}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{color\PYGZus{}bar}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{savefig}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=277\sphinxpxdimen,height=208\sphinxpxdimen]{{20210121_cospar_tutorial_98_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=277\sphinxpxdimen,height=208\sphinxpxdimen]{{20210121_cospar_tutorial_98_1}.png}

\end{nbsphinxfancyoutput}


\subsubsection{Refine state annotation by marker genes}
\label{\detokenize{20210121_cospar_tutorial:Refine-state-annotation-by-marker-genes}}
The goal here is to refine \sphinxcode{\sphinxupquote{adata.obs{[}\textquotesingle{}state\_info\textquotesingle{}{]}}}. First, explore parameters to find satisfactory annotation.

In this method, a state is selected if it expresses all genes in the list of marker\_genes, and the expression are above the relative threshold express\_threshold. You can also specify which time point you want to focus on. In addition, we also include cell states neighboring to these valid states to smooth the selection (controlled by \sphinxcode{\sphinxupquote{add\_neighbor\_N}}).

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[43]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{confirm\PYGZus{}change}\PYG{o}{=}\PYG{k+kc}{False}
\PYG{n}{marker\PYGZus{}genes}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mpo}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Elane}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{S100a8}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pp}\PYG{o}{.}\PYG{n}{refine\PYGZus{}state\PYGZus{}info\PYGZus{}by\PYGZus{}marker\PYGZus{}genes}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{marker\PYGZus{}genes}\PYG{p}{,}
    \PYG{n}{selected\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{new\PYGZus{}cluster\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{new}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{add\PYGZus{}neighbor\PYGZus{}N}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{n}{confirm\PYGZus{}change}\PYG{o}{=}\PYG{n}{confirm\PYGZus{}change}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=247\sphinxpxdimen,height=202\sphinxpxdimen]{{20210121_cospar_tutorial_101_0}.png}

\end{nbsphinxfancyoutput}

Now, confirm changes to \sphinxcode{\sphinxupquote{adata.obs{[}\textquotesingle{}state\_info\textquotesingle{}{]}}}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[44]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{confirm\PYGZus{}change}\PYG{o}{=}\PYG{k+kc}{True}
\PYG{n}{marker\PYGZus{}genes}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mpo}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Elane}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{S100a8}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pp}\PYG{o}{.}\PYG{n}{refine\PYGZus{}state\PYGZus{}info\PYGZus{}by\PYGZus{}marker\PYGZus{}genes}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{marker\PYGZus{}genes}\PYG{p}{,}
    \PYG{n}{selected\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{new\PYGZus{}cluster\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{new}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{add\PYGZus{}neighbor\PYGZus{}N}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{n}{confirm\PYGZus{}change}\PYG{o}{=}\PYG{n}{confirm\PYGZus{}change}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Change state annotation at adata.obs['state\_info']
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=247\sphinxpxdimen,height=202\sphinxpxdimen]{{20210121_cospar_tutorial_103_1}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=470\sphinxpxdimen,height=274\sphinxpxdimen]{{20210121_cospar_tutorial_103_2}.png}

\end{nbsphinxfancyoutput}


\subsubsection{Refine state annotation by clustering states at given time points}
\label{\detokenize{20210121_cospar_tutorial:Refine-state-annotation-by-clustering-states-at-given-time-points}}
First, explore the parameters.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[45]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{confirm\PYGZus{}change}\PYG{o}{=}\PYG{k+kc}{False}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pp}\PYG{o}{.}\PYG{n}{refine\PYGZus{}state\PYGZus{}info\PYGZus{}by\PYGZus{}leiden\PYGZus{}clustering}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
            \PYG{n}{leiden\PYGZus{}resolution}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{,}\PYG{n}{confirm\PYGZus{}change}\PYG{o}{=}\PYG{n}{confirm\PYGZus{}change}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Error: Selected time points not available. Please select from ['4', '6']
\end{sphinxVerbatim}
}

Once you are happy with the result, confirm the change to \sphinxcode{\sphinxupquote{adata.obs{[}\textquotesingle{}state\_info\textquotesingle{}{]}}}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[46]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{confirm\PYGZus{}change}\PYG{o}{=}\PYG{k+kc}{True}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pp}\PYG{o}{.}\PYG{n}{refine\PYGZus{}state\PYGZus{}info\PYGZus{}by\PYGZus{}leiden\PYGZus{}clustering}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
                    \PYG{n}{leiden\PYGZus{}resolution}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{,}\PYG{n}{confirm\PYGZus{}change}\PYG{o}{=}\PYG{n}{confirm\PYGZus{}change}\PYG{p}{,}\PYG{n}{cluster\PYGZus{}name\PYGZus{}prefix}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{day2\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Error: Selected time points not available. Please select from ['4', '6']
\end{sphinxVerbatim}
}


\subsubsection{Differential gene expression between two clusters}
\label{\detokenize{20210121_cospar_tutorial:Differential-gene-expression-between-two-clusters}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[47]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{diff\PYGZus{}gene\PYGZus{}A}\PYG{p}{,}\PYG{n}{diff\PYGZus{}gene\PYGZus{}B}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{differential\PYGZus{}genes\PYGZus{}for\PYGZus{}given\PYGZus{}fates}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Neutrophil}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Monocyte}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
                                    \PYG{n}{gene\PYGZus{}N}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{n}{plot\PYGZus{}gene\PYGZus{}N}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=583\sphinxpxdimen,height=283\sphinxpxdimen]{{20210121_cospar_tutorial_110_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=472\sphinxpxdimen,height=171\sphinxpxdimen]{{20210121_cospar_tutorial_110_1}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=472\sphinxpxdimen,height=171\sphinxpxdimen]{{20210121_cospar_tutorial_110_2}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[48]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{diff\PYGZus{}gene\PYGZus{}A}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxout}[48]:\,\hspace{\fboxrule}\hspace{\fboxsep}}        gene             pv     mean\_1      mean\_2     ratio
16       Ngp  4.184225e-182   1.684322  324.910828 -6.923776
96      Camp   1.401590e-73   0.132501   24.727663 -4.505735
66       Ltf   5.324550e-86   0.108736   24.162815 -4.504305
12    S100a9  6.193967e-200  33.714066  442.656708 -3.675852
13    S100a8  2.892061e-198  32.819645  263.530884 -2.967503
..       {\ldots}            {\ldots}        {\ldots}         {\ldots}       {\ldots}
339   Prss57   2.689917e-24   0.036761    1.080616 -1.004927
314  Ccdc125   8.511859e-26   0.562560    2.135035 -1.004570
299     Cnn2   3.391266e-27   0.903385    2.791486 -0.994196
552    Anxa1   2.409673e-13   7.341900   15.615431 -0.994076
471     Cybb   4.089828e-16  15.634762   31.941101 -0.985688

[100 rows x 5 columns]
\end{sphinxVerbatim}
}


\section{Hematopoietic dataset}
\label{\detokenize{20210121_all_hematopoietic_data:Hematopoietic-dataset}}\label{\detokenize{20210121_all_hematopoietic_data::doc}}
Hematopoiesis dataset from \sphinxstyleemphasis{Weinreb, C., Rodriguez\sphinxhyphen{}Fraticelli, A., Camargo, F. D. \& Klein, A. M. Science 367, (2020)}. This dataset has 3 time points for both the clones and the state measurements.

This dataset is very big. Running the whole pipeline for the first time could take 1\sphinxhyphen{}2 hours. Most of the time is used for generating the similarity matrix, which are saved for later usage. The actual computation of transition map takes only 10 minutues.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[1]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{k+kn}{import} \PYG{n+nn}{scanpy} \PYG{k}{as} \PYG{n+nn}{sc}
\PYG{k+kn}{import} \PYG{n+nn}{time}
\PYG{k+kn}{import} \PYG{n+nn}{cospar} \PYG{k}{as} \PYG{n+nn}{cs}
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[2]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{logging}\PYG{o}{.}\PYG{n}{print\PYGZus{}version}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{verbosity}\PYG{o}{=}\PYG{l+m+mi}{3}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{set\PYGZus{}figure\PYGZus{}params}\PYG{p}{(}\PYG{n+nb}{format}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{png}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{dpi}\PYG{o}{=}\PYG{l+m+mi}{75}\PYG{p}{,}\PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{14}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} use png to reduce file size.}

\PYG{n}{cs}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{data\PYGZus{}path}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LARRY\PYGZus{}data}\PYG{l+s+s1}{\PYGZsq{}} \PYG{c+c1}{\PYGZsh{} A relative path to save data. If not existed before, create a new one.}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{figure\PYGZus{}path}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LARRY\PYGZus{}figure}\PYG{l+s+s1}{\PYGZsq{}} \PYG{c+c1}{\PYGZsh{} A relative path to save figures. If not existed before, create a new one.}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Running cospar 0.0.2 (python 3.6.12) on 2021-01-28 16:47.
\end{sphinxVerbatim}
}


\subsection{Load data}
\label{\detokenize{20210121_all_hematopoietic_data:Load-data}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[3]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{data\PYGZus{}path}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{data\PYGZus{}path}
\PYG{n}{figure\PYGZus{}path}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{figure\PYGZus{}path}
\PYG{n}{adata\PYGZus{}orig}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{datasets}\PYG{o}{.}\PYG{n}{hematopoiesis\PYGZus{}all}\PYG{p}{(}\PYG{n}{data\PYGZus{}path}\PYG{o}{=}\PYG{n}{data\PYGZus{}path}\PYG{p}{,}\PYG{n}{figure\PYGZus{}path}\PYG{o}{=}\PYG{n}{figure\PYGZus{}path}\PYG{p}{)}
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[4]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{sc}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{umap}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{state\PYGZus{}info}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=470\sphinxpxdimen,height=274\sphinxpxdimen]{{20210121_all_hematopoietic_data_6_0}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[5]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{hf}\PYG{o}{.}\PYG{n}{check\PYGZus{}available\PYGZus{}choices}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Available transition maps: []
Availabel clusters: ['Neutrophil', 'Lymphoid', 'Erythroid', 'Eos', 'pDC', 'Monocyte', 'undiff', 'Neu\_Mon', 'Ccr7\_DC', 'Baso', 'Meg', 'Mast']
Availabel time points: ['2', '4', '6']
Clonal time points: ['2', '4', '6']
\end{sphinxVerbatim}
}


\subsubsection{Raw clonal data analysis (without using state information)}
\label{\detokenize{20210121_all_hematopoietic_data:Raw-clonal-data-analysis-(without-using-state-information)}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[6]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{clones\PYGZus{}on\PYGZus{}manifold}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{selected\PYGZus{}clone\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{color\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{black}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{point\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=247\sphinxpxdimen,height=184\sphinxpxdimen]{{20210121_all_hematopoietic_data_9_0}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[7]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{plot\PYGZus{}time\PYGZus{}point}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{4}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ccr7\PYGZus{}DC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mast}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Meg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pDC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Eos}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Lymphoid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Erythroid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Baso}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}  \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Neutrophil}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Monocyte}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{celltype\PYGZus{}names}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mDC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}  \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mast}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Meg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pDC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Eos}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ly}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ery}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Baso}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Neu}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mon}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}coupling\PYGZus{}from\PYGZus{}clones}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{plot\PYGZus{}time\PYGZus{}point}\PYG{p}{,} \PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{n}{selected\PYGZus{}fates}\PYG{p}{,}
                \PYG{n}{color\PYGZus{}bar}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}\PYG{n}{rename\PYGZus{}selected\PYGZus{}fates}\PYG{o}{=}\PYG{n}{celltype\PYGZus{}names}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=281\sphinxpxdimen,height=283\sphinxpxdimen]{{20210121_all_hematopoietic_data_10_0}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[8]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{plot\PYGZus{}time\PYGZus{}point}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{4}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{barcode\PYGZus{}heatmap}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{plot\PYGZus{}time\PYGZus{}point}\PYG{p}{,} \PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{n}{selected\PYGZus{}fates}\PYG{p}{,} \PYG{n}{color\PYGZus{}bar}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=284\sphinxpxdimen,height=433\sphinxpxdimen]{{20210121_all_hematopoietic_data_11_0}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[9]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{c+c1}{\PYGZsh{} select\PYGZus{}fate\PYGZus{}cluster=\PYGZsq{}Monocyte\PYGZsq{}}
\PYG{c+c1}{\PYGZsh{} clonal\PYGZus{}fate\PYGZus{}bias,clone\PYGZus{}id=cs.pl.clonal\PYGZus{}fate\PYGZus{}bias(adata\PYGZus{}orig,select\PYGZus{}fate\PYGZus{}cluster,}
\PYG{c+c1}{\PYGZsh{}             clone\PYGZus{}size\PYGZus{}thresh=5,N\PYGZus{}resampling=100,compute\PYGZus{}new=False)}
\end{sphinxVerbatim}
}


\subsection{Part 1: Infer transition map using clones from both day4 and day6}
\label{\detokenize{20210121_all_hematopoietic_data:Part-1:-Infer-transition-map-using-clones-from-both-day4-and-day6}}

\subsubsection{Map inference}
\label{\detokenize{20210121_all_hematopoietic_data:Map-inference}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[13]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{t}\PYG{o}{=}\PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{noise\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mf}{0.2} \PYG{c+c1}{\PYGZsh{}}
\PYG{n}{selected\PYGZus{}clonal\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{6}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{adata}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{tmap}\PYG{o}{.}\PYG{n}{infer\PYGZus{}Tmap\PYGZus{}from\PYGZus{}multitime\PYGZus{}clones}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{selected\PYGZus{}clonal\PYGZus{}time\PYGZus{}points}\PYG{p}{,}\PYG{n}{smooth\PYGZus{}array}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{15}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,}
        \PYG{n}{noise\PYGZus{}threshold}\PYG{o}{=}\PYG{n}{noise\PYGZus{}threshold}\PYG{p}{,}\PYG{n}{demulti\PYGZus{}threshold}\PYG{o}{=}\PYG{n}{noise\PYGZus{}threshold}\PYG{p}{,}\PYG{n}{use\PYGZus{}full\PYGZus{}Smatrix}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Used\PYGZhy{}\PYGZhy{}time: }\PYG{l+s+s1}{\PYGZob{}}\PYG{l+s+s1}{time.time()\PYGZhy{}t\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
-------Step 1: Select time points---------
--> Clonal cell fraction (day 4-6): 0.8093837722229649
--> Clonal cell fraction (day 6-4): 0.8744969393621699
--> Numer of cells that are clonally related -- day 4: 12110  and day 6: 25858
Valid clone number 'FOR' post selection 3047
Cell number=37968, Clone number=3047
-------Step 2: Compute the full Similarity matrix if necessary---------
-------Step 3: Optimize the transition map recursively---------
---------Compute the transition map-----------
Compute similarity matrix: load existing data
--> Time elapsed:  2.8668580055236816
--> Time elapsed:  11.12159776687622
--> Time elapsed:  3.948186159133911
--> Time elapsed:  13.878545045852661
Compute similarity matrix: load existing data
--> Time elapsed:  2.4825279712677
--> Time elapsed:  7.225665092468262
--> Time elapsed:  1.8797578811645508
--> Time elapsed:  9.714000940322876
Compute similarity matrix: load existing data
--> Time elapsed:  1.7630691528320312
--> Time elapsed:  5.514636039733887
--> Time elapsed:  1.5426161289215088
--> Time elapsed:  5.716917991638184
Current iteration: 0
Use smooth\_round=20
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
--> Clone id: 1000
--> Clone id: 2000
--> Clone id: 3000
Start to smooth the refined clonal map
Phase I: time elapsed --  46.65948677062988
Phase II: time elapsed --  98.13885879516602
Current iteration: 1
Use smooth\_round=15
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
--> Clone id: 1000
--> Clone id: 2000
--> Clone id: 3000
Start to smooth the refined clonal map
Phase I: time elapsed --  37.80651021003723
Phase II: time elapsed --  102.54157018661499
Current iteration: 2
Use smooth\_round=10
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
--> Clone id: 1000
--> Clone id: 2000
--> Clone id: 3000
Start to smooth the refined clonal map
Phase I: time elapsed --  31.309563875198364
Phase II: time elapsed --  86.41444969177246
No need for Final Smooth (i.e., clonally states are the final state space for Tmap)
----Demultiplexed transition map----
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
--> Clone id: 1000
--> Clone id: 2000
--> Clone id: 3000
Used--time: 629.5148532390594
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=363\sphinxpxdimen,height=241\sphinxpxdimen]{{20210121_all_hematopoietic_data_15_1}.png}

\end{nbsphinxfancyoutput}


\subsubsection{Save or load pre\sphinxhyphen{}computed data}
\label{\detokenize{20210121_all_hematopoietic_data:Save-or-load-pre-computed-data}}
This can be used to save maps obtained from different parameter choices. Usually, different parameter choice will result to different ‘data\_des’, a prefix to define the map. Saving an adata would print the ‘data\_des’, which can be used to load the corresponding map.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[27]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{save\PYGZus{}data}\PYG{o}{=}\PYG{k+kc}{False}
\PYG{k}{if} \PYG{n}{save\PYGZus{}data}\PYG{p}{:}
    \PYG{n}{cs}\PYG{o}{.}\PYG{n}{hf}\PYG{o}{.}\PYG{n}{save\PYGZus{}map}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{)}

\PYG{n}{load\PYGZus{}data}\PYG{o}{=}\PYG{k+kc}{True}
\PYG{k}{if} \PYG{n}{load\PYGZus{}data}\PYG{p}{:}\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} Plotting}
    \PYG{c+c1}{\PYGZsh{} updated Jan 27, 2021}
    \PYG{c+c1}{\PYGZsh{}data\PYGZus{}des=\PYGZsq{}LARRY\PYGZus{}TwoTimeClone\PYGZus{}t*4*6\PYGZsq{}\PYGZsh{}\PYGZsh{}\PYGZsh{} Plotting}
    \PYG{n}{data\PYGZus{}des}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LARRY\PYGZus{}OneTimeClone\PYGZus{}t*4*6}\PYG{l+s+s1}{\PYGZsq{}}
    \PYG{c+c1}{\PYGZsh{}data\PYGZus{}des=\PYGZsq{}LARRY\PYGZus{}TwoTimeClone\PYGZus{}t*2*4*6\PYGZsq{}}
    \PYG{n}{adata}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{hf}\PYG{o}{.}\PYG{n}{load\PYGZus{}saved\PYGZus{}adata}\PYG{p}{(}\PYG{n}{data\PYGZus{}des}\PYG{p}{)}

\end{sphinxVerbatim}
}


\subsubsection{Plotting}
\label{\detokenize{20210121_all_hematopoietic_data:Plotting}}
There are some common parameters
\begin{itemize}
\item {} 
\sphinxstylestrong{used\_map\_name}: \sphinxstyleemphasis{\{‘transition\_map’, ‘demultiplexed\_map’, ‘OT\_transition\_map’, ‘HighVar\_transition\_map’\}}

\item {} 
\sphinxstylestrong{selected\_fates}: selected fate clusters for things like fate map construction, DGE analysis etc. The \sphinxstyleemphasis{selected\_fates} allows nested structure, e.g., \sphinxstyleemphasis{selected\_fates={[}{[}‘0’,‘2’{]},‘1’{]}} means combined cluster ‘0\sphinxhyphen{}2’ and cluster ‘1’

\item {} 
\sphinxstylestrong{map\_backwards}: \sphinxstyleemphasis{True}, assuming that the \sphinxstyleemphasis{selected\_fates} are cell states belonging to later time points (t2), and map for the initial cell states; \sphinxstyleemphasis{False}, map from early states to later states.

\item {} 
\sphinxstylestrong{plot\_time\_points}: select states at given time points for the analysis

\end{itemize}


\paragraph{Plotting transition profiles for single cells}
\label{\detokenize{20210121_all_hematopoietic_data:Plotting-transition-profiles-for-single-cells}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[12]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{selected\PYGZus{}state\PYGZus{}id\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}

\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{single\PYGZus{}cell\PYGZus{}transition}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}state\PYGZus{}id\PYGZus{}list}\PYG{o}{=}\PYG{n}{selected\PYGZus{}state\PYGZus{}id\PYGZus{}list}\PYG{p}{,}
                                    \PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=282\sphinxpxdimen,height=883\sphinxpxdimen]{{20210121_all_hematopoietic_data_20_0}.png}

\end{nbsphinxfancyoutput}


\paragraph{Fate map}
\label{\detokenize{20210121_all_hematopoietic_data:Fate-map}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[13]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}map}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}
               \PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=287\sphinxpxdimen,height=2417\sphinxpxdimen]{{20210121_all_hematopoietic_data_22_0}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[14]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}map}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Neutrophil}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Monocyte}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
               \PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{intraclone\PYGZus{}transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=288\sphinxpxdimen,height=435\sphinxpxdimen]{{20210121_all_hematopoietic_data_23_0}.png}

\end{nbsphinxfancyoutput}


\paragraph{Fate bias}
\label{\detokenize{20210121_all_hematopoietic_data:Fate-bias}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[15]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}bias\PYGZus{}intrinsic}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Monocyte}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Neutrophil}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
            \PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=528\sphinxpxdimen,height=230\sphinxpxdimen]{{20210121_all_hematopoietic_data_25_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=600\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_all_hematopoietic_data_25_1}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[16]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}bias\PYGZus{}from\PYGZus{}binary\PYGZus{}competition}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Monocyte}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Neutrophil}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
            \PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{sum\PYGZus{}fate\PYGZus{}prob\PYGZus{}thresh}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=315\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_all_hematopoietic_data_26_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=310\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_all_hematopoietic_data_26_1}.png}

\end{nbsphinxfancyoutput}


\paragraph{Lineage coupling of the transition map}
\label{\detokenize{20210121_all_hematopoietic_data:Lineage-coupling-of-the-transition-map}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[17]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{fate\PYGZus{}array}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ccr7\PYGZus{}DC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mast}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Meg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pDC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Eos}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Lymphoid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Erythroid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Baso}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}  \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Neutrophil}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Monocyte}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{celltype\PYGZus{}names}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mDC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}  \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mast}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Meg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pDC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Eos}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ly}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ery}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Baso}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Neu}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mon}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}coupling\PYGZus{}from\PYGZus{}Tmap}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{n}{fate\PYGZus{}array}\PYG{p}{,}\PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{rename\PYGZus{}selected\PYGZus{}fates}\PYG{o}{=}\PYG{n}{celltype\PYGZus{}names}\PYG{p}{)}

\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=366\sphinxpxdimen,height=283\sphinxpxdimen]{{20210121_all_hematopoietic_data_28_0}.png}

\end{nbsphinxfancyoutput}


\paragraph{Dynamic trajectory inference}
\label{\detokenize{20210121_all_hematopoietic_data:Dynamic-trajectory-inference}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[18]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{dynamic\PYGZus{}trajectory\PYGZus{}from\PYGZus{}competition\PYGZus{}bias}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,} \PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Neutrophil}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Monocyte}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
 \PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}
    \PYG{n}{bias\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{sum\PYGZus{}fate\PYGZus{}prob\PYGZus{}thresh}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{n}{avoid\PYGZus{}target\PYGZus{}states}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=583\sphinxpxdimen,height=283\sphinxpxdimen]{{20210121_all_hematopoietic_data_30_0}.png}

\end{nbsphinxfancyoutput}


\paragraph{Differential genes for two ancestor groups}
\label{\detokenize{20210121_all_hematopoietic_data:Differential-genes-for-two-ancestor-groups}}
The selected cell states can be accessed at \sphinxstyleemphasis{adata.obs{[}‘DGE\_cell\_group\_A’{]}} and \sphinxstyleemphasis{adata.obs{[}‘DGE\_cell\_group\_B’{]}}. A DGE analysis can be performed below. It is also easy to use other methods for DGE analysis using the selected idx.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[19]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{group\PYGZus{}A\PYGZus{}index}\PYG{o}{=}\PYG{n}{adata}\PYG{o}{.}\PYG{n}{obs}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{DGE\PYGZus{}cell\PYGZus{}group\PYGZus{}A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{group\PYGZus{}B\PYGZus{}index}\PYG{o}{=}\PYG{n}{adata}\PYG{o}{.}\PYG{n}{obs}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{DGE\PYGZus{}cell\PYGZus{}group\PYGZus{}B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{dge\PYGZus{}gene\PYGZus{}A}\PYG{p}{,} \PYG{n}{dge\PYGZus{}gene\PYGZus{}B}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{differential\PYGZus{}genes}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{plot\PYGZus{}gene\PYGZus{}N}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=583\sphinxpxdimen,height=283\sphinxpxdimen]{{20210121_all_hematopoietic_data_33_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=472\sphinxpxdimen,height=171\sphinxpxdimen]{{20210121_all_hematopoietic_data_33_1}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=472\sphinxpxdimen,height=171\sphinxpxdimen]{{20210121_all_hematopoietic_data_33_2}.png}

\end{nbsphinxfancyoutput}


\paragraph{Gene trend along the dynamic trajectory}
\label{\detokenize{20210121_all_hematopoietic_data:Gene-trend-along-the-dynamic-trajectory}}
The selected states, combined with the target states are stored as dynamic trajectory at adata.uns{[}‘dynamic\_trajectory’{]}. We can plot gene trend along this trajectory

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[20]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{c+c1}{\PYGZsh{} The results are based on pre\PYGZhy{}computed dynamic trajectories from a previous step}
\PYG{c+c1}{\PYGZsh{} better to use the \PYGZsq{}intraclone transition map\PYGZsq{}}

\PYG{n}{gene\PYGZus{}name\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Gata1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mpo}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Elane}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{S100a8}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{selected\PYGZus{}fate}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Neutrophil}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{adata\PYGZus{}selected}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{gene\PYGZus{}expression\PYGZus{}dynamics}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fate}\PYG{p}{,}\PYG{n}{gene\PYGZus{}name\PYGZus{}list}\PYG{p}{,} \PYG{n}{traj\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{,}
      \PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{invert\PYGZus{}PseudoTime}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{include\PYGZus{}target\PYGZus{}states}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{compute\PYGZus{}new}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}
    \PYG{n}{fig\PYGZus{}width}\PYG{o}{=}\PYG{l+m+mf}{3.5}\PYG{p}{,} \PYG{n}{gene\PYGZus{}exp\PYGZus{}percentile}\PYG{o}{=}\PYG{l+m+mi}{99}\PYG{p}{,} \PYG{n}{n\PYGZus{}neighbors}\PYG{o}{=}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{n}{plot\PYGZus{}raw\PYGZus{}data}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{point\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}

\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{nbsphinx-stderr}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
/Users/shouwenwang/miniconda3/envs/CoSpar\_env/lib/python3.6/site-packages/plotnine/ggplot.py:729: PlotnineWarning: Saving 3.5 x 2.163 in image.
/Users/shouwenwang/miniconda3/envs/CoSpar\_env/lib/python3.6/site-packages/plotnine/ggplot.py:730: PlotnineWarning: Filename: LARRY\_figure/LARRY\_TwoTimeClone\_t*4*6\_fate\_trajectory\_pseutoTime\_gene\_expression\_Neutrophil\_True.png
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=718\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_all_hematopoietic_data_36_1}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=695\sphinxpxdimen,height=429\sphinxpxdimen]{{20210121_all_hematopoietic_data_36_2}.png}

\end{nbsphinxfancyoutput}


\paragraph{Apply other pseudotime methods on the selected cell states}
\label{\detokenize{20210121_all_hematopoietic_data:Apply-other-pseudotime-methods-on-the-selected-cell-states}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[21]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{c+c1}{\PYGZsh{} adata\PYGZus{}selected can be used by other analysis package for further analysis}
\PYG{n}{sc}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{umap}\PYG{p}{(}\PYG{n}{adata\PYGZus{}selected}\PYG{p}{,}\PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{state\PYGZus{}info}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{nbsphinx-stderr}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Trying to set attribute `.uns` of view, copying.
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=470\sphinxpxdimen,height=274\sphinxpxdimen]{{20210121_all_hematopoietic_data_38_1}.png}

\end{nbsphinxfancyoutput}


\paragraph{Identify differentially expressed genes}
\label{\detokenize{20210121_all_hematopoietic_data:Identify-differentially-expressed-genes}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[22]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{diff\PYGZus{}gene\PYGZus{}A}\PYG{p}{,}\PYG{n}{diff\PYGZus{}gene\PYGZus{}B}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{differential\PYGZus{}genes\PYGZus{}for\PYGZus{}given\PYGZus{}fates}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Neutrophil}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Monocyte}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{gene\PYGZus{}N}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{n}{plot\PYGZus{}gene\PYGZus{}N}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=583\sphinxpxdimen,height=283\sphinxpxdimen]{{20210121_all_hematopoietic_data_40_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=472\sphinxpxdimen,height=171\sphinxpxdimen]{{20210121_all_hematopoietic_data_40_1}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=472\sphinxpxdimen,height=171\sphinxpxdimen]{{20210121_all_hematopoietic_data_40_2}.png}

\end{nbsphinxfancyoutput}


\subsubsection{Transition map from only clonal information}
\label{\detokenize{20210121_all_hematopoietic_data:Transition-map-from-only-clonal-information}}
Assume uniform transition within the same clone

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[25]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{c+c1}{\PYGZsh{} The Weinreb method: selecting uni\PYGZhy{}potent clones first; Uniform transition probability within the same clone}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{tmap}\PYG{o}{.}\PYG{n}{infer\PYGZus{}weinreb\PYGZus{}Tmap}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{)}

\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}bias\PYGZus{}from\PYGZus{}binary\PYGZus{}competition}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Monocyte}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Neutrophil}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{weinreb\PYGZus{}transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
            \PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{sum\PYGZus{}fate\PYGZus{}prob\PYGZus{}thresh}\PYG{o}{=}\PYG{l+m+mf}{0.4}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
This method works when there are only time points and all datasets
Used clone fraction 0.6307843780767969
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=315\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_all_hematopoietic_data_42_1}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=310\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_all_hematopoietic_data_42_2}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[26]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{c+c1}{\PYGZsh{} The naive method: no clone pre\PYGZhy{}selection. Uniform transition probability within the same clone}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{tmap}\PYG{o}{.}\PYG{n}{infer\PYGZus{}naive\PYGZus{}Tmap}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{)}

\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}bias\PYGZus{}from\PYGZus{}binary\PYGZus{}competition}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Monocyte}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Neutrophil}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{naive\PYGZus{}transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
            \PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{sum\PYGZus{}fate\PYGZus{}prob\PYGZus{}thresh}\PYG{o}{=}\PYG{l+m+mf}{0.4}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=315\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_all_hematopoietic_data_43_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=310\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_all_hematopoietic_data_43_1}.png}

\end{nbsphinxfancyoutput}


\subsection{Part II: Infer transition map using clones from all time points}
\label{\detokenize{20210121_all_hematopoietic_data:Part-II:-Infer-transition-map-using-clones-from-all-time-points}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[8]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{t}\PYG{o}{=}\PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{noise\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mf}{0.2} \PYG{c+c1}{\PYGZsh{}}
\PYG{n}{selected\PYGZus{}clonal\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{6}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{adata}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{tmap}\PYG{o}{.}\PYG{n}{infer\PYGZus{}Tmap\PYGZus{}from\PYGZus{}multitime\PYGZus{}clones}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{selected\PYGZus{}clonal\PYGZus{}time\PYGZus{}points}\PYG{p}{,}\PYG{n}{smooth\PYGZus{}array}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{15}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,}
        \PYG{n}{noise\PYGZus{}threshold}\PYG{o}{=}\PYG{n}{noise\PYGZus{}threshold}\PYG{p}{,}\PYG{n}{demulti\PYGZus{}threshold}\PYG{o}{=}\PYG{n}{noise\PYGZus{}threshold}\PYG{p}{,}\PYG{n}{use\PYGZus{}full\PYGZus{}Smatrix}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Used\PYGZhy{}\PYGZhy{}time: }\PYG{l+s+s1}{\PYGZob{}}\PYG{l+s+s1}{time.time()\PYGZhy{}t\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
-------Step 1: Select time points---------
--> Clonal cell fraction (day 2-4): 0.48396946564885496
--> Clonal cell fraction (day 4-6): 0.8093837722229649
--> Clonal cell fraction (day 4-2): 0.3728111215078198
--> Clonal cell fraction (day 6-4): 0.8744969393621699
--> Numer of cells that are clonally related -- day 2: 2219  and day 4: 5578
--> Numer of cells that are clonally related -- day 4: 12110  and day 6: 25858
Valid clone number 'FOR' post selection 3617
Cell number=41455, Clone number=3617
-------Step 2: Compute the full Similarity matrix if necessary---------
-------Step 3: Optimize the transition map recursively---------
---------Compute the transition map-----------
Compute similarity matrix: load existing data
--> Time elapsed:  4.178639888763428
--> Time elapsed:  16.909836053848267
--> Time elapsed:  7.051729202270508
--> Time elapsed:  29.396594047546387
Compute similarity matrix: load existing data
--> Time elapsed:  3.1903891563415527
--> Time elapsed:  9.919449090957642
--> Time elapsed:  3.2668142318725586
--> Time elapsed:  14.067722797393799
Compute similarity matrix: load existing data
--> Time elapsed:  2.4883570671081543
--> Time elapsed:  7.939680099487305
--> Time elapsed:  2.008693218231201
--> Time elapsed:  11.060231924057007
Current iteration: 0
Use smooth\_round=20
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
--> Clone id: 1000
--> Clone id: 2000
--> Clone id: 3000
--> Relative time point pair index: 1
--> Clone id: 0
--> Clone id: 1000
--> Clone id: 2000
--> Clone id: 3000
Start to smooth the refined clonal map
Phase I: time elapsed --  76.52748799324036
Phase II: time elapsed --  149.31560707092285
Current iteration: 1
Use smooth\_round=15
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
--> Clone id: 1000
--> Clone id: 2000
--> Clone id: 3000
--> Relative time point pair index: 1
--> Clone id: 0
--> Clone id: 1000
--> Clone id: 2000
--> Clone id: 3000
Start to smooth the refined clonal map
Phase I: time elapsed --  50.76579403877258
Phase II: time elapsed --  114.15616798400879
Current iteration: 2
Use smooth\_round=10
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
--> Clone id: 1000
--> Clone id: 2000
--> Clone id: 3000
--> Relative time point pair index: 1
--> Clone id: 0
--> Clone id: 1000
--> Clone id: 2000
--> Clone id: 3000
Start to smooth the refined clonal map
Phase I: time elapsed --  40.142027139663696
Phase II: time elapsed --  105.41105198860168
No need for Final Smooth (i.e., clonally states are the final state space for Tmap)
----Demultiplexed transition map----
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
--> Clone id: 1000
--> Clone id: 2000
--> Clone id: 3000
--> Relative time point pair index: 1
--> Clone id: 0
--> Clone id: 1000
--> Clone id: 2000
--> Clone id: 3000
Used--time: 754.9322369098663
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=363\sphinxpxdimen,height=241\sphinxpxdimen]{{20210121_all_hematopoietic_data_45_1}.png}

\end{nbsphinxfancyoutput}

From our experience, it is better to use the intra\sphinxhyphen{}clone transition map to compute the trajectory

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[9]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{c+c1}{\PYGZsh{} combine all time points}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{dynamic\PYGZus{}trajectory\PYGZus{}via\PYGZus{}iterative\PYGZus{}mapping}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,} \PYG{n}{selected\PYGZus{}fate}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Neutrophil}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{map\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{n}{plot\PYGZus{}separately}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{apply\PYGZus{}time\PYGZus{}constaint}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{point\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen,height=237\sphinxpxdimen]{{20210121_all_hematopoietic_data_48_0}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[10]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{c+c1}{\PYGZsh{} plot each tiem point separately, use the intra\PYGZhy{}clone transition map.}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{dynamic\PYGZus{}trajectory\PYGZus{}via\PYGZus{}iterative\PYGZus{}mapping}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,} \PYG{n}{selected\PYGZus{}fate}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Neutrophil}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{intraclone\PYGZus{}transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{map\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{n}{plot\PYGZus{}separately}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{apply\PYGZus{}time\PYGZus{}constaint}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{point\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=733\sphinxpxdimen,height=237\sphinxpxdimen]{{20210121_all_hematopoietic_data_49_0}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[11]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{c+c1}{\PYGZsh{} The results are based on pre\PYGZhy{}computed dynamic trajectories from a previous step}
\PYG{c+c1}{\PYGZsh{} better to use the \PYGZsq{}intraclone transition map\PYGZsq{}}

\PYG{n}{gene\PYGZus{}name\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Gata1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mpo}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Elane}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{S100a8}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{selected\PYGZus{}fate}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Neutrophil}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{adata\PYGZus{}selected}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{gene\PYGZus{}expression\PYGZus{}dynamics}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fate}\PYG{p}{,}\PYG{n}{gene\PYGZus{}name\PYGZus{}list}\PYG{p}{,} \PYG{n}{traj\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{,}
      \PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{invert\PYGZus{}PseudoTime}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{include\PYGZus{}target\PYGZus{}states}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{compute\PYGZus{}new}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}
    \PYG{n}{fig\PYGZus{}width}\PYG{o}{=}\PYG{l+m+mf}{3.5}\PYG{p}{,} \PYG{n}{gene\PYGZus{}exp\PYGZus{}percentile}\PYG{o}{=}\PYG{l+m+mi}{99}\PYG{p}{,} \PYG{n}{n\PYGZus{}neighbors}\PYG{o}{=}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{n}{plot\PYGZus{}raw\PYGZus{}data}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{point\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}

\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{nbsphinx-stderr}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
/Users/shouwenwang/miniconda3/envs/CoSpar\_env/lib/python3.6/site-packages/plotnine/ggplot.py:729: PlotnineWarning: Saving 3.5 x 2.163 in image.
/Users/shouwenwang/miniconda3/envs/CoSpar\_env/lib/python3.6/site-packages/plotnine/ggplot.py:730: PlotnineWarning: Filename: LARRY\_figure/LARRY\_TwoTimeClone\_t*2*4*6\_fate\_trajectory\_pseutoTime\_gene\_expression\_Neutrophil\_True.png
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=718\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_all_hematopoietic_data_51_1}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=695\sphinxpxdimen,height=429\sphinxpxdimen]{{20210121_all_hematopoietic_data_51_2}.png}

\end{nbsphinxfancyoutput}


\subsection{Part IIII: Infer transition map using only clones from the last time point}
\label{\detokenize{20210121_all_hematopoietic_data:Part-IIII:-Infer-transition-map-using-only-clones-from-the-last-time-point}}
\sphinxstyleemphasis{Purpose}: Infer transition map from scRNAseq data where cells at one time point are clonally labeled. After initializing the map by either \sphinxstyleemphasis{OT} method or \sphinxstyleemphasis{HighVar} method, We jointly infer the likely clonal ancestors and the transition map between cell states in these two time points.

Parameters relevant for cell state selection: \sphinxstyleemphasis{initial\_time\_points, clonal\_time\_point, use\_full\_Smatrix}.

Choose the initialization method, and set the corresponding parameters.
\begin{itemize}
\item {} 
‘OT’: tend to be more accurate, but not reliable under batch effect. Key parameters: \sphinxstyleemphasis{OT\_epsilon}.

\item {} 
‘HighVar’: is robust to batch effect. Related parameters: \sphinxstyleemphasis{HighVar\_gene\_pctl}.

\end{itemize}

Parameters relevant for CoSpar itself: \sphinxstyleemphasis{smooth\_array, normalization\_mode, CoSpar\_KNN, noise\_threshold, Clone\_update\_iter\_N}.

cs.hf.check\_available\_choices(adata\_orig)

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[10]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{initial\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{}[\PYGZsq{}2\PYGZsq{},\PYGZsq{}4\PYGZsq{}]}
\PYG{n}{clonal\PYGZus{}time\PYGZus{}point}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{6}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{t}\PYG{o}{=}\PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{adata}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{tmap}\PYG{o}{.}\PYG{n}{infer\PYGZus{}Tmap\PYGZus{}from\PYGZus{}one\PYGZus{}time\PYGZus{}clones}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{initial\PYGZus{}time\PYGZus{}points}\PYG{p}{,}\PYG{n}{clonal\PYGZus{}time\PYGZus{}point}\PYG{p}{,}\PYG{n}{Clone\PYGZus{}update\PYGZus{}iter\PYGZus{}N}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}
        \PYG{n}{initialize\PYGZus{}method}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{OT}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{OT\PYGZus{}cost}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{SPD}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{smooth\PYGZus{}array}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{15}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,}\PYG{n}{noise\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{,}\PYG{n}{use\PYGZus{}full\PYGZus{}Smatrix}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Used\PYGZhy{}\PYGZhy{}time: }\PYG{l+s+s1}{\PYGZob{}}\PYG{l+s+s1}{time.time()\PYGZhy{}t\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
-------------------------------New Start--------------------------------------------------
Current time point: 4
-----------Pre-processing and sub-sampling cells------------
----------------
Step 1: Use OT method for initialization
Load pre-computed shortest path distance matrix
Load pre-computed custon OT matrix
----------------
Step 2: Jointly optimize the transition map and the initial clonal states!
Joint optimization that consider possibility of clonal overlap: v2
--> original clone shape: (44531, 5000)
--> After excluding zero-sized clones: (44531, 3949)
Sort clones by size (small to large)
Infer the number of initial cells to extract for each clone in advance
--> Inferring early clonal states: current clone id 0
--> Inferring early clonal states: current clone id 100
--> Inferring early clonal states: current clone id 200
--> Inferring early clonal states: current clone id 300
--> Inferring early clonal states: current clone id 400
--> Inferring early clonal states: current clone id 500
--> Inferring early clonal states: current clone id 600
--> Inferring early clonal states: current clone id 700
--> Inferring early clonal states: current clone id 800
--> Inferring early clonal states: current clone id 900
--> Inferring early clonal states: current clone id 1000
--> Inferring early clonal states: current clone id 1100
--> Inferring early clonal states: current clone id 1200
--> Inferring early clonal states: current clone id 1300
--> Inferring early clonal states: current clone id 1400
--> Inferring early clonal states: current clone id 1500
--> Inferring early clonal states: current clone id 1600
--> Inferring early clonal states: current clone id 1700
--> Inferring early clonal states: current clone id 1800
--> Inferring early clonal states: current clone id 1900
--> Inferring early clonal states: current clone id 2000
--> Inferring early clonal states: current clone id 2100
--> Inferring early clonal states: current clone id 2200
--> Inferring early clonal states: current clone id 2300
--> Inferring early clonal states: current clone id 2400
--> Inferring early clonal states: current clone id 2500
--> Inferring early clonal states: current clone id 2600
--> Inferring early clonal states: current clone id 2700
--> Inferring early clonal states: current clone id 2800
--> Inferring early clonal states: current clone id 2900
--> Inferring early clonal states: current clone id 3000
--> Inferring early clonal states: current clone id 3100
--> Inferring early clonal states: current clone id 3200
--> Inferring early clonal states: current clone id 3300
--> Inferring early clonal states: current clone id 3400
--> Inferring early clonal states: current clone id 3500
--> Inferring early clonal states: current clone id 3600
--> Inferring early clonal states: current clone id 3700
--> Inferring early clonal states: current clone id 3800
--> Inferring early clonal states: current clone id 3900
---------Compute the transition map-----------
Compute similarity matrix: load existing data
--> Time elapsed:  3.6797239780426025
--> Time elapsed:  13.742685794830322
--> Time elapsed:  4.610268831253052
--> Time elapsed:  12.055868864059448
Compute similarity matrix: load existing data
--> Time elapsed:  3.0670039653778076
--> Time elapsed:  8.03362512588501
--> Time elapsed:  3.0305347442626953
--> Time elapsed:  10.189287900924683
Compute similarity matrix: load existing data
--> Time elapsed:  2.1817760467529297
--> Time elapsed:  6.402044057846069
--> Time elapsed:  1.544910192489624
--> Time elapsed:  9.86088514328003
Current iteration: 0
Use smooth\_round=20
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
--> Clone id: 1000
--> Clone id: 2000
--> Clone id: 3000
Start to smooth the refined clonal map
Phase I: time elapsed --  54.03305506706238
Phase II: time elapsed --  117.08894395828247
Current iteration: 1
Use smooth\_round=15
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
--> Clone id: 1000
--> Clone id: 2000
--> Clone id: 3000
Start to smooth the refined clonal map
Phase I: time elapsed --  47.91264796257019
Phase II: time elapsed --  111.59352087974548
Current iteration: 2
Use smooth\_round=10
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
--> Clone id: 1000
--> Clone id: 2000
--> Clone id: 3000
Start to smooth the refined clonal map
Phase I: time elapsed --  34.98528003692627
Phase II: time elapsed --  98.14115309715271
No need for Final Smooth (i.e., clonally states are the final state space for Tmap)
----Demultiplexed transition map----
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
--> Clone id: 1000
--> Clone id: 2000
--> Clone id: 3000
Finishing computing transport map from CoSpar using inferred clonal data, used time 698.4034938812256
Used--time: 819.3050382137299
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[29]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}map}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Neutrophil}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Monocyte}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
               \PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=288\sphinxpxdimen,height=435\sphinxpxdimen]{{20210121_all_hematopoietic_data_57_0}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[30]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}bias\PYGZus{}from\PYGZus{}binary\PYGZus{}competition}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Monocyte}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Neutrophil}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
            \PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{sum\PYGZus{}fate\PYGZus{}prob\PYGZus{}thresh}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=315\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_all_hematopoietic_data_59_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=310\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_all_hematopoietic_data_59_1}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[31]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}bias\PYGZus{}from\PYGZus{}binary\PYGZus{}competition}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Monocyte}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Neutrophil}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{OT\PYGZus{}transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
            \PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{sum\PYGZus{}fate\PYGZus{}prob\PYGZus{}thresh}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=315\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_all_hematopoietic_data_60_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=302\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_all_hematopoietic_data_60_1}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[32]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{fate\PYGZus{}array}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ccr7\PYGZus{}DC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mast}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Meg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pDC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Eos}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Lymphoid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Erythroid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Baso}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}  \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Neutrophil}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Monocyte}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{celltype\PYGZus{}names}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mDC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}  \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mast}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Meg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pDC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Eos}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ly}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ery}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Baso}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Neu}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mon}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}coupling\PYGZus{}from\PYGZus{}Tmap}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{n}{fate\PYGZus{}array}\PYG{p}{,}\PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                        \PYG{n}{rename\PYGZus{}selected\PYGZus{}fates}\PYG{o}{=}\PYG{n}{celltype\PYGZus{}names}\PYG{p}{,}\PYG{n}{color\PYGZus{}bar}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=366\sphinxpxdimen,height=283\sphinxpxdimen]{{20210121_all_hematopoietic_data_62_0}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[33]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{dynamic\PYGZus{}trajectory\PYGZus{}from\PYGZus{}competition\PYGZus{}bias}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,} \PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Neutrophil}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Monocyte}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
 \PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}
    \PYG{n}{bias\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{sum\PYGZus{}fate\PYGZus{}prob\PYGZus{}thresh}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{n}{avoid\PYGZus{}target\PYGZus{}states}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=583\sphinxpxdimen,height=283\sphinxpxdimen]{{20210121_all_hematopoietic_data_64_0}.png}

\end{nbsphinxfancyoutput}

The results are saved in adata, and can be used to perform DGE analysis or plot gene trends, as shown above.


\section{Reprogramming dataset (static barcoding)}
\label{\detokenize{20210121_reprogramming_data_merge_tags:Reprogramming-dataset-(static-barcoding)}}\label{\detokenize{20210121_reprogramming_data_merge_tags::doc}}
The reprogramming dataset from \sphinxstyleemphasis{Biddy, B. A. et al. Nature 564, 219\textendash{}224 (2018)}. This dataset has multiple time points for both the clones and the state measurements.

The cells are barcoded over 3 rounds during the entire differentiation process. We combine up to 3 tags from the same cell into a single clonal label in representing the X\_clone matrix. In this representation, each cell has at most one clonal label. Effectively, we convert the barcodes into static labels that do not carry temporal information.

\sphinxstylestrong{Key components}:
\begin{itemize}
\item {} 
Part 1: Infer transition map using clones from all time points

\item {} 
Part II: Infer transition map using clones from the last time point

\item {} 
Part III: Infer transition map from state information alone

\end{itemize}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[1]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{k+kn}{import} \PYG{n+nn}{cospar} \PYG{k}{as} \PYG{n+nn}{cs}
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[2]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{logging}\PYG{o}{.}\PYG{n}{print\PYGZus{}version}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{verbosity}\PYG{o}{=}\PYG{l+m+mi}{3}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{set\PYGZus{}figure\PYGZus{}params}\PYG{p}{(}\PYG{n+nb}{format}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{png}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{dpi}\PYG{o}{=}\PYG{l+m+mi}{75}\PYG{p}{,}\PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{14}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} use png to reduce file size.}

\PYG{n}{cs}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{data\PYGZus{}path}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{CellTag\PYGZus{}data\PYGZus{}1}\PYG{l+s+s1}{\PYGZsq{}} \PYG{c+c1}{\PYGZsh{} A relative path to save data. If not existed before, create a new one.}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{figure\PYGZus{}path}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{CellTag\PYGZus{}figure\PYGZus{}1}\PYG{l+s+s1}{\PYGZsq{}} \PYG{c+c1}{\PYGZsh{} A relative path to save figures. If not existed before, create a new one.}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Running cospar 0.0.2 (python 3.6.12) on 2021-01-31 19:05.
\end{sphinxVerbatim}
}


\subsection{Load data}
\label{\detokenize{20210121_reprogramming_data_merge_tags:Load-data}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[3]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{adata\PYGZus{}orig}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{datasets}\PYG{o}{.}\PYG{n}{reprogramming\PYGZus{}merge\PYGZus{}tags}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
creating directory CellTag\_data\_1/ for saving data
creating directory CellTag\_figure\_1/ for saving figures
try downloading from url
https://kleintools.hms.harvard.edu/tools/downloads/cospar/CellTagging\_ConcatenateClone\_adata\_preprocessed.h5ad
{\ldots} this may take a while but only happens once
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
HBox(children=(HTML(value=''), FloatProgress(value=0.0, max=156534930.0), HTML(value='')))
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]

\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[4]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{embedding}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{state\PYGZus{}info}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=556\sphinxpxdimen,height=274\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_6_0}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[5]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{hf}\PYG{o}{.}\PYG{n}{check\PYGZus{}available\PYGZus{}choices}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Available transition maps: []
Availabel clusters: ['3', '16', '19', '18', '12', 'Reprogrammed', '13', '0', '15', '22', '4', '8', '5', '20', '7', '10', '2', 'Failed', '11', '21', '9']
Availabel time points: ['7', '8', '3', '5', '6', '4']
Clonal time points: ['7', '8', '3', '5', '6', '4']
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[6]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{re\PYGZus{}propressing}\PYG{o}{=}\PYG{k+kc}{False}
\PYG{k}{if} \PYG{n}{re\PYGZus{}propressing}\PYG{p}{:}
    \PYG{n}{cs}\PYG{o}{.}\PYG{n}{pp}\PYG{o}{.}\PYG{n}{get\PYGZus{}highly\PYGZus{}variable\PYGZus{}genes}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{)}
    \PYG{n}{cs}\PYG{o}{.}\PYG{n}{pp}\PYG{o}{.}\PYG{n}{remove\PYGZus{}cell\PYGZus{}cycle\PYGZus{}correlated\PYGZus{}genes}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{corr\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mf}{0.03}\PYG{p}{,}\PYG{n}{confirm\PYGZus{}change}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
    \PYG{n}{cs}\PYG{o}{.}\PYG{n}{pp}\PYG{o}{.}\PYG{n}{get\PYGZus{}X\PYGZus{}pca}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{n\PYGZus{}pca\PYGZus{}comp}\PYG{o}{=}\PYG{l+m+mi}{40}\PYG{p}{)}
    \PYG{n}{cs}\PYG{o}{.}\PYG{n}{pp}\PYG{o}{.}\PYG{n}{get\PYGZus{}X\PYGZus{}emb}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{n\PYGZus{}neighbors}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{n}{umap\PYGZus{}min\PYGZus{}dist}\PYG{o}{=}\PYG{l+m+mf}{0.3}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}cs.pp.get\PYGZus{}state\PYGZus{}info(adata\PYGZus{}orig,leiden\PYGZus{}resolution=0.5) \PYGZsh{} if this is changed, the cluster name used later will be wrong.}
    \PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{embedding}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{time\PYGZus{}info}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}
}


\subsubsection{Raw clonal data analysis (without using state information)}
\label{\detokenize{20210121_reprogramming_data_merge_tags:Raw-clonal-data-analysis-(without-using-state-information)}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[7]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{c+c1}{\PYGZsh{}cs.pl.clones\PYGZus{}on\PYGZus{}manifold(adata\PYGZus{}orig,selected\PYGZus{}clone\PYGZus{}list=[1],color\PYGZus{}list=[\PYGZsq{}black\PYGZsq{},\PYGZsq{}red\PYGZsq{},\PYGZsq{}blue\PYGZsq{}],point\PYGZus{}size=2)}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{clones\PYGZus{}on\PYGZus{}manifold}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{selected\PYGZus{}clone\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{324}\PYG{p}{,}\PYG{l+m+mi}{313}\PYG{p}{]}\PYG{p}{,}\PYG{n}{point\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}324,313,446,716,367}

\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=247\sphinxpxdimen,height=184\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_10_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=247\sphinxpxdimen,height=184\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_10_1}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[8]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{plot\PYGZus{}time\PYGZus{}point}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{8}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Reprogrammed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Failed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}coupling\PYGZus{}from\PYGZus{}clones}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{plot\PYGZus{}time\PYGZus{}point}\PYG{p}{,} \PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{n}{selected\PYGZus{}fates}\PYG{p}{,} \PYG{n}{color\PYGZus{}bar}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=359\sphinxpxdimen,height=283\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_11_0}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[9]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{plot\PYGZus{}time\PYGZus{}point}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{8}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{barcode\PYGZus{}heatmap}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{plot\PYGZus{}time\PYGZus{}point}\PYG{p}{,} \PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{n}{selected\PYGZus{}fates}\PYG{p}{,} \PYG{n}{color\PYGZus{}bar}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=282\sphinxpxdimen,height=433\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_12_0}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[11]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{clonal\PYGZus{}fate\PYGZus{}bias}\PYG{p}{,}\PYG{n}{clone\PYGZus{}id}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{clonal\PYGZus{}fate\PYGZus{}bias}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fate}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Reprogrammed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{n}{clone\PYGZus{}size\PYGZus{}thresh}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{n}{N\PYGZus{}resampling}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{n}{compute\PYGZus{}new}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Current clone id: 0
Current clone id: 5
Current clone id: 10
Current clone id: 15
Current clone id: 20
Current clone id: 25
Current clone id: 30
Current clone id: 35
Current clone id: 40
Current clone id: 45
Current clone id: 50
Current clone id: 55
Current clone id: 60
Current clone id: 65
Current clone id: 70
Current clone id: 75
Current clone id: 80
Current clone id: 85
Current clone id: 90
Current clone id: 95
Current clone id: 100
Current clone id: 105
Current clone id: 110
Current clone id: 115
Current clone id: 120
Current clone id: 125
Current clone id: 130
Current clone id: 135
Current clone id: 140
Current clone id: 145
Current clone id: 150
Current clone id: 155
Current clone id: 160
Current clone id: 165
Current clone id: 170
Current clone id: 175
Current clone id: 180
Current clone id: 185
Current clone id: 190
Current clone id: 195
Current clone id: 200
Current clone id: 205
Current clone id: 210
Current clone id: 215
Current clone id: 220
Current clone id: 225
Current clone id: 230
Current clone id: 235
Current clone id: 240
Current clone id: 245
Current clone id: 250
Current clone id: 255
Current clone id: 260
Current clone id: 265
Current clone id: 270
Current clone id: 275
Current clone id: 280
Current clone id: 285
Current clone id: 290
Current clone id: 295
Current clone id: 300
Current clone id: 305
Current clone id: 310
Current clone id: 315
Current clone id: 320
Current clone id: 325
Current clone id: 330
Current clone id: 335
Current clone id: 340
Current clone id: 345
Current clone id: 350
Current clone id: 355
Current clone id: 360
Current clone id: 365
Current clone id: 370
Current clone id: 375
Current clone id: 380
Current clone id: 385
Current clone id: 390
Current clone id: 395
Current clone id: 400
Current clone id: 405
Current clone id: 410
Current clone id: 415
Current clone id: 420
Current clone id: 425
Current clone id: 430
Current clone id: 435
Current clone id: 440
Current clone id: 445
Current clone id: 450
Current clone id: 455
Current clone id: 460
Current clone id: 465
Current clone id: 470
Current clone id: 475
Current clone id: 480
Current clone id: 485
Current clone id: 490
Current clone id: 495
Current clone id: 500
Current clone id: 505
Current clone id: 510
Current clone id: 515
Current clone id: 520
Current clone id: 525
Current clone id: 530
Current clone id: 535
Current clone id: 540
Current clone id: 545
Current clone id: 550
Current clone id: 555
Current clone id: 560
Current clone id: 565
Current clone id: 570
Current clone id: 575
Current clone id: 580
Current clone id: 585
Current clone id: 590
Current clone id: 595
Current clone id: 600
Current clone id: 605
Current clone id: 610
Current clone id: 615
Current clone id: 620
Current clone id: 625
Current clone id: 630
Current clone id: 635
Current clone id: 640
Current clone id: 645
Current clone id: 650
Current clone id: 655
Current clone id: 660
Current clone id: 665
Current clone id: 670
Current clone id: 675
Current clone id: 680
Current clone id: 685
Current clone id: 690
Current clone id: 695
Current clone id: 700
Current clone id: 705
Current clone id: 710
Current clone id: 715
Current clone id: 720
Current clone id: 725
Current clone id: 730
Current clone id: 735
Current clone id: 740
Current clone id: 745
Current clone id: 750
Current clone id: 755
Current clone id: 760
Current clone id: 765
Current clone id: 770
Current clone id: 775
Current clone id: 780
Current clone id: 785
Current clone id: 790
Current clone id: 795
Current clone id: 800
Current clone id: 805
Current clone id: 810
Current clone id: 815
Current clone id: 820
Current clone id: 825
Current clone id: 830
Current clone id: 835
Current clone id: 840
Current clone id: 845
Current clone id: 850
Current clone id: 855
Current clone id: 860
Current clone id: 865
Current clone id: 870
Current clone id: 875
Current clone id: 880
Current clone id: 885
Current clone id: 890
Current clone id: 895
Current clone id: 900
Current clone id: 905
Current clone id: 910
Current clone id: 915
Current clone id: 920
Current clone id: 925
Current clone id: 930
Current clone id: 935
Current clone id: 940
Current clone id: 945
Current clone id: 950
Current clone id: 955
Current clone id: 960
Current clone id: 965
Current clone id: 970
Current clone id: 975
Current clone id: 980
Current clone id: 985
Current clone id: 990
Current clone id: 995
Current clone id: 1000
Current clone id: 1005
Current clone id: 1010
Current clone id: 1015
Current clone id: 1020
Current clone id: 1025
Current clone id: 1030
Current clone id: 1035
Current clone id: 1040
Current clone id: 1045
Current clone id: 1050
Current clone id: 1055
Current clone id: 1060
Current clone id: 1065
Current clone id: 1070
Current clone id: 1075
Current clone id: 1080
Current clone id: 1085
Current clone id: 1090
Current clone id: 1095
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=283\sphinxpxdimen,height=245\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_13_1}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=302\sphinxpxdimen,height=265\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_13_2}.png}

\end{nbsphinxfancyoutput}


\subsection{Part 1: Infer transition map using clones from all time points}
\label{\detokenize{20210121_reprogramming_data_merge_tags:Part-1:-Infer-transition-map-using-clones-from-all-time-points}}

\subsubsection{Map inference}
\label{\detokenize{20210121_reprogramming_data_merge_tags:Map-inference}}
Running it the first time takes 20 mins, 17 mins of which are used to compute the similarity matrix. When it is run again, it only takes 3 mins.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[12]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{noise\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mf}{0.2} \PYG{c+c1}{\PYGZsh{}}
\PYG{n}{selected\PYGZus{}clonal\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{5}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{6}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{7}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{8}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{c+c1}{\PYGZsh{}selected\PYGZus{}clonal\PYGZus{}time\PYGZus{}points=[\PYGZsq{}7\PYGZsq{},\PYGZsq{}8\PYGZsq{}]}
\PYG{n}{adata}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{tmap}\PYG{o}{.}\PYG{n}{infer\PYGZus{}Tmap\PYGZus{}from\PYGZus{}multitime\PYGZus{}clones}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{selected\PYGZus{}clonal\PYGZus{}time\PYGZus{}points}\PYG{p}{,}\PYG{n}{smooth\PYGZus{}array}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{15}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,}
        \PYG{n}{noise\PYGZus{}threshold}\PYG{o}{=}\PYG{n}{noise\PYGZus{}threshold}\PYG{p}{,}\PYG{n}{demulti\PYGZus{}threshold}\PYG{o}{=}\PYG{n}{noise\PYGZus{}threshold}\PYG{p}{,}\PYG{n}{use\PYGZus{}full\PYGZus{}Smatrix}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
-------Step 1: Select time points---------
--> Clonal cell fraction (day 3-4): 0.47126436781609193
--> Clonal cell fraction (day 4-5): 0.7685492801771872
--> Clonal cell fraction (day 5-6): 0.7980198019801981
--> Clonal cell fraction (day 6-7): 0.805352798053528
--> Clonal cell fraction (day 7-8): 0.8049918831168831
--> Clonal cell fraction (day 4-3): 0.07308970099667775
--> Clonal cell fraction (day 5-4): 0.6072607260726073
--> Clonal cell fraction (day 6-5): 0.8746958637469586
--> Clonal cell fraction (day 7-6): 0.8952922077922078
--> Clonal cell fraction (day 8-7): 0.9663468859448759
--> Numer of cells that are clonally related -- day 3: 41  and day 4: 66
--> Numer of cells that are clonally related -- day 4: 694  and day 5: 1840
--> Numer of cells that are clonally related -- day 5: 2418  and day 6: 2876
--> Numer of cells that are clonally related -- day 6: 2648  and day 7: 4412
--> Numer of cells that are clonally related -- day 7: 3967  and day 8: 6346
Valid clone number 'FOR' post selection 790
Cell number=17434, Clone number=790
-------Step 2: Compute the full Similarity matrix if necessary---------
Compute similarity matrix: computing new; beta=0.1
Smooth round: 1
--> Time elapsed: 0.1462101936340332
Smooth round: 2
--> Time elapsed: 0.6318700313568115
Smooth round: 3
--> Time elapsed: 4.058271884918213
--> Orignal sparsity=0.1440132780842932, Thresholding
--> Final sparsity=0.08134327961173121
similarity matrix truncated (Smooth round=3):  8.030797004699707
Smooth round: 4
--> Time elapsed: 10.500530004501343
--> Orignal sparsity=0.2782366721346004, Thresholding
--> Final sparsity=0.1435782907327997
similarity matrix truncated (Smooth round=4):  12.915031909942627
Smooth round: 5
--> Time elapsed: 15.246415138244629
--> Orignal sparsity=0.37387141506207067, Thresholding
--> Final sparsity=0.2072778864557119
similarity matrix truncated (Smooth round=5):  8.020248889923096
Save the matrix\textasciitilde{}\textasciitilde{}\textasciitilde{}
Smooth round: 6
--> Time elapsed: 21.41595482826233
--> Orignal sparsity=0.45353977091439257, Thresholding
--> Final sparsity=0.2689848859325567
similarity matrix truncated (Smooth round=6):  6.984263181686401
Smooth round: 7
--> Time elapsed: 34.1442928314209
--> Orignal sparsity=0.5228332749578013, Thresholding
--> Final sparsity=0.32826160348792477
similarity matrix truncated (Smooth round=7):  7.781483173370361
Smooth round: 8
--> Time elapsed: 30.63093614578247
--> Orignal sparsity=0.5844685765175182, Thresholding
--> Final sparsity=0.38362760964515485
similarity matrix truncated (Smooth round=8):  7.974940061569214
Smooth round: 9
--> Time elapsed: 35.917556285858154
--> Orignal sparsity=0.6382832981536288, Thresholding
--> Final sparsity=0.4347932758186628
similarity matrix truncated (Smooth round=9):  7.4193642139434814
Smooth round: 10
--> Time elapsed: 40.89142179489136
--> Orignal sparsity=0.6850691009500649, Thresholding
--> Final sparsity=0.48187784020689256
similarity matrix truncated (Smooth round=10):  9.044863224029541
Save the matrix\textasciitilde{}\textasciitilde{}\textasciitilde{}
Smooth round: 11
--> Time elapsed: 36.58433485031128
--> Orignal sparsity=0.7256668380762321, Thresholding
--> Final sparsity=0.5251253879869471
similarity matrix truncated (Smooth round=11):  7.607695817947388
Smooth round: 12
--> Time elapsed: 70.08605909347534
--> Orignal sparsity=0.7608566277859781, Thresholding
--> Final sparsity=0.5648926975432402
similarity matrix truncated (Smooth round=12):  9.646785020828247
Smooth round: 13
--> Time elapsed: 65.23817300796509
--> Orignal sparsity=0.7914519214016483, Thresholding
--> Final sparsity=0.6015221957973469
similarity matrix truncated (Smooth round=13):  11.143070936203003
Smooth round: 14
--> Time elapsed: 70.58985090255737
--> Orignal sparsity=0.8182097402031955, Thresholding
--> Final sparsity=0.6353063058254474
similarity matrix truncated (Smooth round=14):  8.404071807861328
Smooth round: 15
--> Time elapsed: 45.05844712257385
--> Orignal sparsity=0.8416467679655742, Thresholding
--> Final sparsity=0.6664864314513196
similarity matrix truncated (Smooth round=15):  7.536661148071289
Save the matrix\textasciitilde{}\textasciitilde{}\textasciitilde{}
-------Step 3: Optimize the transition map recursively---------
---------Compute the transition map-----------
Compute similarity matrix: load existing data
--> Time elapsed:  2.461054801940918
--> Time elapsed:  5.206609725952148
--> Time elapsed:  2.061098098754883
--> Time elapsed:  5.179265737533569
Compute similarity matrix: load existing data
--> Time elapsed:  1.8073961734771729
--> Time elapsed:  4.124726057052612
--> Time elapsed:  1.3285229206085205
--> Time elapsed:  4.872633934020996
Compute similarity matrix: load existing data
--> Time elapsed:  0.8039090633392334
--> Time elapsed:  3.964270830154419
--> Time elapsed:  0.9816751480102539
--> Time elapsed:  2.7839057445526123
Current iteration: 0
Use smooth\_round=15
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
--> Relative time point pair index: 1
--> Clone id: 0
--> Relative time point pair index: 2
--> Clone id: 0
--> Relative time point pair index: 3
--> Clone id: 0
--> Relative time point pair index: 4
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  33.08131003379822
Phase II: time elapsed --  55.68743395805359
Current iteration: 1
Use smooth\_round=10
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
--> Relative time point pair index: 1
--> Clone id: 0
--> Relative time point pair index: 2
--> Clone id: 0
--> Relative time point pair index: 3
--> Clone id: 0
--> Relative time point pair index: 4
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  14.042507886886597
Phase II: time elapsed --  31.260063886642456
Current iteration: 2
Use smooth\_round=5
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
--> Relative time point pair index: 1
--> Clone id: 0
--> Relative time point pair index: 2
--> Clone id: 0
--> Relative time point pair index: 3
--> Clone id: 0
--> Relative time point pair index: 4
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  12.665872812271118
Phase II: time elapsed --  29.531916856765747
No need for Final Smooth (i.e., clonally states are the final state space for Tmap)
----Demultiplexed transition map----
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
--> Relative time point pair index: 1
--> Clone id: 0
--> Relative time point pair index: 2
--> Clone id: 0
--> Relative time point pair index: 3
--> Clone id: 0
--> Relative time point pair index: 4
--> Clone id: 0
-----------Total used time: 1220.7262461185455 s ------------
Used--time: 1220.7797009944916
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=363\sphinxpxdimen,height=241\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_17_1}.png}

\end{nbsphinxfancyoutput}


\subsubsection{Save or load pre\sphinxhyphen{}computed data}
\label{\detokenize{20210121_reprogramming_data_merge_tags:Save-or-load-pre-computed-data}}
This can be used to save maps obtained from different parameter choices. Usually, different parameter choice will result to different ‘data\_des’, a prefix to define the map. Saving an adata would print the ‘data\_des’, which can be used to load the corresponding map.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[13]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{save\PYGZus{}data}\PYG{o}{=}\PYG{k+kc}{True}
\PYG{k}{if} \PYG{n}{save\PYGZus{}data}\PYG{p}{:}
    \PYG{n}{cs}\PYG{o}{.}\PYG{n}{hf}\PYG{o}{.}\PYG{n}{save\PYGZus{}map}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{)}

\PYG{n}{load\PYGZus{}data}\PYG{o}{=}\PYG{k+kc}{False}
\PYG{k}{if} \PYG{n}{load\PYGZus{}data}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{} Updated Jan 28, 2021}
    \PYG{c+c1}{\PYGZsh{}data\PYGZus{}des=\PYGZsq{}CellTagging\PYGZus{}TwoTimeClone\PYGZus{}t*3*4*5*6*7*8\PYGZsq{}}
    \PYG{n}{data\PYGZus{}des}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{CellTagging\PYGZus{}OneTimeClone\PYGZus{}t*3*4*5*6*7*8}\PYG{l+s+s1}{\PYGZsq{}}
    \PYG{n}{adata}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{hf}\PYG{o}{.}\PYG{n}{load\PYGZus{}saved\PYGZus{}adata\PYGZus{}with\PYGZus{}key}\PYG{p}{(}\PYG{n}{data\PYGZus{}des}\PYG{p}{)}

\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Saved file: data\_des='CellTagging\_TwoTimeClone\_t*3*4*5*6*7*8'
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[15]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{hf}\PYG{o}{.}\PYG{n}{check\PYGZus{}available\PYGZus{}choices}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Available transition maps: ['transition\_map', 'intraclone\_transition\_map']
Availabel clusters: ['3', '16', '19', '18', '12', 'Reprogrammed', '13', '0', '15', '22', '4', '8', '5', '20', '7', '10', '2', 'Failed', '11', '21', '9']
Availabel time points: ['7', '8', '3', '5', '6', '4']
Clonal time points: ['7', '8', '3', '5', '6', '4']
\end{sphinxVerbatim}
}


\subsection{Plotting}
\label{\detokenize{20210121_reprogramming_data_merge_tags:Plotting}}
There are some common parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{used\_map\_name}} (str). Determines which transition map to use for analysis. Choices: \{‘transition\_map’, ‘intraclone\_transition\_map’, ‘OT\_transition\_map’, ‘HighVar\_transition\_map’,’clonal\_transition\_map’\}

\item {} 
\sphinxcode{\sphinxupquote{selected\_fates}} (list of str). Selected clusters to aggregate differentiation dynamics and visualize fate bias etc.. The selected\_fates allows nested structure, e.g., selected\_fates={[}‘1’, {[}‘0’, ‘2’{]}{]} selects two clusters: cluster ‘1’ and the other that combines ‘0’ and ‘2’.

\item {} 
\sphinxcode{\sphinxupquote{map\_backwards}} (bool). We can analyze either the forward transitions, i.e., where the selected states or clusters are going (map\_backwards=False), or the backward transitions, i.e., where these selected states or clusters came from (map\_backwards=False). The latter is more useful, and is the default.

\item {} 
\sphinxcode{\sphinxupquote{plot\_time\_points}} (list). List of time points to use. By default, all are used.

\end{itemize}


\subsubsection{Plotting transition profiles for single cells}
\label{\detokenize{20210121_reprogramming_data_merge_tags:Plotting-transition-profiles-for-single-cells}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[16]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{selected\PYGZus{}state\PYGZus{}id\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1000}\PYG{p}{,}\PYG{l+m+mi}{3500}\PYG{p}{,}\PYG{l+m+mi}{6000}\PYG{p}{,}\PYG{l+m+mi}{5500}\PYG{p}{]}

\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{single\PYGZus{}cell\PYGZus{}transition}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}state\PYGZus{}id\PYGZus{}list}\PYG{o}{=}\PYG{n}{selected\PYGZus{}state\PYGZus{}id\PYGZus{}list}\PYG{p}{,}
                                    \PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=282\sphinxpxdimen,height=883\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_23_0}.png}

\end{nbsphinxfancyoutput}


\paragraph{Fate map}
\label{\detokenize{20210121_reprogramming_data_merge_tags:Fate-map}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[17]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}map}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Reprogrammed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Failed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
               \PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{intraclone\PYGZus{}transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=288\sphinxpxdimen,height=435\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_25_0}.png}

\end{nbsphinxfancyoutput}


\paragraph{Relative fate bias}
\label{\detokenize{20210121_reprogramming_data_merge_tags:Relative-fate-bias}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[18]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}bias\PYGZus{}intrinsic}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Reprogrammed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Failed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
            \PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=528\sphinxpxdimen,height=230\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_27_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=600\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_27_1}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[19]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}bias\PYGZus{}from\PYGZus{}binary\PYGZus{}competition}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Reprogrammed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Failed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
            \PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{7}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{sum\PYGZus{}fate\PYGZus{}prob\PYGZus{}thresh}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=318\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_28_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=302\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_28_1}.png}

\end{nbsphinxfancyoutput}


\paragraph{Identify differentially expressed genes}
\label{\detokenize{20210121_reprogramming_data_merge_tags:Identify-differentially-expressed-genes}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[20]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{dynamic\PYGZus{}trajectory\PYGZus{}from\PYGZus{}competition\PYGZus{}bias}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,} \PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Reprogrammed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Failed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
 \PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}
    \PYG{n}{bias\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{sum\PYGZus{}fate\PYGZus{}prob\PYGZus{}thresh}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{n}{avoid\PYGZus{}target\PYGZus{}states}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}

\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=583\sphinxpxdimen,height=283\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_30_0}.png}

\end{nbsphinxfancyoutput}


\paragraph{Differential genes for two ancestor groups}
\label{\detokenize{20210121_reprogramming_data_merge_tags:Differential-genes-for-two-ancestor-groups}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[21]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{dge\PYGZus{}gene\PYGZus{}A}\PYG{p}{,} \PYG{n}{dge\PYGZus{}gene\PYGZus{}B}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{differential\PYGZus{}genes}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{plot\PYGZus{}gene\PYGZus{}N}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=583\sphinxpxdimen,height=283\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_32_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=472\sphinxpxdimen,height=171\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_32_1}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=472\sphinxpxdimen,height=171\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_32_2}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[22]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{c+c1}{\PYGZsh{} All, ranked, DGE genes for group A}
\PYG{n}{dge\PYGZus{}gene\PYGZus{}A}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxout}[22]:\,\hspace{\fboxrule}\hspace{\fboxsep}}         gene             pv    mean\_1      mean\_2     ratio
10      Apoa1  1.061060e-245  5.941834  123.686348 -4.166843
29       Ctgf  2.061783e-173  0.865551    6.773607 -2.058983
511      Kng1   7.617055e-25  0.899244    5.939509 -1.869408
43    S100a13  3.075840e-144  1.659719    7.623402 -1.696983
3       Timp3  2.261970e-284  5.562981   19.726454 -1.659050
..        {\ldots}            {\ldots}       {\ldots}         {\ldots}       {\ldots}
204     Tpd52   1.026880e-55  0.486977    1.223368 -0.580364
354     Mmp15   1.016207e-35  0.065997    0.587256 -0.574332
269    Calml4   6.892886e-45  0.731211    1.570095 -0.570040
270       Cfb   7.787499e-45  0.647714    1.445904 -0.569902
331  Rasgef1b   3.800116e-38  0.188547    0.762722 -0.568606

[100 rows x 5 columns]
\end{sphinxVerbatim}
}


\paragraph{Map trajectory backwards iteratively}
\label{\detokenize{20210121_reprogramming_data_merge_tags:Map-trajectory-backwards-iteratively}}
From our experience, it is better to use the intra\sphinxhyphen{}clone transition map to compute the trajectory

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[23]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{c+c1}{\PYGZsh{} plot each tiem point separately, use the transition map.}

\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{dynamic\PYGZus{}trajectory\PYGZus{}via\PYGZus{}iterative\PYGZus{}mapping}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fate}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Failed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{map\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{n}{plot\PYGZus{}separately}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{apply\PYGZus{}time\PYGZus{}constaint}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{point\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=1432\sphinxpxdimen,height=237\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_36_0}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[24]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{c+c1}{\PYGZsh{} plot each tiem point separately, use the transition map.}

\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{dynamic\PYGZus{}trajectory\PYGZus{}via\PYGZus{}iterative\PYGZus{}mapping}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fate}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Reprogrammed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{map\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mf}{0.3}\PYG{p}{,} \PYG{n}{plot\PYGZus{}separately}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{apply\PYGZus{}time\PYGZus{}constaint}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{point\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=1432\sphinxpxdimen,height=237\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_37_0}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[25]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{c+c1}{\PYGZsh{} plot each tiem point separately, use the intra\PYGZhy{}clone transition map.}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{dynamic\PYGZus{}trajectory\PYGZus{}via\PYGZus{}iterative\PYGZus{}mapping}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fate}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Reprogrammed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                        \PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{intraclone\PYGZus{}transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{map\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mf}{0.05}\PYG{p}{,} \PYG{n}{plot\PYGZus{}separately}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{apply\PYGZus{}time\PYGZus{}constaint}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{point\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=1432\sphinxpxdimen,height=237\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_38_0}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[26]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{c+c1}{\PYGZsh{} plot each tiem point separately, use the intra\PYGZhy{}clone transition map.}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{dynamic\PYGZus{}trajectory\PYGZus{}via\PYGZus{}iterative\PYGZus{}mapping}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fate}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Failed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                        \PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{intraclone\PYGZus{}transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{map\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mf}{0.05}\PYG{p}{,} \PYG{n}{plot\PYGZus{}separately}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{apply\PYGZus{}time\PYGZus{}constaint}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{point\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=1432\sphinxpxdimen,height=237\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_39_0}.png}

\end{nbsphinxfancyoutput}


\paragraph{Gene trend along the trajectory}
\label{\detokenize{20210121_reprogramming_data_merge_tags:Gene-trend-along-the-trajectory}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[27]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{c+c1}{\PYGZsh{} The results are based on pre\PYGZhy{}computed dynamic trajectories from the immediate previous step}
\PYG{c+c1}{\PYGZsh{} better to use the \PYGZsq{}intraclone transition map\PYGZsq{}}

\PYG{n}{gene\PYGZus{}name\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Col1a2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Apoa1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Peg3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Spint2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mettl7a1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cdh1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{selected\PYGZus{}fate}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Failed}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{adata\PYGZus{}selected}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{gene\PYGZus{}expression\PYGZus{}dynamics}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fate}\PYG{p}{,}\PYG{n}{gene\PYGZus{}name\PYGZus{}list}\PYG{p}{,} \PYG{n}{traj\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{,}
      \PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{invert\PYGZus{}PseudoTime}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{include\PYGZus{}target\PYGZus{}states}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{compute\PYGZus{}new}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}
    \PYG{n}{fig\PYGZus{}width}\PYG{o}{=}\PYG{l+m+mf}{3.5}\PYG{p}{,} \PYG{n}{gene\PYGZus{}exp\PYGZus{}percentile}\PYG{o}{=}\PYG{l+m+mi}{99}\PYG{p}{,} \PYG{n}{n\PYGZus{}neighbors}\PYG{o}{=}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{n}{plot\PYGZus{}raw\PYGZus{}data}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{point\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}

\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{nbsphinx-stderr}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
/Users/shouwenwang/miniconda3/envs/CoSpar\_env/lib/python3.6/site-packages/plotnine/ggplot.py:729: PlotnineWarning: Saving 3.5 x 2.163 in image.
/Users/shouwenwang/miniconda3/envs/CoSpar\_env/lib/python3.6/site-packages/plotnine/ggplot.py:730: PlotnineWarning: Filename: CellTag\_figure\_1/CellTagging\_TwoTimeClone\_t*3*4*5*6*7*8\_fate\_trajectory\_pseutoTime\_gene\_expression\_Failed\_True.png
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=718\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_41_1}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=702\sphinxpxdimen,height=429\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_41_2}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[28]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{c+c1}{\PYGZsh{} The results are based on pre\PYGZhy{}computed dynamic trajectories from a previous step}
\PYG{c+c1}{\PYGZsh{} better to use the \PYGZsq{}intraclone transition map\PYGZsq{}}

\PYG{n}{gene\PYGZus{}name\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Col1a2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Apoa1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Peg3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Spint2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mettl7a1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cdh1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{selected\PYGZus{}fate}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Reprogrammed}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{adata\PYGZus{}selected}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{gene\PYGZus{}expression\PYGZus{}dynamics}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fate}\PYG{p}{,}\PYG{n}{gene\PYGZus{}name\PYGZus{}list}\PYG{p}{,} \PYG{n}{traj\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{,}
      \PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{invert\PYGZus{}PseudoTime}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{include\PYGZus{}target\PYGZus{}states}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{compute\PYGZus{}new}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}
    \PYG{n}{fig\PYGZus{}width}\PYG{o}{=}\PYG{l+m+mf}{3.5}\PYG{p}{,} \PYG{n}{gene\PYGZus{}exp\PYGZus{}percentile}\PYG{o}{=}\PYG{l+m+mi}{99}\PYG{p}{,} \PYG{n}{n\PYGZus{}neighbors}\PYG{o}{=}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{n}{plot\PYGZus{}raw\PYGZus{}data}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{point\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}

\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{nbsphinx-stderr}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
/Users/shouwenwang/miniconda3/envs/CoSpar\_env/lib/python3.6/site-packages/plotnine/ggplot.py:729: PlotnineWarning: Saving 3.5 x 2.163 in image.
/Users/shouwenwang/miniconda3/envs/CoSpar\_env/lib/python3.6/site-packages/plotnine/ggplot.py:730: PlotnineWarning: Filename: CellTag\_figure\_1/CellTagging\_TwoTimeClone\_t*3*4*5*6*7*8\_fate\_trajectory\_pseutoTime\_gene\_expression\_Reprogrammed\_True.png
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=718\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_42_1}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=695\sphinxpxdimen,height=429\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_42_2}.png}

\end{nbsphinxfancyoutput}


\subsubsection{Transition map from only clonal information}
\label{\detokenize{20210121_reprogramming_data_merge_tags:Transition-map-from-only-clonal-information}}
Assume uniform transition within the same clone

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[29]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{tmap}\PYG{o}{.}\PYG{n}{infer\PYGZus{}Tmap\PYGZus{}from\PYGZus{}clonal\PYGZus{}info\PYGZus{}alone}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{method}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{naive}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}bias\PYGZus{}from\PYGZus{}binary\PYGZus{}competition}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Reprogrammed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Failed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{clonal\PYGZus{}transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
            \PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{sum\PYGZus{}fate\PYGZus{}prob\PYGZus{}thresh}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=318\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_44_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=310\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_44_1}.png}

\end{nbsphinxfancyoutput}


\subsection{Part II: Infer transition map using clones from the last time point}
\label{\detokenize{20210121_reprogramming_data_merge_tags:Part-II:-Infer-transition-map-using-clones-from-the-last-time-point}}
It takes 12 mins to compute for the first time (excluding the time for computing similarity matrix); and 5 mins later.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[30]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{initial\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{5}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{6}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{7}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{clonal\PYGZus{}time\PYGZus{}point}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{8}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{n}{adata}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{tmap}\PYG{o}{.}\PYG{n}{infer\PYGZus{}Tmap\PYGZus{}from\PYGZus{}one\PYGZus{}time\PYGZus{}clones}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{initial\PYGZus{}time\PYGZus{}points}\PYG{p}{,}\PYG{n}{clonal\PYGZus{}time\PYGZus{}point}\PYG{p}{,}
        \PYG{n}{initialize\PYGZus{}method}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{OT}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{OT\PYGZus{}cost}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{SPD}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{smooth\PYGZus{}array}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{15}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,}\PYG{n}{noise\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{,}\PYG{n}{use\PYGZus{}full\PYGZus{}Smatrix}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
-------------------------------New Start--------------------------------------------------
Current time point: 3
-----------Pre-processing and sub-sampling cells------------
----------------
Step 1: Use OT method for initialization
Compute new shortest path distance matrix
--> Chosen mode is distances
Finishing computing shortest-path distance, used time 29.862331867218018
Compute new custon OT matrix
OT solver: duality\_gap
Finishing computing optial transport map, used time 1.2392089366912842
----------------
Step 2: Jointly optimize the transition map and the initial clonal states!
Joint optimization that consider possibility of clonal overlap: v2
--> original clone shape: (6654, 414)
--> After excluding zero-sized clones at t2: (6654, 348)
Sort clones by size (small to large)
Infer the number of initial cells to extract for each clone in advance
--> Inferring early clonal states: current clone id 0
--> Inferring early clonal states: current clone id 100
--> Inferring early clonal states: current clone id 200
--> Inferring early clonal states: current clone id 300
---------Compute the transition map-----------
Compute similarity matrix: load existing data
--> Time elapsed:  0.0015919208526611328
--> Time elapsed:  0.568378210067749
--> Time elapsed:  0.0016720294952392578
--> Time elapsed:  0.5150761604309082
Compute similarity matrix: load existing data
--> Time elapsed:  0.0009791851043701172
--> Time elapsed:  0.43868112564086914
--> Time elapsed:  0.00109100341796875
--> Time elapsed:  0.46360301971435547
Compute similarity matrix: load existing data
--> Time elapsed:  0.0005650520324707031
--> Time elapsed:  0.3390321731567383
--> Time elapsed:  0.0009012222290039062
--> Time elapsed:  0.3096041679382324
Current iteration: 0
Use smooth\_round=15
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  0.8483231067657471
Phase II: time elapsed --  0.850473165512085
Current iteration: 1
Use smooth\_round=10
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  0.5068161487579346
Phase II: time elapsed --  0.5087811946868896
Current iteration: 2
Use smooth\_round=5
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  0.4799518585205078
Phase II: time elapsed --  0.48163890838623047
No need for Final Smooth (i.e., clonally states are the final state space for Tmap)
----Demultiplexed transition map----
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Finishing computing transport map from CoSpar using inferred clonal data, used time 37.015310287475586
-------------------------------New Start--------------------------------------------------
Current time point: 4
-----------Pre-processing and sub-sampling cells------------
----------------
Step 1: Use OT method for initialization
Compute new shortest path distance matrix
--> Chosen mode is distances
Finishing computing shortest-path distance, used time 34.604453802108765
Compute new custon OT matrix
OT solver: duality\_gap
Finishing computing optial transport map, used time 11.564520120620728
----------------
Step 2: Jointly optimize the transition map and the initial clonal states!
Joint optimization that consider possibility of clonal overlap: v2
--> original clone shape: (7470, 784)
--> After excluding zero-sized clones at t2: (7470, 348)
Sort clones by size (small to large)
Infer the number of initial cells to extract for each clone in advance
--> Inferring early clonal states: current clone id 0
--> Inferring early clonal states: current clone id 100
--> Inferring early clonal states: current clone id 200
--> Inferring early clonal states: current clone id 300
---------Compute the transition map-----------
Compute similarity matrix: load existing data
--> Time elapsed:  0.014209985733032227
--> Time elapsed:  0.46343207359313965
--> Time elapsed:  0.012888669967651367
--> Time elapsed:  0.42757511138916016
Compute similarity matrix: load existing data
--> Time elapsed:  0.00722503662109375
--> Time elapsed:  0.3724937438964844
--> Time elapsed:  0.009593725204467773
--> Time elapsed:  0.37938594818115234
Compute similarity matrix: load existing data
--> Time elapsed:  0.005547046661376953
--> Time elapsed:  0.18985390663146973
--> Time elapsed:  0.007561922073364258
--> Time elapsed:  0.21970820426940918
Current iteration: 0
Use smooth\_round=15
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  3.0836470127105713
Phase II: time elapsed --  3.1541261672973633
Current iteration: 1
Use smooth\_round=10
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  0.7445199489593506
Phase II: time elapsed --  0.8099980354309082
Current iteration: 2
Use smooth\_round=5
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  0.5406358242034912
Phase II: time elapsed --  0.6106979846954346
No need for Final Smooth (i.e., clonally states are the final state space for Tmap)
----Demultiplexed transition map----
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Finishing computing transport map from CoSpar using inferred clonal data, used time 40.18401598930359
-------------------------------New Start--------------------------------------------------
Current time point: 5
-----------Pre-processing and sub-sampling cells------------
----------------
Step 1: Use OT method for initialization
Compute new shortest path distance matrix
--> Chosen mode is distances
Finishing computing shortest-path distance, used time 58.737828969955444
Compute new custon OT matrix
OT solver: duality\_gap
Finishing computing optial transport map, used time 35.35010886192322
----------------
Step 2: Jointly optimize the transition map and the initial clonal states!
Joint optimization that consider possibility of clonal overlap: v2
--> original clone shape: (9597, 1038)
--> After excluding zero-sized clones at t2: (9597, 348)
Sort clones by size (small to large)
Infer the number of initial cells to extract for each clone in advance
--> Inferring early clonal states: current clone id 0
--> Inferring early clonal states: current clone id 100
--> Inferring early clonal states: current clone id 200
--> Inferring early clonal states: current clone id 300
---------Compute the transition map-----------
Compute similarity matrix: load existing data
--> Time elapsed:  0.12756109237670898
--> Time elapsed:  0.43659496307373047
--> Time elapsed:  0.12559223175048828
--> Time elapsed:  0.4278299808502197
Compute similarity matrix: load existing data
--> Time elapsed:  0.09239411354064941
--> Time elapsed:  0.37059712409973145
--> Time elapsed:  0.09299731254577637
--> Time elapsed:  0.349837064743042
Compute similarity matrix: load existing data
--> Time elapsed:  0.07923197746276855
--> Time elapsed:  0.2145400047302246
--> Time elapsed:  0.07623767852783203
--> Time elapsed:  0.20181512832641602
Current iteration: 0
Use smooth\_round=15
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  9.086640119552612
Phase II: time elapsed --  9.66569995880127
Current iteration: 1
Use smooth\_round=10
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  1.6230919361114502
Phase II: time elapsed --  2.3093152046203613
Current iteration: 2
Use smooth\_round=5
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  0.8150079250335693
Phase II: time elapsed --  1.469419002532959
No need for Final Smooth (i.e., clonally states are the final state space for Tmap)
----Demultiplexed transition map----
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Finishing computing transport map from CoSpar using inferred clonal data, used time 52.83109521865845
-------------------------------New Start--------------------------------------------------
Current time point: 6
-----------Pre-processing and sub-sampling cells------------
----------------
Step 1: Use OT method for initialization
Compute new shortest path distance matrix
--> Chosen mode is distances
Finishing computing shortest-path distance, used time 61.78106498718262
Compute new custon OT matrix
OT solver: duality\_gap
Finishing computing optial transport map, used time 39.69208097457886
----------------
Step 2: Jointly optimize the transition map and the initial clonal states!
Joint optimization that consider possibility of clonal overlap: v2
--> original clone shape: (9855, 903)
--> After excluding zero-sized clones at t2: (9855, 348)
Sort clones by size (small to large)
Infer the number of initial cells to extract for each clone in advance
--> Inferring early clonal states: current clone id 0
--> Inferring early clonal states: current clone id 100
--> Inferring early clonal states: current clone id 200
--> Inferring early clonal states: current clone id 300
---------Compute the transition map-----------
Compute similarity matrix: load existing data
--> Time elapsed:  0.12160992622375488
--> Time elapsed:  0.4239342212677002
--> Time elapsed:  0.13516592979431152
--> Time elapsed:  0.45110225677490234
Compute similarity matrix: load existing data
--> Time elapsed:  0.15372896194458008
--> Time elapsed:  0.34644126892089844
--> Time elapsed:  0.11916685104370117
--> Time elapsed:  0.34626102447509766
Compute similarity matrix: load existing data
--> Time elapsed:  0.08623170852661133
--> Time elapsed:  0.2085731029510498
--> Time elapsed:  0.09159111976623535
--> Time elapsed:  0.20116090774536133
Current iteration: 0
Use smooth\_round=15
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  10.137753009796143
Phase II: time elapsed --  10.834695100784302
Current iteration: 1
Use smooth\_round=10
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  1.6164088249206543
Phase II: time elapsed --  2.4393677711486816
Current iteration: 2
Use smooth\_round=5
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  0.8946599960327148
Phase II: time elapsed --  1.607361078262329
No need for Final Smooth (i.e., clonally states are the final state space for Tmap)
----Demultiplexed transition map----
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Finishing computing transport map from CoSpar using inferred clonal data, used time 55.39346194267273
-------------------------------New Start--------------------------------------------------
Current time point: 7
-----------Pre-processing and sub-sampling cells------------
----------------
Step 1: Use OT method for initialization
Compute new shortest path distance matrix
--> Chosen mode is distances
Finishing computing shortest-path distance, used time 89.31214118003845
Compute new custon OT matrix
OT solver: duality\_gap
Finishing computing optial transport map, used time 74.63937878608704
----------------
Step 2: Jointly optimize the transition map and the initial clonal states!
Joint optimization that consider possibility of clonal overlap: v2
--> original clone shape: (11495, 755)
--> After excluding zero-sized clones at t2: (11495, 348)
Sort clones by size (small to large)
Infer the number of initial cells to extract for each clone in advance
--> Inferring early clonal states: current clone id 0
--> Inferring early clonal states: current clone id 100
--> Inferring early clonal states: current clone id 200
--> Inferring early clonal states: current clone id 300
---------Compute the transition map-----------
Compute similarity matrix: load existing data
--> Time elapsed:  0.4853849411010742
--> Time elapsed:  0.8712310791015625
--> Time elapsed:  0.3859226703643799
--> Time elapsed:  0.5718529224395752
Compute similarity matrix: load existing data
--> Time elapsed:  0.34917783737182617
--> Time elapsed:  0.4595940113067627
--> Time elapsed:  0.288179874420166
--> Time elapsed:  0.4204981327056885
Compute similarity matrix: load existing data
--> Time elapsed:  0.20076727867126465
--> Time elapsed:  0.3278007507324219
--> Time elapsed:  0.1556720733642578
--> Time elapsed:  0.2803492546081543
Current iteration: 0
Use smooth\_round=15
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  15.601884841918945
Phase II: time elapsed --  17.08461594581604
Current iteration: 1
Use smooth\_round=10
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  2.6450207233428955
Phase II: time elapsed --  4.203082799911499
Current iteration: 2
Use smooth\_round=5
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  1.9045066833496094
Phase II: time elapsed --  3.522645950317383
No need for Final Smooth (i.e., clonally states are the final state space for Tmap)
----Demultiplexed transition map----
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Finishing computing transport map from CoSpar using inferred clonal data, used time 74.41073203086853
-----------Total used time: 709.7741031646729 s ------------
Total time: 709.8692650794983
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[31]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{hf}\PYG{o}{.}\PYG{n}{check\PYGZus{}available\PYGZus{}choices}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Available transition maps: ['transition\_map', 'OT\_transition\_map']
Availabel clusters: ['3', '16', '19', '18', '12', 'Reprogrammed', '13', '0', '15', '22', '4', '8', '5', '20', '7', '10', '2', 'Failed', '11', '21', '9']
Availabel time points: ['7', '8', '3', '5', '6', '4']
Clonal time points: ['7', '8', '3', '5', '6', '4']
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[32]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}map}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Reprogrammed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Failed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
               \PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}
               \PYG{n}{plot\PYGZus{}color\PYGZus{}bar}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}\PYG{n}{plot\PYGZus{}background}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}\PYG{n}{auto\PYGZus{}color\PYGZus{}scale}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}\PYG{n}{plot\PYGZus{}horizontal}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=538\sphinxpxdimen,height=230\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_50_0}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[33]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}bias\PYGZus{}from\PYGZus{}binary\PYGZus{}competition}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Reprogrammed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Failed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
            \PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{sum\PYGZus{}fate\PYGZus{}prob\PYGZus{}thresh}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=318\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_52_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=310\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_52_1}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[34]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}bias\PYGZus{}from\PYGZus{}binary\PYGZus{}competition}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Reprogrammed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Failed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{OT\PYGZus{}transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
            \PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{sum\PYGZus{}fate\PYGZus{}prob\PYGZus{}thresh}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=318\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_53_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=310\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_53_1}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[35]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{dynamic\PYGZus{}trajectory\PYGZus{}from\PYGZus{}competition\PYGZus{}bias}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,} \PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Reprogrammed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Failed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
 \PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}
    \PYG{n}{bias\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{sum\PYGZus{}fate\PYGZus{}prob\PYGZus{}thresh}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{n}{avoid\PYGZus{}target\PYGZus{}states}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}

\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=583\sphinxpxdimen,height=283\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_55_0}.png}

\end{nbsphinxfancyoutput}

The selected states, combined with the target states are stored as dynamic trajectory at adata.uns{[}‘dynamic\_trajectory’{]}. We can plot gene trend along this trajectory

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[36]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{gene\PYGZus{}name\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Col1a2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Apoa1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Peg3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Spint2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mettl7a1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cdh1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{selected\PYGZus{}fate}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Reprogrammed}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{adata\PYGZus{}selected}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{gene\PYGZus{}expression\PYGZus{}dynamics}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fate}\PYG{p}{,}\PYG{n}{gene\PYGZus{}name\PYGZus{}list}\PYG{p}{,} \PYG{n}{traj\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{,}
      \PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{invert\PYGZus{}PseudoTime}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{include\PYGZus{}target\PYGZus{}states}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{nbsphinx-stderr}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
/Users/shouwenwang/miniconda3/envs/CoSpar\_env/lib/python3.6/site-packages/plotnine/ggplot.py:729: PlotnineWarning: Saving 3.5 x 2.163 in image.
/Users/shouwenwang/miniconda3/envs/CoSpar\_env/lib/python3.6/site-packages/plotnine/ggplot.py:730: PlotnineWarning: Filename: CellTag\_figure\_1/CellTagging\_OneTimeClone\_t*3*4*5*6*7*8\_fate\_trajectory\_pseutoTime\_gene\_expression\_Reprogrammed\_True.png
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=718\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_58_1}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=695\sphinxpxdimen,height=429\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_58_2}.png}

\end{nbsphinxfancyoutput}


\subsection{Part III: Infer transition map from state information alone}
\label{\detokenize{20210121_reprogramming_data_merge_tags:Part-III:-Infer-transition-map-from-state-information-alone}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[37]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{initial\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{6}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{7}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{target\PYGZus{}time\PYGZus{}point}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{8}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{n}{adata}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{tmap}\PYG{o}{.}\PYG{n}{infer\PYGZus{}Tmap\PYGZus{}from\PYGZus{}state\PYGZus{}info\PYGZus{}alone}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{initial\PYGZus{}time\PYGZus{}points}\PYG{p}{,}\PYG{n}{target\PYGZus{}time\PYGZus{}point}\PYG{p}{,}
        \PYG{n}{method}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{OT}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{OT\PYGZus{}cost}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{SPD}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
-------------------------------New Start--------------------------------------------------
Current time point: 6
-----------Pre-processing and sub-sampling cells------------
----------------
Step 1: Use OT method for initialization
Load pre-computed shortest path distance matrix
Load pre-computed custon OT matrix
-------------------------------New Start--------------------------------------------------
Current time point: 7
-----------Pre-processing and sub-sampling cells------------
----------------
Step 1: Use OT method for initialization
Load pre-computed shortest path distance matrix
Load pre-computed custon OT matrix
-----------Total used time: 4.846709728240967 s ------------
Total time: 4.882646083831787
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[38]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{hf}\PYG{o}{.}\PYG{n}{check\PYGZus{}available\PYGZus{}choices}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Available transition maps: ['OT\_transition\_map']
Availabel clusters: ['7', '13', '10', '0', 'Failed', '8', '3', '5', '11', '21', '15', '16', '20', '12', '22', '9', '19', '18', 'Reprogrammed', '4']
Availabel time points: ['7', '6', '8']
Clonal time points: ['7', '6', '8']
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[39]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}map}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Reprogrammed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Failed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
               \PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{OT\PYGZus{}transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=288\sphinxpxdimen,height=435\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_63_0}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[40]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}bias\PYGZus{}from\PYGZus{}binary\PYGZus{}competition}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Reprogrammed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Failed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{OT\PYGZus{}transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
            \PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{sum\PYGZus{}fate\PYGZus{}prob\PYGZus{}thresh}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=318\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_65_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=310\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_65_1}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[41]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{dynamic\PYGZus{}trajectory\PYGZus{}from\PYGZus{}intrinsic\PYGZus{}bias}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,} \PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Reprogrammed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Failed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
 \PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{OT\PYGZus{}transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}
    \PYG{n}{bias\PYGZus{}threshold\PYGZus{}A}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{bias\PYGZus{}threshold\PYGZus{}B}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{avoid\PYGZus{}target\PYGZus{}states}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}

\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=583\sphinxpxdimen,height=283\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_67_0}.png}

\end{nbsphinxfancyoutput}

The selected states, combined with the target states are stored as dynamic trajectory at \sphinxcode{\sphinxupquote{adata.uns{[}\textquotesingle{}dynamic\_trajectory\textquotesingle{}{]}}}. We can plot gene trend along this trajectory

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[42]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{gene\PYGZus{}name\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Col1a2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Apoa1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Peg3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Spint2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mettl7a1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cdh1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{selected\PYGZus{}fate}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Reprogrammed}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{adata\PYGZus{}selected}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{gene\PYGZus{}expression\PYGZus{}dynamics}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fate}\PYG{p}{,}\PYG{n}{gene\PYGZus{}name\PYGZus{}list}\PYG{p}{,} \PYG{n}{traj\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{,}
      \PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{invert\PYGZus{}PseudoTime}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{include\PYGZus{}target\PYGZus{}states}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{nbsphinx-stderr}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
/Users/shouwenwang/miniconda3/envs/CoSpar\_env/lib/python3.6/site-packages/plotnine/ggplot.py:729: PlotnineWarning: Saving 3.5 x 2.163 in image.
/Users/shouwenwang/miniconda3/envs/CoSpar\_env/lib/python3.6/site-packages/plotnine/ggplot.py:730: PlotnineWarning: Filename: CellTag\_figure\_1/CellTagging\_stateInfo\_t*6*7*8\_fate\_trajectory\_pseutoTime\_gene\_expression\_Reprogrammed\_True.png
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=718\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_70_1}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=695\sphinxpxdimen,height=429\sphinxpxdimen]{{20210121_reprogramming_data_merge_tags_70_2}.png}

\end{nbsphinxfancyoutput}


\section{Reprogramming dataset (dynamic barcoding)}
\label{\detokenize{20210121_reprogramming_data_no_merge_tags:Reprogramming-dataset-(dynamic-barcoding)}}\label{\detokenize{20210121_reprogramming_data_no_merge_tags::doc}}
The reprogramming dataset from \sphinxstyleemphasis{Biddy, B. A. et al. Nature 564, 219\textendash{}224 (2018)}. This dataset has multiple time points for both the clones and the state measurements.

The cells are barcoded over 3 rounds during the entire differentiation process. We treat barcode tags from each round as independent clonal label here. In this representation, each cell can have multiple clonal labels at different time points.

\sphinxstylestrong{Key components}:
\begin{itemize}
\item {} 
Part 1: Infer transition map using clones from all time points

\item {} 
Part II: Infer transition map using clones from the last time point

\end{itemize}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[1]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{k+kn}{import} \PYG{n+nn}{cospar} \PYG{k}{as} \PYG{n+nn}{cs}
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[2]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{logging}\PYG{o}{.}\PYG{n}{print\PYGZus{}version}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{verbosity}\PYG{o}{=}\PYG{l+m+mi}{3}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{set\PYGZus{}figure\PYGZus{}params}\PYG{p}{(}\PYG{n+nb}{format}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{png}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{dpi}\PYG{o}{=}\PYG{l+m+mi}{75}\PYG{p}{,}\PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{14}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} use png to reduce file size.}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Running cospar 0.0.2 (python 3.6.12) on 2021-01-31 19:03.
\end{sphinxVerbatim}
}


\subsection{Load data}
\label{\detokenize{20210121_reprogramming_data_no_merge_tags:Load-data}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[3]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{adata\PYGZus{}orig}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{datasets}\PYG{o}{.}\PYG{n}{reprogramming\PYGZus{}no\PYGZus{}merge\PYGZus{}tags}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[4]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{adata\PYGZus{}orig}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxout}[4]:\,\hspace{\fboxrule}\hspace{\fboxsep}}AnnData object with n\_obs × n\_vars = 18803 × 28001
    obs: 'time\_info', 'state\_info'
    uns: 'available\_map', 'clonal\_time\_points', 'data\_des', 'state\_info\_colors'
    obsm: 'X\_clone', 'X\_emb', 'X\_pca'
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[5]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{embedding}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{state\PYGZus{}info}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=556\sphinxpxdimen,height=274\sphinxpxdimen]{{20210121_reprogramming_data_no_merge_tags_7_0}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[6]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{hf}\PYG{o}{.}\PYG{n}{check\PYGZus{}available\PYGZus{}choices}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Available transition maps: []
Availabel clusters: ['19', '2', '20', '18', 'Failed', '9', '13', '8', '11', '15', '16', '5', '10', '12', '4', '22', '3', '0', '7', '21', 'Reprogrammed']
Availabel time points: ['6', '4', '3', '5', '7', '8']
Clonal time points: ['6', '4', '3', '5', '7', '8']
\end{sphinxVerbatim}
}


\subsubsection{Raw clonal data analysis (without using state information)}
\label{\detokenize{20210121_reprogramming_data_no_merge_tags:Raw-clonal-data-analysis-(without-using-state-information)}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[7]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{c+c1}{\PYGZsh{}cs.pl.clones\PYGZus{}on\PYGZus{}manifold(adata\PYGZus{}orig,selected\PYGZus{}clone\PYGZus{}list=[1],color\PYGZus{}list=[\PYGZsq{}black\PYGZsq{},\PYGZsq{}red\PYGZsq{},\PYGZsq{}blue\PYGZsq{}],point\PYGZus{}size=2)}

\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{clones\PYGZus{}on\PYGZus{}manifold}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{selected\PYGZus{}clone\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{324}\PYG{p}{,}\PYG{l+m+mi}{313}\PYG{p}{]}\PYG{p}{,}\PYG{n}{point\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}324,313,446,716,367}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=247\sphinxpxdimen,height=184\sphinxpxdimen]{{20210121_reprogramming_data_no_merge_tags_10_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=247\sphinxpxdimen,height=184\sphinxpxdimen]{{20210121_reprogramming_data_no_merge_tags_10_1}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[8]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{plot\PYGZus{}time\PYGZus{}point}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{8}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Reprogrammed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Failed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}coupling\PYGZus{}from\PYGZus{}clones}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{plot\PYGZus{}time\PYGZus{}point}\PYG{p}{,} \PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{n}{selected\PYGZus{}fates}\PYG{p}{,} \PYG{n}{color\PYGZus{}bar}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=370\sphinxpxdimen,height=283\sphinxpxdimen]{{20210121_reprogramming_data_no_merge_tags_11_0}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[9]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{plot\PYGZus{}time\PYGZus{}point}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{8}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{barcode\PYGZus{}heatmap}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{plot\PYGZus{}time\PYGZus{}point}\PYG{p}{,} \PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{n}{selected\PYGZus{}fates}\PYG{p}{,} \PYG{n}{color\PYGZus{}bar}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=282\sphinxpxdimen,height=433\sphinxpxdimen]{{20210121_reprogramming_data_no_merge_tags_12_0}.png}

\end{nbsphinxfancyoutput}

The computation requires simulation, with time linearly proportional to N\_resampling, and the number of clones. Can take hours for big data.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[10]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{clonal\PYGZus{}fate\PYGZus{}bias}\PYG{p}{,}\PYG{n}{clone\PYGZus{}id}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{clonal\PYGZus{}fate\PYGZus{}bias}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fate}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Reprogrammed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{n}{clone\PYGZus{}size\PYGZus{}thresh}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{n}{N\PYGZus{}resampling}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{n}{compute\PYGZus{}new}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=283\sphinxpxdimen,height=246\sphinxpxdimen]{{20210121_reprogramming_data_no_merge_tags_14_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=310\sphinxpxdimen,height=265\sphinxpxdimen]{{20210121_reprogramming_data_no_merge_tags_14_1}.png}

\end{nbsphinxfancyoutput}


\subsection{Part 1: Infer transition map using clones from all time points}
\label{\detokenize{20210121_reprogramming_data_no_merge_tags:Part-1:-Infer-transition-map-using-clones-from-all-time-points}}

\subsubsection{Map inference}
\label{\detokenize{20210121_reprogramming_data_no_merge_tags:Map-inference}}
Running it the first time takes 20 mins, 17 mins of which are used to compute the similarity matrix. When it is run again, it only takes 3 mins.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[11]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{noise\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mf}{0.2} \PYG{c+c1}{\PYGZsh{}}
\PYG{n}{selected\PYGZus{}clonal\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{5}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{6}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{7}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{8}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{c+c1}{\PYGZsh{}selected\PYGZus{}clonal\PYGZus{}time\PYGZus{}points=[\PYGZsq{}7\PYGZsq{},\PYGZsq{}8\PYGZsq{}]}
\PYG{n}{adata}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{tmap}\PYG{o}{.}\PYG{n}{infer\PYGZus{}Tmap\PYGZus{}from\PYGZus{}multitime\PYGZus{}clones}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{selected\PYGZus{}clonal\PYGZus{}time\PYGZus{}points}\PYG{p}{,}\PYG{n}{smooth\PYGZus{}array}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{15}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,}
        \PYG{n}{noise\PYGZus{}threshold}\PYG{o}{=}\PYG{n}{noise\PYGZus{}threshold}\PYG{p}{,}\PYG{n}{demulti\PYGZus{}threshold}\PYG{o}{=}\PYG{n}{noise\PYGZus{}threshold}\PYG{p}{,}\PYG{n}{use\PYGZus{}full\PYGZus{}Smatrix}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
-------Step 1: Select time points---------
--> Clonal cell fraction (day 3-4): 0.5632183908045977
--> Clonal cell fraction (day 4-5): 0.8427464008859358
--> Clonal cell fraction (day 5-6): 0.8514851485148515
--> Clonal cell fraction (day 6-7): 0.8354622871046229
--> Clonal cell fraction (day 7-8): 0.854301948051948
--> Clonal cell fraction (day 4-3): 0.12181616832779624
--> Clonal cell fraction (day 5-4): 0.7069306930693069
--> Clonal cell fraction (day 6-5): 0.9105839416058394
--> Clonal cell fraction (day 7-6): 0.890625
--> Clonal cell fraction (day 8-7): 0.9279731993299832
--> Numer of cells that are clonally related -- day 3: 49  and day 4: 110
--> Numer of cells that are clonally related -- day 4: 761  and day 5: 2142
--> Numer of cells that are clonally related -- day 5: 2580  and day 6: 2994
--> Numer of cells that are clonally related -- day 6: 2747  and day 7: 4389
--> Numer of cells that are clonally related -- day 7: 4210  and day 8: 6094
Valid clone number 'FOR' post selection 1178
Cell number=17495, Clone number=1343
-------Step 2: Compute the full Similarity matrix if necessary---------
Compute similarity matrix: computing new; beta=0.1
Smooth round: 1
--> Time elapsed: 0.1337580680847168
Smooth round: 2
--> Time elapsed: 0.5934758186340332
Smooth round: 3
--> Time elapsed: 4.39215874671936
--> Orignal sparsity=0.1440132780842932, Thresholding
--> Final sparsity=0.08134327961173121
similarity matrix truncated (Smooth round=3):  7.517376899719238
Smooth round: 4
--> Time elapsed: 8.568882942199707
--> Orignal sparsity=0.2782366721346004, Thresholding
--> Final sparsity=0.1435782907327997
similarity matrix truncated (Smooth round=4):  6.493448972702026
Smooth round: 5
--> Time elapsed: 15.888505935668945
--> Orignal sparsity=0.37387141506207067, Thresholding
--> Final sparsity=0.2072778864557119
similarity matrix truncated (Smooth round=5):  7.890843152999878
Save the matrix\textasciitilde{}\textasciitilde{}\textasciitilde{}
Smooth round: 6
--> Time elapsed: 21.847924947738647
--> Orignal sparsity=0.45353977091439257, Thresholding
--> Final sparsity=0.2689848859325567
similarity matrix truncated (Smooth round=6):  7.91843581199646
Smooth round: 7
--> Time elapsed: 24.09710192680359
--> Orignal sparsity=0.5228332749578013, Thresholding
--> Final sparsity=0.32826160348792477
similarity matrix truncated (Smooth round=7):  7.959678888320923
Smooth round: 8
--> Time elapsed: 28.971921920776367
--> Orignal sparsity=0.5844685765175182, Thresholding
--> Final sparsity=0.38362760964515485
similarity matrix truncated (Smooth round=8):  8.130839109420776
Smooth round: 9
--> Time elapsed: 33.23370909690857
--> Orignal sparsity=0.6382832981536288, Thresholding
--> Final sparsity=0.4347932758186628
similarity matrix truncated (Smooth round=9):  8.56610894203186
Smooth round: 10
--> Time elapsed: 34.91329598426819
--> Orignal sparsity=0.6850691009500649, Thresholding
--> Final sparsity=0.48187784020689256
similarity matrix truncated (Smooth round=10):  7.945361852645874
Save the matrix\textasciitilde{}\textasciitilde{}\textasciitilde{}
Smooth round: 11
--> Time elapsed: 48.110677003860474
--> Orignal sparsity=0.7256668380762321, Thresholding
--> Final sparsity=0.5251253879869471
similarity matrix truncated (Smooth round=11):  8.004131078720093
Smooth round: 12
--> Time elapsed: 39.93495488166809
--> Orignal sparsity=0.7608566277859781, Thresholding
--> Final sparsity=0.5648926975432402
similarity matrix truncated (Smooth round=12):  8.09719705581665
Smooth round: 13
--> Time elapsed: 55.33443212509155
--> Orignal sparsity=0.7914519214016483, Thresholding
--> Final sparsity=0.6015221957973469
similarity matrix truncated (Smooth round=13):  8.601667881011963
Smooth round: 14
--> Time elapsed: 50.29007625579834
--> Orignal sparsity=0.8182097402031955, Thresholding
--> Final sparsity=0.6353063058254474
similarity matrix truncated (Smooth round=14):  7.615164756774902
Smooth round: 15
--> Time elapsed: 54.27081823348999
--> Orignal sparsity=0.8416467679655742, Thresholding
--> Final sparsity=0.6664864314513196
similarity matrix truncated (Smooth round=15):  9.232807874679565
Save the matrix\textasciitilde{}\textasciitilde{}\textasciitilde{}
-------Step 3: Optimize the transition map recursively---------
---------Compute the transition map-----------
Compute similarity matrix: load existing data
--> Time elapsed:  2.567207098007202
--> Time elapsed:  5.323064088821411
--> Time elapsed:  2.1344919204711914
--> Time elapsed:  6.327005863189697
Compute similarity matrix: load existing data
--> Time elapsed:  2.0665841102600098
--> Time elapsed:  4.253573179244995
--> Time elapsed:  2.279231071472168
--> Time elapsed:  3.66169810295105
Compute similarity matrix: load existing data
--> Time elapsed:  0.7392430305480957
--> Time elapsed:  1.6739377975463867
--> Time elapsed:  1.539405107498169
--> Time elapsed:  3.2196900844573975
Current iteration: 0
Use smooth\_round=15
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
--> Clone id: 1000
--> Relative time point pair index: 1
--> Clone id: 0
--> Clone id: 1000
--> Relative time point pair index: 2
--> Clone id: 0
--> Clone id: 1000
--> Relative time point pair index: 3
--> Clone id: 0
--> Clone id: 1000
--> Relative time point pair index: 4
--> Clone id: 0
--> Clone id: 1000
Start to smooth the refined clonal map
Phase I: time elapsed --  35.21870803833008
Phase II: time elapsed --  54.632588148117065
Current iteration: 1
Use smooth\_round=10
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
--> Clone id: 1000
--> Relative time point pair index: 1
--> Clone id: 0
--> Clone id: 1000
--> Relative time point pair index: 2
--> Clone id: 0
--> Clone id: 1000
--> Relative time point pair index: 3
--> Clone id: 0
--> Clone id: 1000
--> Relative time point pair index: 4
--> Clone id: 0
--> Clone id: 1000
Start to smooth the refined clonal map
Phase I: time elapsed --  22.832170963287354
Phase II: time elapsed --  40.86349606513977
Current iteration: 2
Use smooth\_round=5
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
--> Clone id: 1000
--> Relative time point pair index: 1
--> Clone id: 0
--> Clone id: 1000
--> Relative time point pair index: 2
--> Clone id: 0
--> Clone id: 1000
--> Relative time point pair index: 3
--> Clone id: 0
--> Clone id: 1000
--> Relative time point pair index: 4
--> Clone id: 0
--> Clone id: 1000
Start to smooth the refined clonal map
Phase I: time elapsed --  11.405003070831299
Phase II: time elapsed --  33.78306317329407
No need for Final Smooth (i.e., clonally states are the final state space for Tmap)
----Demultiplexed transition map----
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
--> Clone id: 1000
--> Relative time point pair index: 1
--> Clone id: 0
--> Clone id: 1000
--> Relative time point pair index: 2
--> Clone id: 0
--> Clone id: 1000
--> Relative time point pair index: 3
--> Clone id: 0
--> Clone id: 1000
--> Relative time point pair index: 4
--> Clone id: 0
--> Clone id: 1000
-----------Total used time: 1172.3317241668701 s ------------
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=363\sphinxpxdimen,height=241\sphinxpxdimen]{{20210121_reprogramming_data_no_merge_tags_18_1}.png}

\end{nbsphinxfancyoutput}


\subsubsection{Save or load pre\sphinxhyphen{}computed data}
\label{\detokenize{20210121_reprogramming_data_no_merge_tags:Save-or-load-pre-computed-data}}
This can be used to save maps obtained from different parameter choices. Usually, different parameter choice will result to different ‘data\_des’, a prefix to define the map. Saving an adata would print the ‘data\_des’, which can be used to load the corresponding map.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[12]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{save\PYGZus{}data}\PYG{o}{=}\PYG{k+kc}{True}
\PYG{k}{if} \PYG{n}{save\PYGZus{}data}\PYG{p}{:}
    \PYG{n}{cs}\PYG{o}{.}\PYG{n}{hf}\PYG{o}{.}\PYG{n}{save\PYGZus{}map}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{)}

\PYG{n}{load\PYGZus{}data}\PYG{o}{=}\PYG{k+kc}{False}
\PYG{k}{if} \PYG{n}{load\PYGZus{}data}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{} Updated Jan 28, 2021}
    \PYG{c+c1}{\PYGZsh{}data\PYGZus{}des=\PYGZsq{}CellTagging\PYGZus{}NoConcat\PYGZus{}TwoTimeClone\PYGZus{}t*3*4*5*6*7*8\PYGZsq{}}
    \PYG{n}{data\PYGZus{}des}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{CellTagging\PYGZus{}NoConcat\PYGZus{}OneTimeClone\PYGZus{}t*3*4*5*6*7*8}\PYG{l+s+s1}{\PYGZsq{}}
    \PYG{n}{adata}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{hf}\PYG{o}{.}\PYG{n}{load\PYGZus{}saved\PYGZus{}adata\PYGZus{}with\PYGZus{}key}\PYG{p}{(}\PYG{n}{data\PYGZus{}des}\PYG{p}{)}

\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Saved file: data\_des='CellTagging\_NoConcat\_TwoTimeClone\_t*3*4*5*6*7*8'
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[13]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{hf}\PYG{o}{.}\PYG{n}{check\PYGZus{}available\PYGZus{}choices}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Available transition maps: ['transition\_map', 'intraclone\_transition\_map']
Availabel clusters: ['19', '2', '20', '18', 'Failed', '9', '13', '8', '11', '15', '16', '5', '10', '12', '4', '22', '3', '0', '7', '21', 'Reprogrammed']
Availabel time points: ['6', '4', '3', '5', '7', '8']
Clonal time points: ['6', '4', '3', '5', '7', '8']
\end{sphinxVerbatim}
}


\subsubsection{Plotting}
\label{\detokenize{20210121_reprogramming_data_no_merge_tags:Plotting}}

\paragraph{Plotting transition profiles for single cells}
\label{\detokenize{20210121_reprogramming_data_no_merge_tags:Plotting-transition-profiles-for-single-cells}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[14]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{selected\PYGZus{}state\PYGZus{}id\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1000}\PYG{p}{,}\PYG{l+m+mi}{3500}\PYG{p}{,}\PYG{l+m+mi}{6000}\PYG{p}{,}\PYG{l+m+mi}{5500}\PYG{p}{]}

\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{single\PYGZus{}cell\PYGZus{}transition}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}state\PYGZus{}id\PYGZus{}list}\PYG{o}{=}\PYG{n}{selected\PYGZus{}state\PYGZus{}id\PYGZus{}list}\PYG{p}{,}
                                    \PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=282\sphinxpxdimen,height=883\sphinxpxdimen]{{20210121_reprogramming_data_no_merge_tags_24_0}.png}

\end{nbsphinxfancyoutput}


\paragraph{Fate map}
\label{\detokenize{20210121_reprogramming_data_no_merge_tags:Fate-map}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[15]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}map}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Reprogrammed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Failed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
               \PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{intraclone\PYGZus{}transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=288\sphinxpxdimen,height=435\sphinxpxdimen]{{20210121_reprogramming_data_no_merge_tags_26_0}.png}

\end{nbsphinxfancyoutput}


\paragraph{Relative fate bias}
\label{\detokenize{20210121_reprogramming_data_no_merge_tags:Relative-fate-bias}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[16]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}bias\PYGZus{}intrinsic}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Reprogrammed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Failed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
            \PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=528\sphinxpxdimen,height=230\sphinxpxdimen]{{20210121_reprogramming_data_no_merge_tags_28_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=600\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_reprogramming_data_no_merge_tags_28_1}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[17]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}bias\PYGZus{}from\PYGZus{}binary\PYGZus{}competition}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Reprogrammed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Failed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
            \PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{7}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{sum\PYGZus{}fate\PYGZus{}prob\PYGZus{}thresh}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=318\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_reprogramming_data_no_merge_tags_29_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=302\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_reprogramming_data_no_merge_tags_29_1}.png}

\end{nbsphinxfancyoutput}


\paragraph{Identify differentially expressed genes}
\label{\detokenize{20210121_reprogramming_data_no_merge_tags:Identify-differentially-expressed-genes}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[18]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{dynamic\PYGZus{}trajectory\PYGZus{}from\PYGZus{}competition\PYGZus{}bias}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,} \PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Reprogrammed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Failed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
 \PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}
    \PYG{n}{bias\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{sum\PYGZus{}fate\PYGZus{}prob\PYGZus{}thresh}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{n}{avoid\PYGZus{}target\PYGZus{}states}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}

\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=583\sphinxpxdimen,height=283\sphinxpxdimen]{{20210121_reprogramming_data_no_merge_tags_31_0}.png}

\end{nbsphinxfancyoutput}


\paragraph{Map trajectory backwards iteratively}
\label{\detokenize{20210121_reprogramming_data_no_merge_tags:Map-trajectory-backwards-iteratively}}
From our experience, it is better to use the intra\sphinxhyphen{}clone transition map to compute the trajectory

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[19]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{c+c1}{\PYGZsh{} plot each tiem point separately, use the transition map.}

\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{dynamic\PYGZus{}trajectory\PYGZus{}via\PYGZus{}iterative\PYGZus{}mapping}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fate}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Failed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{map\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{n}{plot\PYGZus{}separately}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{apply\PYGZus{}time\PYGZus{}constaint}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{point\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=1432\sphinxpxdimen,height=237\sphinxpxdimen]{{20210121_reprogramming_data_no_merge_tags_34_0}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[20]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{c+c1}{\PYGZsh{} plot each tiem point separately, use the transition map.}

\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{dynamic\PYGZus{}trajectory\PYGZus{}via\PYGZus{}iterative\PYGZus{}mapping}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fate}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Reprogrammed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{map\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mf}{0.3}\PYG{p}{,} \PYG{n}{plot\PYGZus{}separately}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{apply\PYGZus{}time\PYGZus{}constaint}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{point\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=1432\sphinxpxdimen,height=237\sphinxpxdimen]{{20210121_reprogramming_data_no_merge_tags_35_0}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[21]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{c+c1}{\PYGZsh{} plot each tiem point separately, use the intra\PYGZhy{}clone transition map.}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{dynamic\PYGZus{}trajectory\PYGZus{}via\PYGZus{}iterative\PYGZus{}mapping}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fate}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Reprogrammed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                        \PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{intraclone\PYGZus{}transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{map\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mf}{0.05}\PYG{p}{,} \PYG{n}{plot\PYGZus{}separately}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{apply\PYGZus{}time\PYGZus{}constaint}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{point\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=1432\sphinxpxdimen,height=237\sphinxpxdimen]{{20210121_reprogramming_data_no_merge_tags_36_0}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[22]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{c+c1}{\PYGZsh{} plot each tiem point separately, use the intra\PYGZhy{}clone transition map.}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{dynamic\PYGZus{}trajectory\PYGZus{}via\PYGZus{}iterative\PYGZus{}mapping}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fate}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Failed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                        \PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{intraclone\PYGZus{}transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{map\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mf}{0.05}\PYG{p}{,} \PYG{n}{plot\PYGZus{}separately}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{apply\PYGZus{}time\PYGZus{}constaint}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{point\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=1432\sphinxpxdimen,height=237\sphinxpxdimen]{{20210121_reprogramming_data_no_merge_tags_37_0}.png}

\end{nbsphinxfancyoutput}


\paragraph{Gene trend along the trajectory}
\label{\detokenize{20210121_reprogramming_data_no_merge_tags:Gene-trend-along-the-trajectory}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[23]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{c+c1}{\PYGZsh{} The results are based on pre\PYGZhy{}computed dynamic trajectories from the immediate previous step}
\PYG{c+c1}{\PYGZsh{} better to use the \PYGZsq{}intraclone transition map\PYGZsq{}}

\PYG{n}{gene\PYGZus{}name\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Col1a2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Apoa1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Peg3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Spint2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mettl7a1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cdh1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{selected\PYGZus{}fate}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Failed}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{adata\PYGZus{}selected}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{gene\PYGZus{}expression\PYGZus{}dynamics}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fate}\PYG{p}{,}\PYG{n}{gene\PYGZus{}name\PYGZus{}list}\PYG{p}{,} \PYG{n}{traj\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{,}
      \PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{invert\PYGZus{}PseudoTime}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{include\PYGZus{}target\PYGZus{}states}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{compute\PYGZus{}new}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}
    \PYG{n}{fig\PYGZus{}width}\PYG{o}{=}\PYG{l+m+mf}{3.5}\PYG{p}{,} \PYG{n}{gene\PYGZus{}exp\PYGZus{}percentile}\PYG{o}{=}\PYG{l+m+mi}{99}\PYG{p}{,} \PYG{n}{n\PYGZus{}neighbors}\PYG{o}{=}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{n}{plot\PYGZus{}raw\PYGZus{}data}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{point\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}

\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{nbsphinx-stderr}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
/Users/shouwenwang/miniconda3/envs/CoSpar\_env/lib/python3.6/site-packages/plotnine/ggplot.py:729: PlotnineWarning: Saving 3.5 x 2.163 in image.
/Users/shouwenwang/miniconda3/envs/CoSpar\_env/lib/python3.6/site-packages/plotnine/ggplot.py:730: PlotnineWarning: Filename: figure\_cospar/CellTagging\_NoConcat\_TwoTimeClone\_t*3*4*5*6*7*8\_fate\_trajectory\_pseutoTime\_gene\_expression\_Failed\_True.png
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=718\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_reprogramming_data_no_merge_tags_39_1}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=695\sphinxpxdimen,height=429\sphinxpxdimen]{{20210121_reprogramming_data_no_merge_tags_39_2}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[24]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{c+c1}{\PYGZsh{} The results are based on pre\PYGZhy{}computed dynamic trajectories from a previous step}
\PYG{c+c1}{\PYGZsh{} better to use the \PYGZsq{}intraclone transition map\PYGZsq{}}

\PYG{n}{gene\PYGZus{}name\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Col1a2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Apoa1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Peg3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Spint2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mettl7a1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cdh1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{selected\PYGZus{}fate}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Reprogrammed}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{adata\PYGZus{}selected}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{gene\PYGZus{}expression\PYGZus{}dynamics}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fate}\PYG{p}{,}\PYG{n}{gene\PYGZus{}name\PYGZus{}list}\PYG{p}{,} \PYG{n}{traj\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{,}
      \PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{invert\PYGZus{}PseudoTime}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{include\PYGZus{}target\PYGZus{}states}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{compute\PYGZus{}new}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}
    \PYG{n}{fig\PYGZus{}width}\PYG{o}{=}\PYG{l+m+mf}{3.5}\PYG{p}{,} \PYG{n}{gene\PYGZus{}exp\PYGZus{}percentile}\PYG{o}{=}\PYG{l+m+mi}{99}\PYG{p}{,} \PYG{n}{n\PYGZus{}neighbors}\PYG{o}{=}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{n}{plot\PYGZus{}raw\PYGZus{}data}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{point\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}

\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{nbsphinx-stderr}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
/Users/shouwenwang/miniconda3/envs/CoSpar\_env/lib/python3.6/site-packages/plotnine/ggplot.py:729: PlotnineWarning: Saving 3.5 x 2.163 in image.
/Users/shouwenwang/miniconda3/envs/CoSpar\_env/lib/python3.6/site-packages/plotnine/ggplot.py:730: PlotnineWarning: Filename: figure\_cospar/CellTagging\_NoConcat\_TwoTimeClone\_t*3*4*5*6*7*8\_fate\_trajectory\_pseutoTime\_gene\_expression\_Reprogrammed\_True.png
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=718\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_reprogramming_data_no_merge_tags_40_1}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=695\sphinxpxdimen,height=429\sphinxpxdimen]{{20210121_reprogramming_data_no_merge_tags_40_2}.png}

\end{nbsphinxfancyoutput}


\subsubsection{Transition map from only clonal information}
\label{\detokenize{20210121_reprogramming_data_no_merge_tags:Transition-map-from-only-clonal-information}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[25]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{tmap}\PYG{o}{.}\PYG{n}{infer\PYGZus{}Tmap\PYGZus{}from\PYGZus{}clonal\PYGZus{}info\PYGZus{}alone}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{method}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{naive}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}bias\PYGZus{}from\PYGZus{}binary\PYGZus{}competition}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Reprogrammed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Failed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{clonal\PYGZus{}transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
            \PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{sum\PYGZus{}fate\PYGZus{}prob\PYGZus{}thresh}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=318\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_reprogramming_data_no_merge_tags_42_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=310\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_reprogramming_data_no_merge_tags_42_1}.png}

\end{nbsphinxfancyoutput}


\subsection{Part II: Infer transition map using clones from the last time point}
\label{\detokenize{20210121_reprogramming_data_no_merge_tags:Part-II:-Infer-transition-map-using-clones-from-the-last-time-point}}
It takes 12 mins to compute for the first time (excluding the time for computing similarity matrix); and 5 mins later.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[26]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{initial\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{5}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{6}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{7}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{clonal\PYGZus{}time\PYGZus{}point}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{8}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{adata}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{tmap}\PYG{o}{.}\PYG{n}{infer\PYGZus{}Tmap\PYGZus{}from\PYGZus{}one\PYGZus{}time\PYGZus{}clones}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{initial\PYGZus{}time\PYGZus{}points}\PYG{p}{,}\PYG{n}{clonal\PYGZus{}time\PYGZus{}point}\PYG{p}{,}
        \PYG{n}{initialize\PYGZus{}method}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{OT}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{OT\PYGZus{}cost}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{SPD}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{smooth\PYGZus{}array}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{15}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,}\PYG{n}{noise\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{,}\PYG{n}{use\PYGZus{}full\PYGZus{}Smatrix}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
-------------------------------New Start--------------------------------------------------
Current time point: 3
-----------Pre-processing and sub-sampling cells------------
----------------
Step 1: Use OT method for initialization
Load pre-computed shortest path distance matrix
Load pre-computed custon OT matrix
----------------
Step 2: Jointly optimize the transition map and the initial clonal states!
Joint optimization that consider possibility of clonal overlap: v2
--> original clone shape: (6654, 770)
--> After excluding zero-sized clones at t2: (6654, 694)
Sort clones by size (small to large)
Infer the number of initial cells to extract for each clone in advance
--> Inferring early clonal states: current clone id 0
--> Inferring early clonal states: current clone id 100
--> Inferring early clonal states: current clone id 200
--> Inferring early clonal states: current clone id 300
--> Inferring early clonal states: current clone id 400
--> Inferring early clonal states: current clone id 500
--> Inferring early clonal states: current clone id 600
--> Inferring early clonal states: current clone id 700
--> Inferring early clonal states: current clone id 800
--> Inferring early clonal states: current clone id 900
---------Compute the transition map-----------
Compute similarity matrix: load existing data
--> Time elapsed:  0.001177072525024414
--> Time elapsed:  0.48853087425231934
--> Time elapsed:  0.0019659996032714844
--> Time elapsed:  0.4351649284362793
Compute similarity matrix: load existing data
--> Time elapsed:  0.0006508827209472656
--> Time elapsed:  0.3633909225463867
--> Time elapsed:  0.0007488727569580078
--> Time elapsed:  0.34566497802734375
Compute similarity matrix: load existing data
--> Time elapsed:  0.0004506111145019531
--> Time elapsed:  0.29157400131225586
--> Time elapsed:  0.0007388591766357422
--> Time elapsed:  0.26699209213256836
Current iteration: 0
Use smooth\_round=15
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  0.6211681365966797
Phase II: time elapsed --  0.6230154037475586
Current iteration: 1
Use smooth\_round=10
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  0.37720394134521484
Phase II: time elapsed --  0.3812239170074463
Current iteration: 2
Use smooth\_round=5
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  0.3452720642089844
Phase II: time elapsed --  0.34787702560424805
Final round of Smooth (to expand the state space of Tmap to include non-clonal states)
Phase I: time elapsed --  0.3672800064086914
Phase II: time elapsed --  0.36899375915527344
----Demultiplexed transition map----
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Finishing computing transport map from CoSpar using inferred clonal data, used time 33.415353775024414
-------------------------------New Start--------------------------------------------------
Current time point: 4
-----------Pre-processing and sub-sampling cells------------
----------------
Step 1: Use OT method for initialization
Load pre-computed shortest path distance matrix
Load pre-computed custon OT matrix
----------------
Step 2: Jointly optimize the transition map and the initial clonal states!
Joint optimization that consider possibility of clonal overlap: v2
--> original clone shape: (7470, 1172)
--> After excluding zero-sized clones at t2: (7470, 694)
Sort clones by size (small to large)
Infer the number of initial cells to extract for each clone in advance
--> Inferring early clonal states: current clone id 0
--> Inferring early clonal states: current clone id 100
--> Inferring early clonal states: current clone id 200
--> Inferring early clonal states: current clone id 300
--> Inferring early clonal states: current clone id 400
--> Inferring early clonal states: current clone id 500
--> Inferring early clonal states: current clone id 600
--> Inferring early clonal states: current clone id 700
--> Inferring early clonal states: current clone id 800
--> Inferring early clonal states: current clone id 900
---------Compute the transition map-----------
Compute similarity matrix: load existing data
--> Time elapsed:  0.014316082000732422
--> Time elapsed:  0.4230778217315674
--> Time elapsed:  0.0210421085357666
--> Time elapsed:  0.3985321521759033
Compute similarity matrix: load existing data
--> Time elapsed:  0.01192021369934082
--> Time elapsed:  0.3132040500640869
--> Time elapsed:  0.009737968444824219
--> Time elapsed:  0.33245396614074707
Compute similarity matrix: load existing data
--> Time elapsed:  0.007749795913696289
--> Time elapsed:  0.2143690586090088
--> Time elapsed:  0.008270978927612305
--> Time elapsed:  0.19117307662963867
Current iteration: 0
Use smooth\_round=15
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  2.654543876647949
Phase II: time elapsed --  2.7132139205932617
Current iteration: 1
Use smooth\_round=10
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  0.8287158012390137
Phase II: time elapsed --  0.905642032623291
Current iteration: 2
Use smooth\_round=5
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  0.6787478923797607
Phase II: time elapsed --  0.7454941272735596
Final round of Smooth (to expand the state space of Tmap to include non-clonal states)
Phase I: time elapsed --  0.6463139057159424
Phase II: time elapsed --  0.721977949142456
----Demultiplexed transition map----
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Finishing computing transport map from CoSpar using inferred clonal data, used time 38.43891382217407
-------------------------------New Start--------------------------------------------------
Current time point: 5
-----------Pre-processing and sub-sampling cells------------
----------------
Step 1: Use OT method for initialization
Load pre-computed shortest path distance matrix
Load pre-computed custon OT matrix
----------------
Step 2: Jointly optimize the transition map and the initial clonal states!
Joint optimization that consider possibility of clonal overlap: v2
--> original clone shape: (9597, 1395)
--> After excluding zero-sized clones at t2: (9597, 694)
Sort clones by size (small to large)
Infer the number of initial cells to extract for each clone in advance
--> Inferring early clonal states: current clone id 0
--> Inferring early clonal states: current clone id 100
--> Inferring early clonal states: current clone id 200
--> Inferring early clonal states: current clone id 300
--> Inferring early clonal states: current clone id 400
--> Inferring early clonal states: current clone id 500
--> Inferring early clonal states: current clone id 600
--> Inferring early clonal states: current clone id 700
--> Inferring early clonal states: current clone id 800
--> Inferring early clonal states: current clone id 900
---------Compute the transition map-----------
Compute similarity matrix: load existing data
--> Time elapsed:  0.1458601951599121
--> Time elapsed:  0.4339921474456787
--> Time elapsed:  0.17587995529174805
--> Time elapsed:  0.4758181571960449
Compute similarity matrix: load existing data
--> Time elapsed:  0.24487805366516113
--> Time elapsed:  0.6403329372406006
--> Time elapsed:  0.11470293998718262
--> Time elapsed:  0.41714906692504883
Compute similarity matrix: load existing data
--> Time elapsed:  0.08960103988647461
--> Time elapsed:  0.2675468921661377
--> Time elapsed:  0.07383918762207031
--> Time elapsed:  0.28000593185424805
Current iteration: 0
Use smooth\_round=15
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  9.28814697265625
Phase II: time elapsed --  9.838491201400757
Current iteration: 1
Use smooth\_round=10
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  1.9691081047058105
Phase II: time elapsed --  2.8161470890045166
Current iteration: 2
Use smooth\_round=5
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  1.2565879821777344
Phase II: time elapsed --  1.7074029445648193
Final round of Smooth (to expand the state space of Tmap to include non-clonal states)
Phase I: time elapsed --  1.3795409202575684
Phase II: time elapsed --  1.9576280117034912
----Demultiplexed transition map----
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Finishing computing transport map from CoSpar using inferred clonal data, used time 66.69856905937195
-------------------------------New Start--------------------------------------------------
Current time point: 6
-----------Pre-processing and sub-sampling cells------------
----------------
Step 1: Use OT method for initialization
Load pre-computed shortest path distance matrix
Load pre-computed custon OT matrix
----------------
Step 2: Jointly optimize the transition map and the initial clonal states!
Joint optimization that consider possibility of clonal overlap: v2
--> original clone shape: (9855, 1318)
--> After excluding zero-sized clones at t2: (9855, 694)
Sort clones by size (small to large)
Infer the number of initial cells to extract for each clone in advance
--> Inferring early clonal states: current clone id 0
--> Inferring early clonal states: current clone id 100
--> Inferring early clonal states: current clone id 200
--> Inferring early clonal states: current clone id 300
--> Inferring early clonal states: current clone id 400
--> Inferring early clonal states: current clone id 500
--> Inferring early clonal states: current clone id 600
--> Inferring early clonal states: current clone id 700
--> Inferring early clonal states: current clone id 800
--> Inferring early clonal states: current clone id 900
---------Compute the transition map-----------
Compute similarity matrix: load existing data
--> Time elapsed:  0.2619459629058838
--> Time elapsed:  0.7324919700622559
--> Time elapsed:  0.17139315605163574
--> Time elapsed:  0.44153594970703125
Compute similarity matrix: load existing data
--> Time elapsed:  0.25110292434692383
--> Time elapsed:  0.7214927673339844
--> Time elapsed:  0.14876961708068848
--> Time elapsed:  0.44804930686950684
Compute similarity matrix: load existing data
--> Time elapsed:  0.11345887184143066
--> Time elapsed:  0.34697699546813965
--> Time elapsed:  0.08201289176940918
--> Time elapsed:  0.3031740188598633
Current iteration: 0
Use smooth\_round=15
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  10.852234125137329
Phase II: time elapsed --  12.136868953704834
Current iteration: 1
Use smooth\_round=10
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  2.7241013050079346
Phase II: time elapsed --  4.04835319519043
Current iteration: 2
Use smooth\_round=5
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  2.057713031768799
Phase II: time elapsed --  3.348417043685913
Final round of Smooth (to expand the state space of Tmap to include non-clonal states)
Phase I: time elapsed --  1.9296200275421143
Phase II: time elapsed --  3.4538490772247314
----Demultiplexed transition map----
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Finishing computing transport map from CoSpar using inferred clonal data, used time 86.09633207321167
-------------------------------New Start--------------------------------------------------
Current time point: 7
-----------Pre-processing and sub-sampling cells------------
----------------
Step 1: Use OT method for initialization
Load pre-computed shortest path distance matrix
Load pre-computed custon OT matrix
----------------
Step 2: Jointly optimize the transition map and the initial clonal states!
Joint optimization that consider possibility of clonal overlap: v2
--> original clone shape: (11495, 1152)
--> After excluding zero-sized clones at t2: (11495, 694)
Sort clones by size (small to large)
Infer the number of initial cells to extract for each clone in advance
--> Inferring early clonal states: current clone id 0
--> Inferring early clonal states: current clone id 100
--> Inferring early clonal states: current clone id 200
--> Inferring early clonal states: current clone id 300
--> Inferring early clonal states: current clone id 400
--> Inferring early clonal states: current clone id 500
--> Inferring early clonal states: current clone id 600
--> Inferring early clonal states: current clone id 700
--> Inferring early clonal states: current clone id 800
--> Inferring early clonal states: current clone id 900
--> Inferring early clonal states: current clone id 1000
---------Compute the transition map-----------
Compute similarity matrix: load existing data
--> Time elapsed:  0.6876559257507324
--> Time elapsed:  1.2539939880371094
--> Time elapsed:  0.675605058670044
--> Time elapsed:  1.0762779712677002
Compute similarity matrix: load existing data
--> Time elapsed:  0.35739731788635254
--> Time elapsed:  0.5441539287567139
--> Time elapsed:  0.23572874069213867
--> Time elapsed:  0.441788911819458
Compute similarity matrix: load existing data
--> Time elapsed:  0.3040962219238281
--> Time elapsed:  0.3232109546661377
--> Time elapsed:  0.30980396270751953
--> Time elapsed:  0.28934192657470703
Current iteration: 0
Use smooth\_round=15
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  18.118456840515137
Phase II: time elapsed --  19.51311182975769
Current iteration: 1
Use smooth\_round=10
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  3.0614500045776367
Phase II: time elapsed --  4.439972162246704
Current iteration: 2
Use smooth\_round=5
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  1.9136219024658203
Phase II: time elapsed --  3.1833479404449463
Final round of Smooth (to expand the state space of Tmap to include non-clonal states)
Phase I: time elapsed --  2.3375039100646973
Phase II: time elapsed --  3.925551176071167
----Demultiplexed transition map----
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Finishing computing transport map from CoSpar using inferred clonal data, used time 95.20202279090881
-----------Total used time: 339.69058084487915 s ------------
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[27]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{hf}\PYG{o}{.}\PYG{n}{check\PYGZus{}available\PYGZus{}choices}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Available transition maps: ['transition\_map', 'OT\_transition\_map']
Availabel clusters: ['19', '2', '20', '18', 'Failed', '9', '13', '8', '11', '15', '16', '5', '10', '12', '4', '22', '3', '0', '7', '21', 'Reprogrammed']
Availabel time points: ['6', '4', '3', '5', '7', '8']
Clonal time points: ['6', '4', '3', '5', '7', '8']
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[28]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}map}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Reprogrammed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Failed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
               \PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}
               \PYG{n}{plot\PYGZus{}color\PYGZus{}bar}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}\PYG{n}{plot\PYGZus{}background}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}\PYG{n}{auto\PYGZus{}color\PYGZus{}scale}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}\PYG{n}{plot\PYGZus{}horizontal}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=538\sphinxpxdimen,height=230\sphinxpxdimen]{{20210121_reprogramming_data_no_merge_tags_48_0}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[29]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}bias\PYGZus{}from\PYGZus{}binary\PYGZus{}competition}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Reprogrammed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Failed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
            \PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{sum\PYGZus{}fate\PYGZus{}prob\PYGZus{}thresh}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=318\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_reprogramming_data_no_merge_tags_50_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=310\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_reprogramming_data_no_merge_tags_50_1}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[30]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}bias\PYGZus{}from\PYGZus{}binary\PYGZus{}competition}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Reprogrammed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Failed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{OT\PYGZus{}transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
            \PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{sum\PYGZus{}fate\PYGZus{}prob\PYGZus{}thresh}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=318\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_reprogramming_data_no_merge_tags_51_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=310\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_reprogramming_data_no_merge_tags_51_1}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[31]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{dynamic\PYGZus{}trajectory\PYGZus{}from\PYGZus{}competition\PYGZus{}bias}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,} \PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Reprogrammed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Failed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
 \PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}
    \PYG{n}{bias\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{sum\PYGZus{}fate\PYGZus{}prob\PYGZus{}thresh}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{n}{avoid\PYGZus{}target\PYGZus{}states}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}

\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=583\sphinxpxdimen,height=283\sphinxpxdimen]{{20210121_reprogramming_data_no_merge_tags_53_0}.png}

\end{nbsphinxfancyoutput}

The selected states, combined with the target states are stored as dynamic trajectory at \sphinxcode{\sphinxupquote{adata.uns{[}\textquotesingle{}dynamic\_trajectory\textquotesingle{}{]}}}. We can plot gene trend along this trajectory.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[32]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{gene\PYGZus{}name\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Col1a2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Apoa1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Peg3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Spint2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mettl7a1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cdh1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{selected\PYGZus{}fate}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Reprogrammed}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{adata\PYGZus{}selected}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{gene\PYGZus{}expression\PYGZus{}dynamics}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fate}\PYG{p}{,}\PYG{n}{gene\PYGZus{}name\PYGZus{}list}\PYG{p}{,} \PYG{n}{traj\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{,}
      \PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{invert\PYGZus{}PseudoTime}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{include\PYGZus{}target\PYGZus{}states}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{nbsphinx-stderr}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
/Users/shouwenwang/miniconda3/envs/CoSpar\_env/lib/python3.6/site-packages/plotnine/ggplot.py:729: PlotnineWarning: Saving 3.5 x 2.163 in image.
/Users/shouwenwang/miniconda3/envs/CoSpar\_env/lib/python3.6/site-packages/plotnine/ggplot.py:730: PlotnineWarning: Filename: figure\_cospar/CellTagging\_NoConcat\_OneTimeClone\_t*3*4*5*6*7*8\_fate\_trajectory\_pseutoTime\_gene\_expression\_Reprogrammed\_True.png
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=718\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_reprogramming_data_no_merge_tags_56_1}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=713\sphinxpxdimen,height=429\sphinxpxdimen]{{20210121_reprogramming_data_no_merge_tags_56_2}.png}

\end{nbsphinxfancyoutput}


\section{Lung dataset}
\label{\detokenize{20210121_lung_data:Lung-dataset}}\label{\detokenize{20210121_lung_data::doc}}
The direct lung differentiation dataset from \sphinxstyleemphasis{Hurley, K. et al.  Cell Stem Cell (2020) doi:10.1016/j.stem.2019.12.009}.

This dataset has multiple time points for the state manifold, but only one time point for the clonal observation on day 27.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[1]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{k+kn}{import} \PYG{n+nn}{cospar} \PYG{k}{as} \PYG{n+nn}{cs}
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[2]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{logging}\PYG{o}{.}\PYG{n}{print\PYGZus{}version}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{verbosity}\PYG{o}{=}\PYG{l+m+mi}{3}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{data\PYGZus{}path}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{lung\PYGZus{}data\PYGZus{}test\PYGZus{}2}\PYG{l+s+s1}{\PYGZsq{}} \PYG{c+c1}{\PYGZsh{} A relative path to save data. If not existed before, create a new one.}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{figure\PYGZus{}path}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{lung\PYGZus{}figure\PYGZus{}test\PYGZus{}2}\PYG{l+s+s1}{\PYGZsq{}} \PYG{c+c1}{\PYGZsh{} A relative path to save figures. If not existed before, create a new one.}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{set\PYGZus{}figure\PYGZus{}params}\PYG{p}{(}\PYG{n+nb}{format}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{png}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{dpi}\PYG{o}{=}\PYG{l+m+mi}{75}\PYG{p}{,}\PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{14}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} use png to reduce file size.}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Running cospar 0.0.2 (python 3.6.12) on 2021-02-01 11:38.
\end{sphinxVerbatim}
}


\subsection{Load data}
\label{\detokenize{20210121_lung_data:Load-data}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[3]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{adata\PYGZus{}orig}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{datasets}\PYG{o}{.}\PYG{n}{lung}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[4]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{adata\PYGZus{}orig}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxout}[4]:\,\hspace{\fboxrule}\hspace{\fboxsep}}AnnData object with n\_obs × n\_vars = 15832 × 26766
    obs: 'state\_info', 'time\_info'
    uns: 'clonal\_time\_points', 'data\_des'
    obsm: 'X\_clone', 'X\_emb', 'X\_pca'
\end{sphinxVerbatim}
}


\subsection{Preprocessing (optional)}
\label{\detokenize{20210121_lung_data:Preprocessing-(optional)}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[5]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{preprocessing}\PYG{o}{=}\PYG{k+kc}{False}
\PYG{k}{if} \PYG{n}{preprocessing}\PYG{p}{:}
    \PYG{n}{cs}\PYG{o}{.}\PYG{n}{pp}\PYG{o}{.}\PYG{n}{get\PYGZus{}highly\PYGZus{}variable\PYGZus{}genes}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{normalized\PYGZus{}counts\PYGZus{}per\PYGZus{}cell}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{,}\PYG{n}{min\PYGZus{}counts}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,}
        \PYG{n}{min\PYGZus{}cells}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{min\PYGZus{}gene\PYGZus{}vscore\PYGZus{}pctl}\PYG{o}{=}\PYG{l+m+mi}{80}\PYG{p}{)}

    \PYG{n}{cs}\PYG{o}{.}\PYG{n}{pp}\PYG{o}{.}\PYG{n}{remove\PYGZus{}cell\PYGZus{}cycle\PYGZus{}correlated\PYGZus{}genes}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{corr\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mf}{0.03}\PYG{p}{,}\PYG{n}{confirm\PYGZus{}change}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} optional step}
    \PYG{n}{cs}\PYG{o}{.}\PYG{n}{pp}\PYG{o}{.}\PYG{n}{get\PYGZus{}X\PYGZus{}pca}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{n\PYGZus{}pca\PYGZus{}comp}\PYG{o}{=}\PYG{l+m+mi}{40}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}cs.pp.get\PYGZus{}X\PYGZus{}umap(adata\PYGZus{}orig,n\PYGZus{}neighbors=20,umap\PYGZus{}min\PYGZus{}dist=0.3) \PYGZsh{} we want to keep the original embedding}
    \PYG{c+c1}{\PYGZsh{}cs.pp.get\PYGZus{}state\PYGZus{}info(adata\PYGZus{}orig,leiden\PYGZus{}resolution=0.5) \PYGZsh{} we want to keep the original state annotation}
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[6]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{embedding}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{state\PYGZus{}info}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=471\sphinxpxdimen,height=274\sphinxpxdimen]{{20210121_lung_data_9_0}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[7]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{hf}\PYG{o}{.}\PYG{n}{check\PYGZus{}available\PYGZus{}choices}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Available transition maps: []
Availabel clusters: ['NLE', 'Endoderm', 'PENC', 'iACE2', 'Gut', 'Others']
Availabel time points: ['pos\_17', 'D27', 'pos\_21']
Clonal time points: ['D27']
\end{sphinxVerbatim}
}


\subsubsection{Raw clonal data analysis (without using state information)}
\label{\detokenize{20210121_lung_data:Raw-clonal-data-analysis-(without-using-state-information)}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[8]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{clones\PYGZus{}on\PYGZus{}manifold}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{selected\PYGZus{}clone\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{30}\PYG{p}{,}\PYG{l+m+mi}{198}\PYG{p}{,}\PYG{l+m+mi}{150}\PYG{p}{,}\PYG{l+m+mi}{58}\PYG{p}{,}\PYG{l+m+mi}{263}\PYG{p}{]}\PYG{p}{,}
            \PYG{n}{color\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{D27}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{point\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=247\sphinxpxdimen,height=184\sphinxpxdimen]{{20210121_lung_data_12_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=247\sphinxpxdimen,height=184\sphinxpxdimen]{{20210121_lung_data_12_1}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=247\sphinxpxdimen,height=184\sphinxpxdimen]{{20210121_lung_data_12_2}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=247\sphinxpxdimen,height=184\sphinxpxdimen]{{20210121_lung_data_12_3}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=247\sphinxpxdimen,height=184\sphinxpxdimen]{{20210121_lung_data_12_4}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[9]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{plot\PYGZus{}time\PYGZus{}point}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{D27}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}coupling\PYGZus{}from\PYGZus{}clones}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{plot\PYGZus{}time\PYGZus{}point}\PYG{p}{,}
            \PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{iACE2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PENC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Gut}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{NLE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Endoderm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{color\PYGZus{}bar}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=350\sphinxpxdimen,height=283\sphinxpxdimen]{{20210121_lung_data_13_0}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[10]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{plot\PYGZus{}time\PYGZus{}point}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{D27}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{barcode\PYGZus{}heatmap}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{plot\PYGZus{}time\PYGZus{}point}\PYG{p}{,} \PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{color\PYGZus{}bar}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=283\sphinxpxdimen,height=433\sphinxpxdimen]{{20210121_lung_data_14_0}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[11]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{c+c1}{\PYGZsh{} This is very slow to run. You may skip. (to get more accurate results, set N\PYGZus{}resampling=10000)}
\PYG{n}{select\PYGZus{}fate\PYGZus{}cluster}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{iACE2}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{clonal\PYGZus{}fate\PYGZus{}bias}\PYG{p}{,}\PYG{n}{clone\PYGZus{}id}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{clonal\PYGZus{}fate\PYGZus{}bias}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{select\PYGZus{}fate\PYGZus{}cluster}\PYG{p}{,}
            \PYG{n}{clone\PYGZus{}size\PYGZus{}thresh}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{n}{N\PYGZus{}resampling}\PYG{o}{=}\PYG{l+m+mi}{1000}\PYG{p}{,}\PYG{n}{compute\PYGZus{}new}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=283\sphinxpxdimen,height=246\sphinxpxdimen]{{20210121_lung_data_15_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=302\sphinxpxdimen,height=265\sphinxpxdimen]{{20210121_lung_data_15_1}.png}

\end{nbsphinxfancyoutput}


\subsection{Infer transition map using clones from the last time point}
\label{\detokenize{20210121_lung_data:Infer-transition-map-using-clones-from-the-last-time-point}}
It takes around 9 minutes to run it for the first time (the data has \textasciitilde{}15000 cells). Later runs take \textless{} 3 mins.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[12]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{initial\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pos\PYGZus{}17}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pos\PYGZus{}21}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{clonal\PYGZus{}time\PYGZus{}point}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{D27}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{adata}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{tmap}\PYG{o}{.}\PYG{n}{infer\PYGZus{}Tmap\PYGZus{}from\PYGZus{}one\PYGZus{}time\PYGZus{}clones}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{initial\PYGZus{}time\PYGZus{}points}\PYG{p}{,}\PYG{n}{clonal\PYGZus{}time\PYGZus{}point}\PYG{p}{,}\PYG{n}{use\PYGZus{}full\PYGZus{}Smatrix}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}
        \PYG{n}{initialize\PYGZus{}method}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{HighVar}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{HighVar\PYGZus{}gene\PYGZus{}pctl}\PYG{o}{=}\PYG{l+m+mi}{80}\PYG{p}{,}\PYG{n}{smooth\PYGZus{}array}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{15}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,}\PYG{n}{noise\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
-------------------------------New Start--------------------------------------------------
Current time point: pos\_17
-----------Pre-processing and sub-sampling cells------------
Compute similarity matrix: computing new; beta=0.1
Smooth round: 1
--> Time elapsed: 0.0472261905670166
Smooth round: 2
--> Time elapsed: 0.3395230770111084
Smooth round: 3
--> Time elapsed: 2.321316957473755
--> Orignal sparsity=0.10625611684179591, Thresholding
--> Final sparsity=0.06359080221047629
similarity matrix truncated (Smooth round=3):  4.5784912109375
Smooth round: 4
--> Time elapsed: 4.774793863296509
--> Orignal sparsity=0.19565865491781953, Thresholding
--> Final sparsity=0.10602011255244238
similarity matrix truncated (Smooth round=4):  6.487684965133667
Smooth round: 5
--> Time elapsed: 6.284330129623413
--> Orignal sparsity=0.26021891990074664, Thresholding
--> Final sparsity=0.14820819224009757
similarity matrix truncated (Smooth round=5):  5.18575119972229
Save the matrix\textasciitilde{}\textasciitilde{}\textasciitilde{}
Smooth round: 6
--> Time elapsed: 9.356720924377441
--> Orignal sparsity=0.31224158218520337, Thresholding
--> Final sparsity=0.18877169029228322
similarity matrix truncated (Smooth round=6):  5.6274871826171875
Smooth round: 7
--> Time elapsed: 9.806509017944336
--> Orignal sparsity=0.3542734135085911, Thresholding
--> Final sparsity=0.2273821595933655
similarity matrix truncated (Smooth round=7):  6.41509485244751
Smooth round: 8
--> Time elapsed: 12.279183149337769
--> Orignal sparsity=0.387948762026544, Thresholding
--> Final sparsity=0.26310728844759823
similarity matrix truncated (Smooth round=8):  5.6763060092926025
Smooth round: 9
--> Time elapsed: 12.471949100494385
--> Orignal sparsity=0.4144626540397264, Thresholding
--> Final sparsity=0.29545661641526066
similarity matrix truncated (Smooth round=9):  5.868991851806641
Smooth round: 10
--> Time elapsed: 15.6089608669281
--> Orignal sparsity=0.43520591303430844, Thresholding
--> Final sparsity=0.3242141629670918
similarity matrix truncated (Smooth round=10):  5.183542966842651
Save the matrix\textasciitilde{}\textasciitilde{}\textasciitilde{}
Smooth round: 11
--> Time elapsed: 17.661149978637695
--> Orignal sparsity=0.45140746487052913, Thresholding
--> Final sparsity=0.3494782236602058
similarity matrix truncated (Smooth round=11):  5.033965110778809
Smooth round: 12
--> Time elapsed: 19.266963243484497
--> Orignal sparsity=0.4641330531342104, Thresholding
--> Final sparsity=0.37149772108146145
similarity matrix truncated (Smooth round=12):  5.696819067001343
Smooth round: 13
--> Time elapsed: 21.285794973373413
--> Orignal sparsity=0.4741452124518153, Thresholding
--> Final sparsity=0.39057858908126025
similarity matrix truncated (Smooth round=13):  6.431244134902954
Smooth round: 14
--> Time elapsed: 28.453316926956177
--> Orignal sparsity=0.482047420413074, Thresholding
--> Final sparsity=0.4070729330532491
similarity matrix truncated (Smooth round=14):  7.118032932281494
Smooth round: 15
--> Time elapsed: 27.962788105010986
--> Orignal sparsity=0.4883325471710157, Thresholding
--> Final sparsity=0.4213173189319078
similarity matrix truncated (Smooth round=15):  6.9173102378845215
Save the matrix\textasciitilde{}\textasciitilde{}\textasciitilde{}
Smooth round: 16
--> Time elapsed: 30.122084140777588
--> Orignal sparsity=0.49335887001744694, Thresholding
--> Final sparsity=0.43361185975353644
similarity matrix truncated (Smooth round=16):  6.2952094078063965
Smooth round: 17
--> Time elapsed: 23.850889921188354
--> Orignal sparsity=0.4974221533338559, Thresholding
--> Final sparsity=0.4441931303190831
similarity matrix truncated (Smooth round=17):  6.822499990463257
Smooth round: 18
--> Time elapsed: 19.682230949401855
--> Orignal sparsity=0.5007189762656963, Thresholding
--> Final sparsity=0.4532929059508365
similarity matrix truncated (Smooth round=18):  5.36142110824585
Smooth round: 19
--> Time elapsed: 22.470534801483154
--> Orignal sparsity=0.5034154015724991, Thresholding
--> Final sparsity=0.4611068082922735
similarity matrix truncated (Smooth round=19):  5.988668203353882
Smooth round: 20
--> Time elapsed: 25.77480912208557
--> Orignal sparsity=0.5056165430233724, Thresholding
--> Final sparsity=0.4678271396466843
similarity matrix truncated (Smooth round=20):  7.180889129638672
Save the matrix\textasciitilde{}\textasciitilde{}\textasciitilde{}
----------------
Step 1: Use highly variable genes to construct pseudo-clones, and apply CoSpar to generate initialized map!
HighVar-v0: avoid cells that have been selected
----------------
Step a: find the commonly shared highly variable genes
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=297\sphinxpxdimen,height=220\sphinxpxdimen]{{20210121_lung_data_18_1}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=278\sphinxpxdimen,height=220\sphinxpxdimen]{{20210121_lung_data_18_2}.png}

\end{nbsphinxfancyoutput}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Highly varable gene number at t1 is 3689, Highly varable gene number at t2 is 3729
Common gene set is 1075
----------------
Step b: convert the shared highly variable genes into clonal info
No cells left for assignment, total used genes=851
----------------
Step c: compute the transition map based on clonal info from highly variable genes
---------Compute the transition map-----------
Compute similarity matrix: load existing data
--> Time elapsed:  0.29691505432128906
--> Time elapsed:  2.7558279037475586
--> Time elapsed:  0.18540501594543457
--> Time elapsed:  2.560216188430786
Compute similarity matrix: load existing data
--> Time elapsed:  0.23672795295715332
--> Time elapsed:  1.7196333408355713
--> Time elapsed:  0.19963407516479492
--> Time elapsed:  2.1012139320373535
Compute similarity matrix: load existing data
--> Time elapsed:  0.15925121307373047
--> Time elapsed:  2.2766659259796143
--> Time elapsed:  0.3380889892578125
--> Time elapsed:  1.0854458808898926
Current iteration: 0
Use smooth\_round=20
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
--> Clone id: 1000
Start to smooth the refined clonal map
Phase I: time elapsed --  6.057301998138428
Phase II: time elapsed --  7.385257959365845
Current iteration: 1
Use smooth\_round=15
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
--> Clone id: 1000
Start to smooth the refined clonal map
Phase I: time elapsed --  5.1219611167907715
Phase II: time elapsed --  6.49406099319458
Current iteration: 2
Use smooth\_round=10
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
--> Clone id: 1000
Start to smooth the refined clonal map
Phase I: time elapsed --  4.645283937454224
Phase II: time elapsed --  6.02990198135376
No need for Final Smooth (i.e., clonally states are the final state space for Tmap)
----Demultiplexed transition map----
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
--> Clone id: 1000
Finishing computing transport map from highly variable genes, used time 135.27054286003113
----------------
Step 2: Jointly optimize the transition map and the initial clonal states!
Joint optimization that consider possibility of clonal overlap: v2
--> original clone shape: (12720, 272)
--> After excluding zero-sized clones at t2: (12720, 272)
Sort clones by size (small to large)
Infer the number of initial cells to extract for each clone in advance
--> Inferring early clonal states: current clone id 0
--> Inferring early clonal states: current clone id 100
--> Inferring early clonal states: current clone id 200
---------Compute the transition map-----------
Compute similarity matrix: load existing data
--> Time elapsed:  0.26981568336486816
--> Time elapsed:  0.8196010589599609
--> Time elapsed:  0.16419100761413574
--> Time elapsed:  0.4157860279083252
Compute similarity matrix: load existing data
--> Time elapsed:  0.2678558826446533
--> Time elapsed:  0.5867011547088623
--> Time elapsed:  0.15294790267944336
--> Time elapsed:  0.40844106674194336
Compute similarity matrix: load existing data
--> Time elapsed:  0.18117880821228027
--> Time elapsed:  0.580024003982544
--> Time elapsed:  0.18829822540283203
--> Time elapsed:  0.3908040523529053
Current iteration: 0
Use smooth\_round=20
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  0.3066589832305908
Phase II: time elapsed --  0.6201817989349365
Current iteration: 1
Use smooth\_round=15
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  0.1289079189300537
Phase II: time elapsed --  0.4577610492706299
Current iteration: 2
Use smooth\_round=10
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  0.09908199310302734
Phase II: time elapsed --  0.39781785011291504
Final round of Smooth (to expand the state space of Tmap to include non-clonal states)
Phase I: time elapsed --  0.7827582359313965
Phase II: time elapsed --  2.0664520263671875
----Demultiplexed transition map----
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Finishing computing transport map from CoSpar using inferred clonal data, used time 42.71480917930603
-------------------------------New Start--------------------------------------------------
Current time point: pos\_21
-----------Pre-processing and sub-sampling cells------------
----------------
Step 1: Use highly variable genes to construct pseudo-clones, and apply CoSpar to generate initialized map!
HighVar-v0: avoid cells that have been selected
----------------
Step a: find the commonly shared highly variable genes
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=278\sphinxpxdimen,height=220\sphinxpxdimen]{{20210121_lung_data_18_4}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=278\sphinxpxdimen,height=220\sphinxpxdimen]{{20210121_lung_data_18_5}.png}

\end{nbsphinxfancyoutput}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Highly varable gene number at t1 is 3794, Highly varable gene number at t2 is 3729
Common gene set is 1152
----------------
Step b: convert the shared highly variable genes into clonal info
No cells left for assignment, total used genes=1136
----------------
Step c: compute the transition map based on clonal info from highly variable genes
---------Compute the transition map-----------
Compute similarity matrix: load existing data
--> Time elapsed:  0.14574980735778809
--> Time elapsed:  1.5967421531677246
--> Time elapsed:  0.12334394454956055
--> Time elapsed:  1.4471712112426758
Compute similarity matrix: load existing data
--> Time elapsed:  0.11464405059814453
--> Time elapsed:  1.2609331607818604
--> Time elapsed:  0.08916783332824707
--> Time elapsed:  1.250248908996582
Compute similarity matrix: load existing data
--> Time elapsed:  0.12157678604125977
--> Time elapsed:  1.1028330326080322
--> Time elapsed:  0.11026191711425781
--> Time elapsed:  0.8104751110076904
Current iteration: 0
Use smooth\_round=20
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
--> Clone id: 1000
Start to smooth the refined clonal map
Phase I: time elapsed --  1.530857801437378
Phase II: time elapsed --  2.5124118328094482
Current iteration: 1
Use smooth\_round=15
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
--> Clone id: 1000
Start to smooth the refined clonal map
Phase I: time elapsed --  1.3739171028137207
Phase II: time elapsed --  2.476722002029419
Current iteration: 2
Use smooth\_round=10
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
--> Clone id: 1000
Start to smooth the refined clonal map
Phase I: time elapsed --  1.3121211528778076
Phase II: time elapsed --  2.465062141418457
No need for Final Smooth (i.e., clonally states are the final state space for Tmap)
----Demultiplexed transition map----
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
--> Clone id: 1000
Finishing computing transport map from highly variable genes, used time 95.43795609474182
----------------
Step 2: Jointly optimize the transition map and the initial clonal states!
Joint optimization that consider possibility of clonal overlap: v2
--> original clone shape: (12535, 272)
--> After excluding zero-sized clones at t2: (12535, 272)
Sort clones by size (small to large)
Infer the number of initial cells to extract for each clone in advance
--> Inferring early clonal states: current clone id 0
--> Inferring early clonal states: current clone id 100
--> Inferring early clonal states: current clone id 200
---------Compute the transition map-----------
Compute similarity matrix: load existing data
--> Time elapsed:  0.09975194931030273
--> Time elapsed:  0.4999051094055176
--> Time elapsed:  0.09682202339172363
--> Time elapsed:  0.4227142333984375
Compute similarity matrix: load existing data
--> Time elapsed:  0.09620094299316406
--> Time elapsed:  0.482684850692749
--> Time elapsed:  0.09868907928466797
--> Time elapsed:  0.35282206535339355
Compute similarity matrix: load existing data
--> Time elapsed:  0.0907740592956543
--> Time elapsed:  0.3866617679595947
--> Time elapsed:  0.07892918586730957
--> Time elapsed:  0.2702147960662842
Current iteration: 0
Use smooth\_round=20
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  0.22093629837036133
Phase II: time elapsed --  0.5003211498260498
Current iteration: 1
Use smooth\_round=15
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  0.1145479679107666
Phase II: time elapsed --  0.44263291358947754
Current iteration: 2
Use smooth\_round=10
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  0.09056806564331055
Phase II: time elapsed --  0.4043281078338623
Final round of Smooth (to expand the state space of Tmap to include non-clonal states)
Phase I: time elapsed --  0.39678382873535156
Phase II: time elapsed --  1.7405269145965576
----Demultiplexed transition map----
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Finishing computing transport map from CoSpar using inferred clonal data, used time 33.91204500198364
-----------Total used time: 1033.2948069572449 s ------------
\end{sphinxVerbatim}
}


\subsubsection{Save data or load}
\label{\detokenize{20210121_lung_data:Save-data-or-load}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[13]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{save\PYGZus{}data}\PYG{o}{=}\PYG{k+kc}{False}
\PYG{k}{if} \PYG{n}{save\PYGZus{}data}\PYG{p}{:}
    \PYG{n}{cs}\PYG{o}{.}\PYG{n}{hf}\PYG{o}{.}\PYG{n}{save\PYGZus{}map}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{)}

\PYG{n}{load\PYGZus{}data}\PYG{o}{=}\PYG{k+kc}{False}
\PYG{k}{if} \PYG{n}{load\PYGZus{}data}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{} updated Jan 27, 2021}
    \PYG{c+c1}{\PYGZsh{}data\PYGZus{}des=\PYGZsq{}paper\PYGZus{}OneTimeClone\PYGZus{}t*pos\PYGZus{}17*pos\PYGZus{}21*D27\PYGZsq{}}
    \PYG{n}{data\PYGZus{}des}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{CoSpar\PYGZus{}OneTimeClone\PYGZus{}t*pos\PYGZus{}17*pos\PYGZus{}21*D27}\PYG{l+s+s1}{\PYGZsq{}} \PYG{c+c1}{\PYGZsh{} computed on Jan 30, 2021}
    \PYG{n}{adata}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{hf}\PYG{o}{.}\PYG{n}{load\PYGZus{}saved\PYGZus{}adata\PYGZus{}with\PYGZus{}key}\PYG{p}{(}\PYG{n}{data\PYGZus{}des}\PYG{p}{)}

\end{sphinxVerbatim}
}


\subsubsection{Plotting}
\label{\detokenize{20210121_lung_data:Plotting}}

\paragraph{Plot fate map}
\label{\detokenize{20210121_lung_data:Plot-fate-map}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[14]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}map}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{iACE2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pos\PYGZus{}17}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pos\PYGZus{}21}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
               \PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=289\sphinxpxdimen,height=237\sphinxpxdimen]{{20210121_lung_data_23_0}.png}

\end{nbsphinxfancyoutput}


\paragraph{Relative fate bias}
\label{\detokenize{20210121_lung_data:Relative-fate-bias}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[15]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}bias\PYGZus{}intrinsic}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{iACE2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
            \PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pos\PYGZus{}17}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pos\PYGZus{}21}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{plot\PYGZus{}color\PYGZus{}bar}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}\PYG{n}{plot\PYGZus{}background}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=276\sphinxpxdimen,height=230\sphinxpxdimen]{{20210121_lung_data_25_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=331\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_lung_data_25_1}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[16]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{c+c1}{\PYGZsh{} This produces an average bias score that is close the the average clonal fate bias.}
\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{iACE2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PENC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Gut}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{NLE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Endoderm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}bias\PYGZus{}from\PYGZus{}binary\PYGZus{}competition}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{p}{,}\PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
            \PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pos\PYGZus{}17}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=315\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_lung_data_26_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=302\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_lung_data_26_1}.png}

\end{nbsphinxfancyoutput}


\paragraph{Dynamic trajectory inference on day 17}
\label{\detokenize{20210121_lung_data:Dynamic-trajectory-inference-on-day-17}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[17]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{iACE2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PENC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Gut}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{NLE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Endoderm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{dynamic\PYGZus{}trajectory\PYGZus{}from\PYGZus{}intrinsic\PYGZus{}bias}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{p}{,}
            \PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{bias\PYGZus{}threshold\PYGZus{}A}\PYG{o}{=}\PYG{l+m+mf}{0.7}\PYG{p}{,}\PYG{n}{bias\PYGZus{}threshold\PYGZus{}B}\PYG{o}{=}\PYG{l+m+mf}{0.7}\PYG{p}{,}
                            \PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pos\PYGZus{}17}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=583\sphinxpxdimen,height=283\sphinxpxdimen]{{20210121_lung_data_28_0}.png}

\end{nbsphinxfancyoutput}


\paragraph{Differential genes for two ancestor groups on day 17}
\label{\detokenize{20210121_lung_data:Differential-genes-for-two-ancestor-groups-on-day-17}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[18]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{dge\PYGZus{}gene\PYGZus{}A}\PYG{p}{,} \PYG{n}{dge\PYGZus{}gene\PYGZus{}B}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{differential\PYGZus{}genes}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{plot\PYGZus{}gene\PYGZus{}N}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{gene\PYGZus{}N}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=583\sphinxpxdimen,height=283\sphinxpxdimen]{{20210121_lung_data_30_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=472\sphinxpxdimen,height=171\sphinxpxdimen]{{20210121_lung_data_30_1}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=472\sphinxpxdimen,height=171\sphinxpxdimen]{{20210121_lung_data_30_2}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[19]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{dge\PYGZus{}gene\PYGZus{}A}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxout}[19]:\,\hspace{\fboxrule}\hspace{\fboxsep}}       gene            pv    mean\_1     mean\_2     ratio
225    RGCC  2.385363e-07  0.516128   4.353754 -1.820160
0    ERRFI1  1.819216e-77  4.772617  18.868851 -1.783211
110    KLF9  3.809360e-14  0.074725   2.650913 -1.764289
28     STOM  5.723646e-29  0.542995   4.004713 -1.697554
111    AQP3  5.064844e-14  0.043671   1.504599 -1.262912
..      {\ldots}           {\ldots}       {\ldots}        {\ldots}       {\ldots}
378  RNF145  1.506951e-04  0.507620   1.158090 -0.517482
652   ZADH2  8.800334e-03  0.261093   0.802966 -0.515697
317   ALDH2  3.303192e-05  1.010561   1.871094 -0.514002
401    XPR1  2.812946e-04  1.372163   2.381748 -0.511566
280  FNDC3B  7.389887e-06  2.147762   3.475198 -0.507625

[100 rows x 5 columns]
\end{sphinxVerbatim}
}


\paragraph{Dynamic trajectory on both day 17 and 21}
\label{\detokenize{20210121_lung_data:Dynamic-trajectory-on-both-day-17-and-21}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[20]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{iACE2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PENC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Gut}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{NLE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Endoderm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{dynamic\PYGZus{}trajectory\PYGZus{}from\PYGZus{}intrinsic\PYGZus{}bias}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{p}{,}
            \PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{bias\PYGZus{}threshold\PYGZus{}A}\PYG{o}{=}\PYG{l+m+mf}{0.7}\PYG{p}{,}\PYG{n}{bias\PYGZus{}threshold\PYGZus{}B}\PYG{o}{=}\PYG{l+m+mf}{0.7}\PYG{p}{,}
                            \PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pos\PYGZus{}17}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pos\PYGZus{}21}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=583\sphinxpxdimen,height=283\sphinxpxdimen]{{20210121_lung_data_33_0}.png}

\end{nbsphinxfancyoutput}


\paragraph{Gene trend along the dynamic trajectory}
\label{\detokenize{20210121_lung_data:Gene-trend-along-the-dynamic-trajectory}}
The selected states, combined with the target states are stored as dynamic trajectory at adata.uns{[}‘dynamic\_trajectory’{]}. We can plot gene trend along this trajectory

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[21]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{adata\PYGZus{}selected}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{gene\PYGZus{}expression\PYGZus{}dynamics}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fate}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{iACE2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{include\PYGZus{}target\PYGZus{}states}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}
    \PYG{n}{gene\PYGZus{}name\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{NEAT1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{RGCC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{KLF9}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ERRFI1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{AQP3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{CDH1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{CTD\PYGZhy{}2562J17.7}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}

\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{nbsphinx-stderr}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
/Users/shouwenwang/miniconda3/envs/CoSpar\_env/lib/python3.6/site-packages/plotnine/ggplot.py:729: PlotnineWarning: Saving 3.5 x 2.163 in image.
/Users/shouwenwang/miniconda3/envs/CoSpar\_env/lib/python3.6/site-packages/plotnine/ggplot.py:730: PlotnineWarning: Filename: lung\_figure\_test\_2/Lung\_OneTimeClone\_t*pos\_17*pos\_21*D27\_fate\_trajectory\_pseutoTime\_gene\_expression\_iACE2\_True.png
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=718\sphinxpxdimen,height=266\sphinxpxdimen]{{20210121_lung_data_36_1}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=732\sphinxpxdimen,height=429\sphinxpxdimen]{{20210121_lung_data_36_2}.png}

\end{nbsphinxfancyoutput}


\section{Synthetic data (static barcoding)}
\label{\detokenize{20210120-Bifurcation_model_static_barcoding:Synthetic-data-(static-barcoding)}}\label{\detokenize{20210120-Bifurcation_model_static_barcoding::doc}}
We simulated a differentiation process over a bifurcation fork. In this simulation, cells are barcoded in the beginning, and the barcodes remain un\sphinxhyphen{}changed. In the simulation we resample clones over time, like the experimental design to obtain the hematopoietic dataset or the reprogramming dataset. The dataset has two time points.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[1]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{k+kn}{import} \PYG{n+nn}{cospar} \PYG{k}{as} \PYG{n+nn}{cs}
\end{sphinxVerbatim}
}


\subsection{Initialization and Preprocessing}
\label{\detokenize{20210120-Bifurcation_model_static_barcoding:Initialization-and-Preprocessing}}

\subsubsection{Loading data}
\label{\detokenize{20210120-Bifurcation_model_static_barcoding:Loading-data}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[2]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{adata\PYGZus{}orig}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{datasets}\PYG{o}{.}\PYG{n}{synthetic\PYGZus{}bifurcation\PYGZus{}static\PYGZus{}BC}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
try downloading from url
https://kleintools.hms.harvard.edu/tools/downloads/cospar/bifurcation\_static\_BC\_adata\_preprocessed.h5ad
{\ldots} this may take a while but only happens once
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
HBox(children=(HTML(value=''), FloatProgress(value=0.0, max=1549754.0), HTML(value='')))
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]

\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[3]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{adata\PYGZus{}orig}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxout}[3]:\,\hspace{\fboxrule}\hspace{\fboxsep}}AnnData object with n\_obs × n\_vars = 2474 × 50
    obs: 'time\_info', 'state\_info'
    uns: 'clonal\_time\_points', 'data\_des'
    obsm: 'X\_clone', 'X\_emb', 'X\_pca'
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[5]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{embedding}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{state\PYGZus{}info}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=415\sphinxpxdimen,height=262\sphinxpxdimen]{{20210120-Bifurcation_model_static_barcoding_7_0}.png}

\end{nbsphinxfancyoutput}


\subsubsection{Raw clonal data analysis (without using state information)}
\label{\detokenize{20210120-Bifurcation_model_static_barcoding:Raw-clonal-data-analysis-(without-using-state-information)}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[6]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{clones\PYGZus{}on\PYGZus{}manifold}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{selected\PYGZus{}clone\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=237\sphinxpxdimen,height=177\sphinxpxdimen]{{20210120-Bifurcation_model_static_barcoding_9_0}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[7]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{plot\PYGZus{}time\PYGZus{}point}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}coupling\PYGZus{}from\PYGZus{}clones}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{plot\PYGZus{}time\PYGZus{}point}\PYG{p}{,} \PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{color\PYGZus{}bar}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=360\sphinxpxdimen,height=280\sphinxpxdimen]{{20210120-Bifurcation_model_static_barcoding_10_0}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[8]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{plot\PYGZus{}time\PYGZus{}point}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{barcode\PYGZus{}heatmap}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{plot\PYGZus{}time\PYGZus{}point}\PYG{p}{,} \PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{color\PYGZus{}bar}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=281\sphinxpxdimen,height=424\sphinxpxdimen]{{20210120-Bifurcation_model_static_barcoding_11_0}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[9]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{select\PYGZus{}fate\PYGZus{}cluster}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{clonal\PYGZus{}fate\PYGZus{}bias}\PYG{p}{,}\PYG{n}{clone\PYGZus{}id}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{clonal\PYGZus{}fate\PYGZus{}bias}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{select\PYGZus{}fate\PYGZus{}cluster}\PYG{p}{,}\PYG{n}{N\PYGZus{}resampling}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Current clone id: 0
Current clone id: 5
Current clone id: 10
Current clone id: 15
Current clone id: 20
Current clone id: 25
Current clone id: 30
Current clone id: 35
Current clone id: 40
Current clone id: 45
Current clone id: 50
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=280\sphinxpxdimen,height=244\sphinxpxdimen]{{20210120-Bifurcation_model_static_barcoding_12_1}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=279\sphinxpxdimen,height=252\sphinxpxdimen]{{20210120-Bifurcation_model_static_barcoding_12_2}.png}

\end{nbsphinxfancyoutput}


\subsection{Transition map inference}
\label{\detokenize{20210120-Bifurcation_model_static_barcoding:Transition-map-inference}}

\subsubsection{Transition map from multiple clonal time points.}
\label{\detokenize{20210120-Bifurcation_model_static_barcoding:Transition-map-from-multiple-clonal-time-points.}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[10]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{use\PYGZus{}full\PYGZus{}Smatrix}\PYG{o}{=}\PYG{k+kc}{True}
\PYG{n}{noise\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mf}{0.2} \PYG{c+c1}{\PYGZsh{}}
\PYG{n}{selected\PYGZus{}clonal\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{adata}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{tmap}\PYG{o}{.}\PYG{n}{infer\PYGZus{}Tmap\PYGZus{}from\PYGZus{}multitime\PYGZus{}clones}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{selected\PYGZus{}clonal\PYGZus{}time\PYGZus{}points}\PYG{p}{,}\PYG{n}{smooth\PYGZus{}array}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,}
            \PYG{n}{CoSpar\PYGZus{}KNN}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{n}{noise\PYGZus{}threshold}\PYG{o}{=}\PYG{n}{noise\PYGZus{}threshold}\PYG{p}{,}\PYG{n}{demulti\PYGZus{}threshold}\PYG{o}{=}\PYG{n}{noise\PYGZus{}threshold}\PYG{p}{,}
             \PYG{n}{use\PYGZus{}full\PYGZus{}Smatrix}\PYG{o}{=}\PYG{n}{use\PYGZus{}full\PYGZus{}Smatrix}\PYG{p}{,}\PYG{n}{use\PYGZus{}all\PYGZus{}cells}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
-------Step 1: Select time points---------
--> Clonal cell fraction (day 1-2): 1.0
--> Clonal cell fraction (day 2-1): 1.0
--> Numer of cells that are clonally related -- day 1: 854  and day 2: 1620
Valid clone number 'FOR' post selection 52
Cell number=2474, Clone number=52
-------Step 2: Compute the full Similarity matrix if necessary---------
Compute similarity matrix: computing new; beta=0.1
Smooth round: 1
--> Time elapsed: 0.0065500736236572266
Smooth round: 2
--> Time elapsed: 0.04064488410949707
--> Orignal sparsity=0.18047254911058844, Thresholding
--> Final sparsity=0.16805970451629854
similarity matrix truncated (Smooth round=2):  0.10501980781555176
Smooth round: 3
--> Time elapsed: 0.2107398509979248
--> Orignal sparsity=0.36128591024912937, Thresholding
--> Final sparsity=0.3115755514586951
similarity matrix truncated (Smooth round=3):  0.11839008331298828
Smooth round: 4
--> Time elapsed: 0.28410983085632324
--> Orignal sparsity=0.4542983487444851, Thresholding
--> Final sparsity=0.3801705890003
similarity matrix truncated (Smooth round=4):  0.10097503662109375
Smooth round: 5
--> Time elapsed: 0.2772088050842285
--> Orignal sparsity=0.5090226961858462, Thresholding
--> Final sparsity=0.4313755539420809
similarity matrix truncated (Smooth round=5):  0.11639904975891113
Save the matrix\textasciitilde{}\textasciitilde{}\textasciitilde{}
Smooth round: 6
--> Time elapsed: 0.33049702644348145
--> Orignal sparsity=0.5543067465096992, Thresholding
--> Final sparsity=0.4738424317836788
similarity matrix truncated (Smooth round=6):  0.11284589767456055
Smooth round: 7
--> Time elapsed: 0.38887786865234375
--> Orignal sparsity=0.5961557187474064, Thresholding
--> Final sparsity=0.5110177372564729
similarity matrix truncated (Smooth round=7):  0.11432099342346191
Smooth round: 8
--> Time elapsed: 0.4345111846923828
--> Orignal sparsity=0.6371680186959741, Thresholding
--> Final sparsity=0.543228558414136
similarity matrix truncated (Smooth round=8):  0.12262606620788574
Smooth round: 9
--> Time elapsed: 0.40210509300231934
--> Orignal sparsity=0.673204887826116, Thresholding
--> Final sparsity=0.5714666157790415
similarity matrix truncated (Smooth round=9):  0.11144113540649414
Smooth round: 10
--> Time elapsed: 0.4940023422241211
--> Orignal sparsity=0.7017969910513152, Thresholding
--> Final sparsity=0.5978522633774439
similarity matrix truncated (Smooth round=10):  0.11046934127807617
Save the matrix\textasciitilde{}\textasciitilde{}\textasciitilde{}
-------Step 3: Optimize the transition map recursively---------
---------Compute the transition map-----------
Compute similarity matrix: load existing data
--> Time elapsed:  0.011964082717895508
--> Time elapsed:  0.0265657901763916
--> Time elapsed:  0.008074045181274414
--> Time elapsed:  0.025511980056762695
Compute similarity matrix: load existing data
--> Time elapsed:  0.010082006454467773
--> Time elapsed:  0.02631998062133789
--> Time elapsed:  0.008765935897827148
--> Time elapsed:  0.026265859603881836
Compute similarity matrix: load existing data
--> Time elapsed:  0.00886988639831543
--> Time elapsed:  0.02891993522644043
--> Time elapsed:  0.013264179229736328
--> Time elapsed:  0.04337882995605469
Current iteration: 0
Use smooth\_round=10
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  0.0379939079284668
Phase II: time elapsed --  0.05436587333679199
Current iteration: 1
Use smooth\_round=10
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  0.011701107025146484
Phase II: time elapsed --  0.022777080535888672
Current iteration: 2
Use smooth\_round=10
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  0.018460988998413086
Phase II: time elapsed --  0.0346832275390625
No need for Final Smooth (i.e., clonally states are the final state space for Tmap)
----Demultiplexed transition map----
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
-----------Total used time: 11.65038275718689 s ------------
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=349\sphinxpxdimen,height=231\sphinxpxdimen]{{20210120-Bifurcation_model_static_barcoding_15_1}.png}

\end{nbsphinxfancyoutput}

Generate demultiplexed map within each clone (Optional, as this map has been generated already)

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[11]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{run\PYGZus{}demultiplex}\PYG{o}{=}\PYG{k+kc}{False}
\PYG{k}{if} \PYG{n}{run\PYGZus{}demultiplex}\PYG{p}{:}
    \PYG{n}{demulti\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mf}{0.2} \PYG{c+c1}{\PYGZsh{} This threshold should be smaller, ass the map has been further smoothed to expand to more states.}
    \PYG{n}{cs}\PYG{o}{.}\PYG{n}{tmap}\PYG{o}{.}\PYG{n}{infer\PYGZus{}intraclone\PYGZus{}Tmap}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{demulti\PYGZus{}threshold}\PYG{o}{=}\PYG{n}{demulti\PYGZus{}threshold}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[12]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}bias\PYGZus{}from\PYGZus{}binary\PYGZus{}competition}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
            \PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{sum\PYGZus{}fate\PYGZus{}prob\PYGZus{}thresh}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=299\sphinxpxdimen,height=253\sphinxpxdimen]{{20210120-Bifurcation_model_static_barcoding_18_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=285\sphinxpxdimen,height=253\sphinxpxdimen]{{20210120-Bifurcation_model_static_barcoding_18_1}.png}

\end{nbsphinxfancyoutput}


\subsubsection{Transition map from a single clonal time point}
\label{\detokenize{20210120-Bifurcation_model_static_barcoding:Transition-map-from-a-single-clonal-time-point}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[13]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{initial\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{clonal\PYGZus{}time\PYGZus{}point}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{adata}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{tmap}\PYG{o}{.}\PYG{n}{infer\PYGZus{}Tmap\PYGZus{}from\PYGZus{}one\PYGZus{}time\PYGZus{}clones}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{initial\PYGZus{}time\PYGZus{}points}\PYG{p}{,}\PYG{n}{clonal\PYGZus{}time\PYGZus{}point}\PYG{p}{,}
     \PYG{n}{Clone\PYGZus{}update\PYGZus{}iter\PYGZus{}N}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{initialize\PYGZus{}method}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{OT}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{smooth\PYGZus{}array}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,}
                        \PYG{n}{noise\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{,}\PYG{n}{compute\PYGZus{}new}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
-------------------------------New Start--------------------------------------------------
Current time point: 1
-----------Pre-processing and sub-sampling cells------------
----------------
Step 1: Use OT method for initialization
Compute new shortest path distance matrix
--> Chosen mode is distances
Finishing computing shortest-path distance, used time 3.174316883087158
Compute new custon OT matrix
OT solver: duality\_gap
Finishing computing optial transport map, used time 3.236064910888672
----------------
Step 2: Jointly optimize the transition map and the initial clonal states!
Joint optimization that consider possibility of clonal overlap: v2
--> original clone shape: (2474, 52)
--> After excluding zero-sized clones at t2: (2474, 52)
Sort clones by size (small to large)
Infer the number of initial cells to extract for each clone in advance
--> Inferring early clonal states: current clone id 0
---------Compute the transition map-----------
Compute similarity matrix: computing new; beta=0.1
Smooth round: 1
--> Time elapsed: 0.005304098129272461
Smooth round: 2
--> Time elapsed: 0.037136077880859375
--> Orignal sparsity=0.18047254911058844, Thresholding
--> Final sparsity=0.16805970451629854
similarity matrix truncated (Smooth round=2):  0.0864109992980957
Smooth round: 3
--> Time elapsed: 0.17737793922424316
--> Orignal sparsity=0.36128591024912937, Thresholding
--> Final sparsity=0.3115755514586951
similarity matrix truncated (Smooth round=3):  0.10857129096984863
Smooth round: 4
--> Time elapsed: 0.2745969295501709
--> Orignal sparsity=0.4542983487444851, Thresholding
--> Final sparsity=0.3801705890003
similarity matrix truncated (Smooth round=4):  0.10771417617797852
Smooth round: 5
--> Time elapsed: 0.32264113426208496
--> Orignal sparsity=0.5090226961858462, Thresholding
--> Final sparsity=0.4313755539420809
similarity matrix truncated (Smooth round=5):  0.11082911491394043
Save the matrix\textasciitilde{}\textasciitilde{}\textasciitilde{}
Smooth round: 6
--> Time elapsed: 0.33100080490112305
--> Orignal sparsity=0.5543067465096992, Thresholding
--> Final sparsity=0.4738424317836788
similarity matrix truncated (Smooth round=6):  0.11528491973876953
Smooth round: 7
--> Time elapsed: 0.3826298713684082
--> Orignal sparsity=0.5961557187474064, Thresholding
--> Final sparsity=0.5110177372564729
similarity matrix truncated (Smooth round=7):  0.11359381675720215
Smooth round: 8
--> Time elapsed: 0.44081902503967285
--> Orignal sparsity=0.6371680186959741, Thresholding
--> Final sparsity=0.543228558414136
similarity matrix truncated (Smooth round=8):  0.1231377124786377
Smooth round: 9
--> Time elapsed: 0.42861294746398926
--> Orignal sparsity=0.673204887826116, Thresholding
--> Final sparsity=0.5714666157790415
similarity matrix truncated (Smooth round=9):  0.11669087409973145
Smooth round: 10
--> Time elapsed: 0.5159029960632324
--> Orignal sparsity=0.7017969910513152, Thresholding
--> Final sparsity=0.5978522633774439
similarity matrix truncated (Smooth round=10):  0.10596299171447754
Save the matrix\textasciitilde{}\textasciitilde{}\textasciitilde{}
--> Time elapsed:  0.015125036239624023
--> Time elapsed:  0.029886960983276367
--> Time elapsed:  0.010583639144897461
--> Time elapsed:  0.028316974639892578
Compute similarity matrix: load existing data
--> Time elapsed:  0.008720874786376953
--> Time elapsed:  0.0272371768951416
--> Time elapsed:  0.010474920272827148
--> Time elapsed:  0.02804088592529297
Compute similarity matrix: load existing data
--> Time elapsed:  0.006906747817993164
--> Time elapsed:  0.024413108825683594
--> Time elapsed:  0.00768589973449707
--> Time elapsed:  0.02739882469177246
Current iteration: 0
Use smooth\_round=10
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  0.03129911422729492
Phase II: time elapsed --  0.05033588409423828
Current iteration: 1
Use smooth\_round=10
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  0.013505697250366211
Phase II: time elapsed --  0.03381180763244629
Current iteration: 2
Use smooth\_round=10
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Start to smooth the refined clonal map
Phase I: time elapsed --  0.01205134391784668
Phase II: time elapsed --  0.031478166580200195
No need for Final Smooth (i.e., clonally states are the final state space for Tmap)
----Demultiplexed transition map----
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
Finishing computing transport map from CoSpar using inferred clonal data, used time 8.720440149307251
-----------Total used time: 15.300827264785767 s ------------
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[14]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}bias\PYGZus{}from\PYGZus{}binary\PYGZus{}competition}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
            \PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{sum\PYGZus{}fate\PYGZus{}prob\PYGZus{}thresh}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=299\sphinxpxdimen,height=253\sphinxpxdimen]{{20210120-Bifurcation_model_static_barcoding_21_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=285\sphinxpxdimen,height=253\sphinxpxdimen]{{20210120-Bifurcation_model_static_barcoding_21_1}.png}

\end{nbsphinxfancyoutput}


\subsection{Transition amp from only the clonal information}
\label{\detokenize{20210120-Bifurcation_model_static_barcoding:Transition-amp-from-only-the-clonal-information}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[15]:\,\hspace{\fboxrule}\hspace{\fboxsep}} \PYG{n}{cs}\PYG{o}{.}\PYG{n}{tmap}\PYG{o}{.}\PYG{n}{infer\PYGZus{}Tmap\PYGZus{}from\PYGZus{}clonal\PYGZus{}info\PYGZus{}alone}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{)}

\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}bias\PYGZus{}from\PYGZus{}binary\PYGZus{}competition}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{clonal\PYGZus{}transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
            \PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{sum\PYGZus{}fate\PYGZus{}prob\PYGZus{}thresh}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=299\sphinxpxdimen,height=253\sphinxpxdimen]{{20210120-Bifurcation_model_static_barcoding_23_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=279\sphinxpxdimen,height=253\sphinxpxdimen]{{20210120-Bifurcation_model_static_barcoding_23_1}.png}

\end{nbsphinxfancyoutput}


\section{Synthetic data (dynamic barcoding)}
\label{\detokenize{20210120-Bifurcation_model_dynamic_barcoding:Synthetic-data-(dynamic-barcoding)}}\label{\detokenize{20210120-Bifurcation_model_dynamic_barcoding::doc}}
We simulated a differentiation process over a bifurcation fork. In this simulation, cells are barcoded, and the barcodes could accumulate mutations, which we call \sphinxstyleemphasis{dynamic barcoding}. In the simulation we resample clones over time, like the experimental design to obtain the hematopoietic dataset or the reprogramming dataset. The dataset has two time points.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[1]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{k+kn}{import} \PYG{n+nn}{cospar} \PYG{k}{as} \PYG{n+nn}{cs}
\end{sphinxVerbatim}
}


\subsection{Initialization and Preprocessing}
\label{\detokenize{20210120-Bifurcation_model_dynamic_barcoding:Initialization-and-Preprocessing}}

\subsubsection{Loading data}
\label{\detokenize{20210120-Bifurcation_model_dynamic_barcoding:Loading-data}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[2]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{adata\PYGZus{}orig}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{datasets}\PYG{o}{.}\PYG{n}{synthetic\PYGZus{}bifurcation\PYGZus{}dynamic\PYGZus{}BC}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
try downloading from url
https://kleintools.hms.harvard.edu/tools/downloads/cospar/bifurcation\_dynamic\_BC\_adata\_preprocessed.h5ad
{\ldots} this may take a while but only happens once
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
HBox(children=(HTML(value=''), FloatProgress(value=0.0, max=1222616.0), HTML(value='')))
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]

\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[3]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{adata\PYGZus{}orig}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxout}[3]:\,\hspace{\fboxrule}\hspace{\fboxsep}}AnnData object with n\_obs × n\_vars = 1894 × 50
    obs: 'time\_info', 'state\_info'
    uns: 'clonal\_time\_points', 'data\_des', 'state\_info\_colors'
    obsm: 'X\_clone', 'X\_emb', 'X\_pca'
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[4]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{embedding}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{state\PYGZus{}info}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=415\sphinxpxdimen,height=262\sphinxpxdimen]{{20210120-Bifurcation_model_dynamic_barcoding_6_0}.png}

\end{nbsphinxfancyoutput}


\subsubsection{Raw clonal data analysis (without using state information)}
\label{\detokenize{20210120-Bifurcation_model_dynamic_barcoding:Raw-clonal-data-analysis-(without-using-state-information)}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[5]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{clones\PYGZus{}on\PYGZus{}manifold}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{selected\PYGZus{}clone\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=237\sphinxpxdimen,height=177\sphinxpxdimen]{{20210120-Bifurcation_model_dynamic_barcoding_8_0}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[6]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{plot\PYGZus{}time\PYGZus{}point}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}coupling\PYGZus{}from\PYGZus{}clones}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{plot\PYGZus{}time\PYGZus{}point}\PYG{p}{,} \PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{color\PYGZus{}bar}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=354\sphinxpxdimen,height=280\sphinxpxdimen]{{20210120-Bifurcation_model_dynamic_barcoding_9_0}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[7]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{plot\PYGZus{}time\PYGZus{}point}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{barcode\PYGZus{}heatmap}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{plot\PYGZus{}time\PYGZus{}point}\PYG{p}{,} \PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{color\PYGZus{}bar}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=281\sphinxpxdimen,height=424\sphinxpxdimen]{{20210120-Bifurcation_model_dynamic_barcoding_10_0}.png}

\end{nbsphinxfancyoutput}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[8]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{select\PYGZus{}fate\PYGZus{}cluster}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{clonal\PYGZus{}fate\PYGZus{}bias}\PYG{p}{,}\PYG{n}{clone\PYGZus{}id}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{clonal\PYGZus{}fate\PYGZus{}bias}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{select\PYGZus{}fate\PYGZus{}cluster}\PYG{p}{,}\PYG{n}{N\PYGZus{}resampling}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Current clone id: 0
Current clone id: 5
Current clone id: 10
Current clone id: 15
Current clone id: 20
Current clone id: 25
Current clone id: 30
Current clone id: 35
Current clone id: 40
Current clone id: 45
Current clone id: 50
Current clone id: 55
Current clone id: 60
Current clone id: 65
Current clone id: 70
Current clone id: 75
Current clone id: 80
Current clone id: 85
Current clone id: 90
Current clone id: 95
Current clone id: 100
Current clone id: 105
Current clone id: 110
Current clone id: 115
Current clone id: 120
Current clone id: 125
Current clone id: 130
Current clone id: 135
Current clone id: 140
Current clone id: 145
Current clone id: 150
Current clone id: 155
Current clone id: 160
Current clone id: 165
Current clone id: 170
Current clone id: 175
Current clone id: 180
Current clone id: 185
Current clone id: 190
Current clone id: 195
Current clone id: 200
Current clone id: 205
Current clone id: 210
Current clone id: 215
Current clone id: 220
Current clone id: 225
Current clone id: 230
Current clone id: 235
Current clone id: 240
Current clone id: 245
Current clone id: 250
Current clone id: 255
Current clone id: 260
Current clone id: 265
Current clone id: 270
Current clone id: 275
Current clone id: 280
Current clone id: 285
Current clone id: 290
Current clone id: 295
Current clone id: 300
Current clone id: 305
Current clone id: 310
Current clone id: 315
Current clone id: 320
Current clone id: 325
Current clone id: 330
Current clone id: 335
Current clone id: 340
Current clone id: 345
Current clone id: 350
Current clone id: 355
Current clone id: 360
Current clone id: 365
Current clone id: 370
Current clone id: 375
Current clone id: 380
Current clone id: 385
Current clone id: 390
Current clone id: 395
Current clone id: 400
Current clone id: 405
Current clone id: 410
Current clone id: 415
Current clone id: 420
Current clone id: 425
Current clone id: 430
Current clone id: 435
Current clone id: 440
Current clone id: 445
Current clone id: 450
Current clone id: 455
Current clone id: 460
Current clone id: 465
Current clone id: 470
Current clone id: 475
Current clone id: 480
Current clone id: 485
Current clone id: 490
Current clone id: 495
Current clone id: 500
Current clone id: 505
Current clone id: 510
Current clone id: 515
Current clone id: 520
Current clone id: 525
Current clone id: 530
Current clone id: 535
Current clone id: 540
Current clone id: 545
Current clone id: 550
Current clone id: 555
Current clone id: 560
Current clone id: 565
Current clone id: 570
Current clone id: 575
Current clone id: 580
Current clone id: 585
Current clone id: 590
Current clone id: 595
Current clone id: 600
Current clone id: 605
Current clone id: 610
Current clone id: 615
Current clone id: 620
Current clone id: 625
Current clone id: 630
Current clone id: 635
Current clone id: 640
Current clone id: 645
Current clone id: 650
Current clone id: 655
Current clone id: 660
Current clone id: 665
Current clone id: 670
Current clone id: 675
Current clone id: 680
Current clone id: 685
Current clone id: 690
Current clone id: 695
Current clone id: 700
Current clone id: 705
Current clone id: 710
Current clone id: 715
Current clone id: 720
Current clone id: 725
Current clone id: 730
Current clone id: 735
Current clone id: 740
Current clone id: 745
Current clone id: 750
Current clone id: 755
Current clone id: 760
Current clone id: 765
Current clone id: 770
Current clone id: 775
Current clone id: 780
Current clone id: 785
Current clone id: 790
Current clone id: 795
Current clone id: 800
Current clone id: 805
Current clone id: 810
Current clone id: 815
Current clone id: 820
Current clone id: 825
Current clone id: 830
Current clone id: 835
Current clone id: 840
Current clone id: 845
Current clone id: 850
Current clone id: 855
Current clone id: 860
Current clone id: 865
Current clone id: 870
Current clone id: 875
Current clone id: 880
Current clone id: 885
Current clone id: 890
Current clone id: 895
Current clone id: 900
Current clone id: 905
Current clone id: 910
Current clone id: 915
Current clone id: 920
Current clone id: 925
Current clone id: 930
Current clone id: 935
Current clone id: 940
Current clone id: 945
Current clone id: 950
Current clone id: 955
Current clone id: 960
Current clone id: 965
Current clone id: 970
Current clone id: 975
Current clone id: 980
Current clone id: 985
Current clone id: 990
Current clone id: 995
Current clone id: 1000
Current clone id: 1005
Current clone id: 1010
Current clone id: 1015
Current clone id: 1020
Current clone id: 1025
Current clone id: 1030
Current clone id: 1035
Current clone id: 1040
Current clone id: 1045
Current clone id: 1050
Current clone id: 1055
Current clone id: 1060
Current clone id: 1065
Current clone id: 1070
Current clone id: 1075
Current clone id: 1080
Current clone id: 1085
Current clone id: 1090
Current clone id: 1095
Current clone id: 1100
Current clone id: 1105
Current clone id: 1110
Current clone id: 1115
Current clone id: 1120
Current clone id: 1125
Current clone id: 1130
Current clone id: 1135
Current clone id: 1140
Current clone id: 1145
Current clone id: 1150
Current clone id: 1155
Current clone id: 1160
Current clone id: 1165
Current clone id: 1170
Current clone id: 1175
Current clone id: 1180
Current clone id: 1185
Current clone id: 1190
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=280\sphinxpxdimen,height=244\sphinxpxdimen]{{20210120-Bifurcation_model_dynamic_barcoding_11_1}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=285\sphinxpxdimen,height=252\sphinxpxdimen]{{20210120-Bifurcation_model_dynamic_barcoding_11_2}.png}

\end{nbsphinxfancyoutput}


\subsection{Transition map inference}
\label{\detokenize{20210120-Bifurcation_model_dynamic_barcoding:Transition-map-inference}}

\subsubsection{Transition map from multiple clonal time points.}
\label{\detokenize{20210120-Bifurcation_model_dynamic_barcoding:Transition-map-from-multiple-clonal-time-points.}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[9]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{use\PYGZus{}full\PYGZus{}Smatrix}\PYG{o}{=}\PYG{k+kc}{True}
\PYG{n}{noise\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mf}{0.2} \PYG{c+c1}{\PYGZsh{}}
\PYG{n}{selected\PYGZus{}clonal\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{adata}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{tmap}\PYG{o}{.}\PYG{n}{infer\PYGZus{}Tmap\PYGZus{}from\PYGZus{}multitime\PYGZus{}clones}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{selected\PYGZus{}clonal\PYGZus{}time\PYGZus{}points}\PYG{p}{,}\PYG{n}{smooth\PYGZus{}array}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,}
            \PYG{n}{CoSpar\PYGZus{}KNN}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{n}{noise\PYGZus{}threshold}\PYG{o}{=}\PYG{n}{noise\PYGZus{}threshold}\PYG{p}{,}\PYG{n}{demulti\PYGZus{}threshold}\PYG{o}{=}\PYG{n}{noise\PYGZus{}threshold}\PYG{p}{,}
             \PYG{n}{use\PYGZus{}full\PYGZus{}Smatrix}\PYG{o}{=}\PYG{n}{use\PYGZus{}full\PYGZus{}Smatrix}\PYG{p}{,}\PYG{n}{use\PYGZus{}all\PYGZus{}cells}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
-------Step 1: Select time points---------
--> Clonal cell fraction (day 1-2): 0.6891891891891891
--> Clonal cell fraction (day 2-1): 0.6954397394136808
--> Numer of cells that are clonally related -- day 1: 459  and day 2: 854
Valid clone number 'FOR' post selection 664
Cell number=1313, Clone number=1250
-------Step 2: Compute the full Similarity matrix if necessary---------
Compute similarity matrix: computing new; beta=0.1
Smooth round: 1
--> Time elapsed: 0.005765199661254883
Smooth round: 2
--> Time elapsed: 0.04189419746398926
--> Orignal sparsity=0.20817922210860954, Thresholding
--> Final sparsity=0.19417261646571343
similarity matrix truncated (Smooth round=2):  0.07763195037841797
Smooth round: 3
--> Time elapsed: 0.11136007308959961
--> Orignal sparsity=0.38404861012768604, Thresholding
--> Final sparsity=0.3351262643439127
similarity matrix truncated (Smooth round=3):  0.06285476684570312
Smooth round: 4
--> Time elapsed: 0.16349005699157715
--> Orignal sparsity=0.4768350897459771, Thresholding
--> Final sparsity=0.4027396023010474
similarity matrix truncated (Smooth round=4):  0.08010601997375488
Smooth round: 5
--> Time elapsed: 0.1728661060333252
--> Orignal sparsity=0.5275939469831369, Thresholding
--> Final sparsity=0.45277060109789263
similarity matrix truncated (Smooth round=5):  0.06105303764343262
Save the matrix\textasciitilde{}\textasciitilde{}\textasciitilde{}
Smooth round: 6
--> Time elapsed: 0.26447272300720215
--> Orignal sparsity=0.5694367474010631, Thresholding
--> Final sparsity=0.4926809945038464
similarity matrix truncated (Smooth round=6):  0.07140564918518066
Smooth round: 7
--> Time elapsed: 0.21038579940795898
--> Orignal sparsity=0.608515860121832, Thresholding
--> Final sparsity=0.5261845052848488
similarity matrix truncated (Smooth round=7):  0.0694112777709961
Smooth round: 8
--> Time elapsed: 0.23746991157531738
--> Orignal sparsity=0.6446768486935345, Thresholding
--> Final sparsity=0.5550340150466821
similarity matrix truncated (Smooth round=8):  0.07171773910522461
Smooth round: 9
--> Time elapsed: 0.2531599998474121
--> Orignal sparsity=0.6754060786633497, Thresholding
--> Final sparsity=0.5813643150325208
similarity matrix truncated (Smooth round=9):  0.06805682182312012
Smooth round: 10
--> Time elapsed: 0.26459193229675293
--> Orignal sparsity=0.7013976777663917, Thresholding
--> Final sparsity=0.6061248827788303
similarity matrix truncated (Smooth round=10):  0.06914997100830078
Save the matrix\textasciitilde{}\textasciitilde{}\textasciitilde{}
-------Step 3: Optimize the transition map recursively---------
---------Compute the transition map-----------
Compute similarity matrix: load existing data
--> Time elapsed:  0.005687713623046875
--> Time elapsed:  0.009057044982910156
--> Time elapsed:  0.00498199462890625
--> Time elapsed:  0.010453939437866211
Compute similarity matrix: load existing data
--> Time elapsed:  0.0034210681915283203
--> Time elapsed:  0.010492086410522461
--> Time elapsed:  0.0028977394104003906
--> Time elapsed:  0.012233257293701172
Compute similarity matrix: load existing data
--> Time elapsed:  0.0038161277770996094
--> Time elapsed:  0.00858306884765625
--> Time elapsed:  0.0037457942962646484
--> Time elapsed:  0.008623123168945312
Current iteration: 0
Use smooth\_round=10
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
--> Clone id: 1000
Start to smooth the refined clonal map
Phase I: time elapsed --  0.002910137176513672
Phase II: time elapsed --  0.0061740875244140625
Current iteration: 1
Use smooth\_round=10
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
--> Clone id: 1000
Start to smooth the refined clonal map
Phase I: time elapsed --  0.004522085189819336
Phase II: time elapsed --  0.008304834365844727
Current iteration: 2
Use smooth\_round=10
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
--> Clone id: 1000
Start to smooth the refined clonal map
Phase I: time elapsed --  0.0035140514373779297
Phase II: time elapsed --  0.005897998809814453
No need for Final Smooth (i.e., clonally states are the final state space for Tmap)
----Demultiplexed transition map----
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
--> Clone id: 1000
-----------Total used time: 11.509425163269043 s ------------
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=349\sphinxpxdimen,height=231\sphinxpxdimen]{{20210120-Bifurcation_model_dynamic_barcoding_14_1}.png}

\end{nbsphinxfancyoutput}

Generate demultiplexed map within each clone (Optional, as this map has been generated already)

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[10]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{run\PYGZus{}demultiplex}\PYG{o}{=}\PYG{k+kc}{False}
\PYG{k}{if} \PYG{n}{run\PYGZus{}demultiplex}\PYG{p}{:}
    \PYG{n}{demulti\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mf}{0.2} \PYG{c+c1}{\PYGZsh{} This threshold should be smaller, ass the map has been further smoothed to expand to more states.}
    \PYG{n}{cs}\PYG{o}{.}\PYG{n}{tmap}\PYG{o}{.}\PYG{n}{infer\PYGZus{}intraclone\PYGZus{}Tmap}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{demulti\PYGZus{}threshold}\PYG{o}{=}\PYG{n}{demulti\PYGZus{}threshold}\PYG{p}{)}
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[11]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}bias\PYGZus{}from\PYGZus{}binary\PYGZus{}competition}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
            \PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{sum\PYGZus{}fate\PYGZus{}prob\PYGZus{}thresh}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=299\sphinxpxdimen,height=253\sphinxpxdimen]{{20210120-Bifurcation_model_dynamic_barcoding_17_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=279\sphinxpxdimen,height=253\sphinxpxdimen]{{20210120-Bifurcation_model_dynamic_barcoding_17_1}.png}

\end{nbsphinxfancyoutput}


\subsubsection{Transition map from a single clonal time point}
\label{\detokenize{20210120-Bifurcation_model_dynamic_barcoding:Transition-map-from-a-single-clonal-time-point}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[12]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{initial\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{clonal\PYGZus{}time\PYGZus{}point}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{adata}\PYG{o}{=}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{tmap}\PYG{o}{.}\PYG{n}{infer\PYGZus{}Tmap\PYGZus{}from\PYGZus{}one\PYGZus{}time\PYGZus{}clones}\PYG{p}{(}\PYG{n}{adata\PYGZus{}orig}\PYG{p}{,}\PYG{n}{initial\PYGZus{}time\PYGZus{}points}\PYG{p}{,}\PYG{n}{clonal\PYGZus{}time\PYGZus{}point}\PYG{p}{,}
     \PYG{n}{Clone\PYGZus{}update\PYGZus{}iter\PYGZus{}N}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{initialize\PYGZus{}method}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{OT}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{smooth\PYGZus{}array}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,}
                        \PYG{n}{noise\PYGZus{}threshold}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{,}\PYG{n}{compute\PYGZus{}new}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
-------------------------------New Start--------------------------------------------------
Current time point: 1
-----------Pre-processing and sub-sampling cells------------
----------------
Step 1: Use OT method for initialization
Compute new shortest path distance matrix
--> Chosen mode is distances
Finishing computing shortest-path distance, used time 1.8133256435394287
Compute new custon OT matrix
OT solver: duality\_gap
Finishing computing optial transport map, used time 2.0744729042053223
----------------
Step 2: Jointly optimize the transition map and the initial clonal states!
Joint optimization that consider possibility of clonal overlap: v2
--> original clone shape: (1894, 1669)
--> After excluding zero-sized clones at t2: (1894, 1334)
Sort clones by size (small to large)
Infer the number of initial cells to extract for each clone in advance
--> Inferring early clonal states: current clone id 0
--> Inferring early clonal states: current clone id 100
--> Inferring early clonal states: current clone id 200
--> Inferring early clonal states: current clone id 300
--> Inferring early clonal states: current clone id 400
--> Inferring early clonal states: current clone id 500
--> Inferring early clonal states: current clone id 600
--> Inferring early clonal states: current clone id 700
--> Inferring early clonal states: current clone id 800
--> Inferring early clonal states: current clone id 900
--> Inferring early clonal states: current clone id 1000
---------Compute the transition map-----------
Compute similarity matrix: computing new; beta=0.1
Smooth round: 1
--> Time elapsed: 0.0042688846588134766
Smooth round: 2
--> Time elapsed: 0.026350021362304688
--> Orignal sparsity=0.20817922210860954, Thresholding
--> Final sparsity=0.19417261646571343
similarity matrix truncated (Smooth round=2):  0.04873490333557129
Smooth round: 3
--> Time elapsed: 0.10690093040466309
--> Orignal sparsity=0.38404861012768604, Thresholding
--> Final sparsity=0.3351262643439127
similarity matrix truncated (Smooth round=3):  0.053813934326171875
Smooth round: 4
--> Time elapsed: 0.14299798011779785
--> Orignal sparsity=0.4768350897459771, Thresholding
--> Final sparsity=0.4027396023010474
similarity matrix truncated (Smooth round=4):  0.06744098663330078
Smooth round: 5
--> Time elapsed: 0.1661691665649414
--> Orignal sparsity=0.5275939469831369, Thresholding
--> Final sparsity=0.45277060109789263
similarity matrix truncated (Smooth round=5):  0.06412506103515625
Save the matrix\textasciitilde{}\textasciitilde{}\textasciitilde{}
Smooth round: 6
--> Time elapsed: 0.20180201530456543
--> Orignal sparsity=0.5694367474010631, Thresholding
--> Final sparsity=0.4926809945038464
similarity matrix truncated (Smooth round=6):  0.06461906433105469
Smooth round: 7
--> Time elapsed: 0.19090795516967773
--> Orignal sparsity=0.608515860121832, Thresholding
--> Final sparsity=0.5261845052848488
similarity matrix truncated (Smooth round=7):  0.06158709526062012
Smooth round: 8
--> Time elapsed: 0.27953195571899414
--> Orignal sparsity=0.6446768486935345, Thresholding
--> Final sparsity=0.5550340150466821
similarity matrix truncated (Smooth round=8):  0.07004117965698242
Smooth round: 9
--> Time elapsed: 0.2258460521697998
--> Orignal sparsity=0.6754060786633497, Thresholding
--> Final sparsity=0.5813643150325208
similarity matrix truncated (Smooth round=9):  0.07517480850219727
Smooth round: 10
--> Time elapsed: 0.26035118103027344
--> Orignal sparsity=0.7013976777663917, Thresholding
--> Final sparsity=0.6061248827788303
similarity matrix truncated (Smooth round=10):  0.07227110862731934
Save the matrix\textasciitilde{}\textasciitilde{}\textasciitilde{}
--> Time elapsed:  0.00563502311706543
--> Time elapsed:  0.015253067016601562
--> Time elapsed:  0.0025970935821533203
--> Time elapsed:  0.015963315963745117
Compute similarity matrix: load existing data
--> Time elapsed:  0.006258964538574219
--> Time elapsed:  0.015415191650390625
--> Time elapsed:  0.004996299743652344
--> Time elapsed:  0.015640735626220703
Compute similarity matrix: load existing data
--> Time elapsed:  0.005293130874633789
--> Time elapsed:  0.012995243072509766
--> Time elapsed:  0.0018811225891113281
--> Time elapsed:  0.013762712478637695
Current iteration: 0
Use smooth\_round=10
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
--> Clone id: 1000
Start to smooth the refined clonal map
Phase I: time elapsed --  0.003561258316040039
Phase II: time elapsed --  0.004846096038818359
Current iteration: 1
Use smooth\_round=10
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
--> Clone id: 1000
Start to smooth the refined clonal map
Phase I: time elapsed --  0.0029990673065185547
Phase II: time elapsed --  0.0046923160552978516
Current iteration: 2
Use smooth\_round=10
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
--> Clone id: 1000
Start to smooth the refined clonal map
Phase I: time elapsed --  0.002672910690307617
Phase II: time elapsed --  0.003962039947509766
Final round of Smooth (to expand the state space of Tmap to include non-clonal states)
Phase I: time elapsed --  0.002897024154663086
Phase II: time elapsed --  0.005712985992431641
----Demultiplexed transition map----
Clone normalization
--> Relative time point pair index: 0
--> Clone id: 0
--> Clone id: 1000
Finishing computing transport map from CoSpar using inferred clonal data, used time 8.200721025466919
-----------Total used time: 12.179482698440552 s ------------
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[13]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}bias\PYGZus{}from\PYGZus{}binary\PYGZus{}competition}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
            \PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{sum\PYGZus{}fate\PYGZus{}prob\PYGZus{}thresh}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=299\sphinxpxdimen,height=253\sphinxpxdimen]{{20210120-Bifurcation_model_dynamic_barcoding_20_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=285\sphinxpxdimen,height=253\sphinxpxdimen]{{20210120-Bifurcation_model_dynamic_barcoding_20_1}.png}

\end{nbsphinxfancyoutput}


\subsection{Transition amp from only the clonal information}
\label{\detokenize{20210120-Bifurcation_model_dynamic_barcoding:Transition-amp-from-only-the-clonal-information}}
{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[15]:\,\hspace{\fboxrule}\hspace{\fboxsep}} \PYG{n}{cs}\PYG{o}{.}\PYG{n}{tmap}\PYG{o}{.}\PYG{n}{infer\PYGZus{}Tmap\PYGZus{}from\PYGZus{}clonal\PYGZus{}info\PYGZus{}alone}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{)}

\PYG{n}{cs}\PYG{o}{.}\PYG{n}{pl}\PYG{o}{.}\PYG{n}{fate\PYGZus{}bias\PYGZus{}from\PYGZus{}binary\PYGZus{}competition}\PYG{p}{(}\PYG{n}{adata}\PYG{p}{,}\PYG{n}{selected\PYGZus{}fates}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{used\PYGZus{}map\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{clonal\PYGZus{}transition\PYGZus{}map}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
            \PYG{n}{plot\PYGZus{}time\PYGZus{}points}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{n}{plot\PYGZus{}target\PYGZus{}state}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}\PYG{n}{map\PYGZus{}backwards}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{sum\PYGZus{}fate\PYGZus{}prob\PYGZus{}thresh}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=299\sphinxpxdimen,height=253\sphinxpxdimen]{{20210120-Bifurcation_model_dynamic_barcoding_22_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=285\sphinxpxdimen,height=253\sphinxpxdimen]{{20210120-Bifurcation_model_dynamic_barcoding_22_1}.png}

\end{nbsphinxfancyoutput}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{c}
\item\relax\sphinxstyleindexentry{cospar}\sphinxstyleindexpageref{api:\detokenize{module-cospar}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}